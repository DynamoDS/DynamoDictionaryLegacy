[
    {
        "Name": "IsAlmostEqualTo",
        "imageFile": [
            "IsAlmostEqualTo"
        ],
        "dynFile": [
            "IsAlmostEqualTo"
        ],
        "folderPath": "Analyze/AnalysisExtensions/Action",
        "inDepth": "IsAlmostEqualTo will return a boolean value based on whether two input UV values are equal. In the example below, the UV parameters are compared at a Point on two nearly identical surfaces. Adjusting the sliders will choose different UV parameters to compare the surfaces at."
    },
    {
        "Name": "ByPointAndString",
        "imageFile": [],
        "dynFile": [],
        "folderPath": "Analyze/Label/Create",
        "inDepth": "Add in-depth information about ByPointAndString..."
    },
    {
        "Name": "AllFalse",
        "imageFile": [
            "AllFalse"
        ],
        "dynFile": [
            "AllFalse"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "AllFalse only returns <strong>true</strong> if <em>every</em> item in a list is false."
    },
    {
        "Name": "AllTrue",
        "imageFile": [
            "AllTrue"
        ],
        "dynFile": [
            "AllTrue"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "AllTrue only returns <strong>true</strong> if <em>every</em> item in a list is false."
    },
    {
        "Name": "Contains (list, element)",
        "imageFile": [
            "Contains (list, element)"
        ],
        "dynFile": [
            "Contains (list, element)"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Contains (list, element) will return a boolean value based on whether a List contains an input element. In the example below, a list of Red values extracted from a bitmap are tested for containing an input value of 0. This is helpful in establishing why the Circle.ByCenterPointRadius is displaying a warning as a circle cannot be created from a radius of 0."
    },
    {
        "Name": "Contains (list, element)",
        "imageFile": [
            "Contains (list, element)"
        ],
        "dynFile": [
            "Contains (list, element)"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Contains (list, element) will return a boolean value based on whether a List contains an input element. In the example below, a list of Red values extracted from a bitmap are tested for containing an input value of 0. This is helpful in establishing why the Circle.ByCenterPointRadius is displaying a warning as a circle cannot be created from a radius of 0."
    },
    {
        "Name": "ContainsKey",
        "imageFile": [
            "ContainsKey"
        ],
        "dynFile": [
            "ContainsKey"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "ContainsKey will return a boolean value depending on whether a List contains an input key. In the example below, a list of Red values extracted from a bitmap are tested for containing an Index value from an integer slider. Try adjusting the slider to see what values return true or false."
    },
    {
        "Name": "Count",
        "imageFile": [
            "Count"
        ],
        "dynFile": [
            "Count"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Count returns the amount of items in the input list or lists."
    },
    {
        "Name": "CountFalse",
        "imageFile": [
            "CountFalse"
        ],
        "dynFile": [
            "CountFalse"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "CountFalse returns the amount of false <strong>(boolean)</strong> values in the input list or lists."
    },
    {
        "Name": "CountTrue",
        "imageFile": [
            "CountTrue"
        ],
        "dynFile": [
            "CountTrue"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "CountTrue returns the amount of true <strong>(boolean)</strong> values in the input list or lists."
    },
    {
        "Name": "Equals",
        "imageFile": [
            "Equals"
        ],
        "dynFile": [
            "Equals"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Equals will return a boolean value that is true if ObjectA is equal to ObjectB. In the example below, the radii (doubles) of two circles are compared. Adjusting the sliders can change the circles' radii, making them equal or unequal."
    },
    {
        "Name": "Flatten",
        "imageFile": [
            "Flatten"
        ],
        "dynFile": [
            "Flatten"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Flatten will return a 1D List from a multi-dimensional List. In the example below, two List structures of a Point grid are compared by creating a Sphere at a specified Index of each. The flattened List of Points will return one Point at an Index location. The unflattened List will return 10 Points at an Index location as each Index contains a row of points."
    },
    {
        "Name": "GetKeys",
        "imageFile": [
            "GetKeys"
        ],
        "dynFile": [
            "GetKeys"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "GetKeys will return the keys (index values) of an input list as a new list. In the example below, the keys from a simple list of numbers are extracted as their own list."
    },
    {
        "Name": "GetValues",
        "imageFile": [
            "GetValues"
        ],
        "dynFile": [
            "GetValues"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "GetValues will return the values in a list as a new list. In the example below, a simple list of numbers is returned in a new list."
    },
    {
        "Name": "GroupByFunction",
        "imageFile": [
            "GroupByFunction"
        ],
        "dynFile": [
            "GroupByFunction"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "GroupByFunction will return a new list grouped by a function. In the example below, two different lists are grouped using List.GetItemAtIndex as the function. This function creates groups (a new list) from each top level index."
    },
    {
        "Name": "ImportFromCSV (filePath, transpose)",
        "imageFile": [
            "ImportFromCSV (filePath, transpose)"
        ],
        "dynFile": [
            "ImportFromCSV (filePath, transpose)"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "ImportFromCSV will return the contents of a CSV (Comma Separated Value) file as a list of lists with the ability to transpose the list (swap columns with rows). In the example below, imported values from a sample CSV are used to define the Z translation distance of a grid of points. The list structure of the imported values (list of lists) corresponds to the list structure of the point grid. Switching the boolean value for transpose will use different values from the CSV for translation distances. Each row of the CSV becomes a list."
    },
    {
        "Name": "ImportFromCSV (filePath)",
        "imageFile": [
            "ImportFromCSV (filePath)"
        ],
        "dynFile": [
            "ImportFromCSV (filePath)"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "ImportFromCSV will return the contents of a CSV (Comma Separated Value) file as a list of lists. In the example below, imported values from the a sample CSV are used to define the Z translation distance of a grid of points. The list structure of the imported values (list of lists) corresponds to list structure of the point grid. Each row of the CSV becomes a list."
    },
    {
        "Name": "IndexOf",
        "imageFile": [
            "IndexOf"
        ],
        "dynFile": [
            "IndexOf"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "IndexOf will return the Index location of a member in the List. In the example below, the number 3.8 in a List has an Index value of 2."
    },
    {
        "Name": "Insert (list, element, index)",
        "imageFile": [
            "Insert (list, element, index)"
        ],
        "dynFile": [
            "Insert (list, element, index)"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Insert will insert multiple elements into a list at a specified index. In the example below, a list of two strings \"Hello\" and \"List\" are inserted at index value 2, making the list one index longer."
    },
    {
        "Name": "Insert (list, element, index)",
        "imageFile": [
            "Insert (list, element, index)"
        ],
        "dynFile": [
            "Insert (list, element, index)"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Insert will insert multiple elements into a list at a specified index. In the example below, a list of two strings \"Hello\" and \"List\" are inserted at index value 2, making the list one index longer."
    },
    {
        "Name": "IsHomogeneous",
        "imageFile": [
            "IsHomogeneous"
        ],
        "dynFile": [
            "IsHomogeneous"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "IsHomogeneous will return a boolean value based on whether the elements in a list are all of the same type. In the example below, a simple list of numbers is compared to the same list with a string inserted. The original list is homogeneous (numbers) and the new list is not homogeneous (numbers and a string)."
    },
    {
        "Name": "IsRectangular",
        "imageFile": [
            "IsRectangular"
        ],
        "dynFile": [
            "IsRectangular"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "IsRectangular will return a boolean value based on whether a list's rows have the same number of elements. In the example below, a false value is returned for a grid of points with an extra point added to a row. A NurbsSurface cannot be created from this point collection until the value returned from IsRectangular is true as NurbsSurfaces require rectangular lists."
    },
    {
        "Name": "IsUniformDepth",
        "imageFile": [
            "IsUniformDepth"
        ],
        "dynFile": [
            "IsUniformDepth"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "IsUniformDepth will return a boolean value based on whether the list's depth is consistent (the number of lists inside each list). In the example below, two lists are compared (one of uniform depth and one not) to show the difference. The non-uniform list contains two lists, one of which has two more inside of that. The lists at [0] and [1] are not equal in depth."
    },
    {
        "Name": "LoopWhile",
        "imageFile": [
            "LoopWhile"
        ],
        "dynFile": [
            "LoopWhile"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "LoopWhile will return the result of a looped function until the constraints are met. In the example below, a simple loop is created to add 10, starting with 1, until the result is larger than 100. loopWhile accepts variables for its init input and functions for the continueWhile and loopBody inputs. continueWhile defines the constraints of the loop, which in this example is a < function and an argument of 100. loopBody defines what the loop does, which in this example is an + function with an argument of 10."
    },
    {
        "Name": "Map",
        "imageFile": [
            "Map"
        ],
        "dynFile": [
            "Map"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Map will return the position of a number in a range as a double. In the example below, a value of 4 is mapped to a range of 2 to 6. Since 4 is halfway between 2 and 6, a value of 0.5 is returned."
    },
    {
        "Name": "MapTo",
        "imageFile": [
            "MapTo"
        ],
        "dynFile": [
            "MapTo"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "MapTo will get the position of a number in a range (similar to the Map node), then map that position to a target range. A number in the target range is returned based on the position value. In the example below, the number 3 returns a position of 0.5 between a range of 2 and 4. That position value of 0.5 in a target range of 20 to 100 returns the number 60."
    },
    {
        "Name": "MaximumItemByKey",
        "imageFile": [
            "MaximumItemByKey"
        ],
        "dynFile": [
            "MaximumItemByKey"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "MaximumItemByKey will return the largest item in a list based on a key. In the example below, a series of three circles with increasing radii are compared using radius as the key. The circle at (5,0,0) is returned as it has the largest radius."
    },
    {
        "Name": "MinimumItemByKey",
        "imageFile": [
            "MinimumItemByKey"
        ],
        "dynFile": [
            "MinimumItemByKey"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "MinimumItemByKey will return the smallest item in a list based on a key. In the example below, a series of three circles with increasing radii are compared using radius as the key. The circle at the origin is returned as it has the smallest radius."
    },
    {
        "Name": "NewtonRootFind1DNoDeriv",
        "imageFile": [],
        "dynFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about NewtonRootFind1DNoDeriv..."
    },
    {
        "Name": "NewtonRootFind1DWithDeriv",
        "imageFile": [],
        "dynFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about NewtonRootFind1DWithDeriv..."
    },
    {
        "Name": "NormalizeDepth (list)",
        "imageFile": [
            "NormalizeDepth (list)"
        ],
        "dynFile": [
            "NormalizeDepth (list)"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "NormalizeDepth will return a new list of uniform depth. In the example below, a list contains two lists of unequal depth. The first list, [0], contains 6 elements. The second list [1], contains two lists each with 6 elements. Normalizing this list gives list [0] the depth of [1] by putting each of it's elements in its own list. Now both [0] and [1] have an equal depth of sub-lists."
    },
    {
        "Name": "NormalizeDepth (list, rank)",
        "imageFile": [
            "NormalizeDepth (list, rank)"
        ],
        "dynFile": [
            "NormalizeDepth (list, rank)"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "NormalizeDepth will return a new list of uniform depth to a specified rank. In the example below, a list containing two lists of unequal depth can be normalized to different ranks with an integer slider. By normalizing the depths at different ranks the list increases or decreases in depth, but is always uniform. A list of rank 1 will return single list of elements, while a list of rank 3 will return two levels of sub-lists. See node NormalizeDepth (list) for a more detailed description of normalization."
    },
    {
        "Name": "Rank",
        "imageFile": [],
        "dynFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Counts how many levels are in a list"
    },
    {
        "Name": "RemoveIfNot",
        "imageFile": [
            "RemoveIfNot"
        ],
        "dynFile": [
            "RemoveIfNot"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "RemoveIfNot will return a list with everything removed except a specified type. In the example below, a list is returned with one Line and the Point elements removed."
    },
    {
        "Name": "RemoveKey",
        "imageFile": [
            "RemoveKey"
        ],
        "dynFile": [
            "RemoveKey"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about RemoveKey..."
    },
    {
        "Name": "Reorder",
        "imageFile": [
            "Reorder"
        ],
        "dynFile": [
            "Reorder"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Reorder will return a new list based on a different order of the original list's indices. In the example below, a new list is created by manually changing the index order."
    },
    {
        "Name": "SetDifference",
        "imageFile": [
            "SetDifference"
        ],
        "dynFile": [
            "SetDifference"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "SetDifference will return a new list based on the objects that one list contains and another does not. In the example below, a list of 0 to 9 counting by 1 is compared to a list of 0 to 18 counting by 2. Odd numbers below 10 are returned because they are contained in List1, but not in List2."
    },
    {
        "Name": "SetIntersection",
        "imageFile": [
            "SetIntersection"
        ],
        "dynFile": [
            "SetIntersection"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "SetIntersection will return a new list based on the objects that both lists both contain. In the example below, a list of 0 to 9 counting by 1 is compared to a list of 0 to 18 counting by 2. Even numbers below 10 are returned because they are contained in List1 and List2."
    },
    {
        "Name": "SetUnion",
        "imageFile": [
            "SetUnion"
        ],
        "dynFile": [
            "SetUnion"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "SetUnion will return a new list by combining the objects of two lists using an equality comparer (eliminate duplicate values). In the example below, a list of 0 to 9 counting by 1 is combined with a list of 0 to 18 counting by 2. The resulting list counts contains all elements from List1 and List2 with duplicates (0, 2, 4, etc) eliminated."
    },
    {
        "Name": "SortByFunction",
        "imageFile": [
            "SortByFunction"
        ],
        "dynFile": [
            "SortByFunction"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "SortByFunction will return a list sorted by a function. In the example below, a line is drawn through a list of randomly placed points that have been sorted with different functions. The first curve through an unsorted list is non-directional. Sorting the list using the X or Y component of each point results in directional lines progressing across X or Y."
    },
    {
        "Name": "SortIndexByValue (list, ascending)",
        "imageFile": [
            "SortIndexByValue (list, ascending)"
        ],
        "dynFile": [
            "SortIndexByValue (list, ascending)"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "SortIndexByValue will return a list of indices sorted by their member's values, either ascending or descending by a boolean toggle. In the example below, a list of random numbers is sorted by ascending and descending order and a new order is returned as index values."
    },
    {
        "Name": "SortIndexByValue (list)",
        "imageFile": [
            "SortIndexByValue (list)"
        ],
        "dynFile": [
            "SortIndexByValue (list)"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "SortIndexByValue will return a list of indices sorted by their member's values in ascending order. In the example below, a list of random numbers is sorted, and a new order is returned as index values."
    },
    {
        "Name": "TrueForAll",
        "imageFile": [
            "TrueForAll"
        ],
        "dynFile": [
            "TrueForAll"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Checks to see if the condition (in the predicate input) is true for ALL of the items in the list. You need to connect a node to the predicate input that returns a boolean."
    },
    {
        "Name": "TrueForAny",
        "imageFile": [
            "TrueForAny"
        ],
        "dynFile": [
            "TrueForAny"
        ],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Checks to see if the condition (in the predicate input) is true for ANY of the items in the list. You need to connect a node to the predicate input that returns a boolean."
    },
    {
        "Name": "Add",
        "imageFile": [
            "Add"
        ],
        "dynFile": [
            "Add"
        ],
        "folderPath": "Core/Color/Create",
        "inDepth": "Add will add the individual channels of two colors together, and return the resulting color. Note that the resulting values must be less than 255. In the example below, we create two colors using ByARGB nodes. We then use an Add node to add the two colors together. A Display.ByGeometryColor node is used with a default cuboid in order to visualize the resulting color."
    },
    {
        "Name": "ByARGB",
        "imageFile": [
            "ByARGB"
        ],
        "dynFile": [
            "ByARGB"
        ],
        "folderPath": "Core/Color/Create",
        "inDepth": "ByARGB will create a color using input Alpha, Red, Green, and Blue values. The input values are in the range 0 to 255. In the example below, we use 4 number sliders set to the range 0 to 255 to control the input values of a ByARGB node. A Display.ByGeometryColor node is used with a default cuboid in order to visualize the resulting color."
    },
    {
        "Name": "Color Range",
        "imageFile": [
            "Color_Range"
        ],
        "dynFile": [
            "Color_Range"
        ],
        "folderPath": "Core/Color/Create",
        "inDepth": "Color Range will create a gradient between a set of input colors, and allow colors from that gradient to be selected by a list of input values. The first input, colors, is a list of colors to use in the gradient. The second inut, indices, will determine the relative location of the input colors in the gradient. This list should correspond to the list of colors, each value being in the range 0 to 1. The exact value is not important, only the relative position of the values. The color corresponding to the lowest value will be on the left of the gradient, and the color corresponding to the highest value will be on the right side of the gradient. The final values input allows the user to select points along the gradient in the range 0 to 1 to output. In the example below, we first create two colors: red and green. The order of these colors in the gradient is determined by a list that we create with a code block. A third code block is used to create a range of numbers between 0 and 1 that will determine the output colors from the gradient. A set of cubes is generated along the x-axis, and these cubes are finally colored according the gradient by using a Display.ByGeometryColor node."
    },
    {
        "Name": "Divide",
        "imageFile": [
            "Divide"
        ],
        "dynFile": [
            "Divide"
        ],
        "folderPath": "Core/Color/Create",
        "inDepth": "Divide will divide the individual channels a color by in input number, and return the resulting color. Note that the resulting values must be less than 255. In the example below, we create a color using ByARGB nodes. We then use a Divide node to divide the color by a number controlled with a number slider. A Display.ByGeometryColor node is used with a default cuboid in order to visualize the resulting color."
    },
    {
        "Name": "Multiply",
        "imageFile": [
            "Multiply"
        ],
        "dynFile": [
            "Multiply"
        ],
        "folderPath": "Core/Color/Create",
        "inDepth": "Multiply will multiply the individual channels a color by in input number, and return the resulting color. Note that the resulting values must be less than 255. In the example below, we create a color using ByARGB nodes. We then use a Multiply node to multiply the color by a number controlled with a number slider. A Display.ByGeometryColor node is used with a default cuboid in order to visualize the resulting color."
    },
    {
        "Name": "Brightness",
        "imageFile": [
            "Brightness"
        ],
        "dynFile": [
            "Brightness"
        ],
        "folderPath": "Core/Color/Action",
        "inDepth": "Brightness will return the brightness value of an input color in the range 0 to 1. In the example below, we create two colors using ByARGB nodes, and then add the two colors together. The brightness value of the resulting color is found by using a Brightness node."
    },
    {
        "Name": "Components",
        "imageFile": [
            "Components"
        ],
        "dynFile": [
            "Components"
        ],
        "folderPath": "Core/Color/Action",
        "inDepth": "Components will return the Alpha, Red, Blue, and Green values of an input color in the range 0 to 255. In the example below, we create two colors using ByARGB nodes, and then add the two colors together. The resulting individual color components can then be extracted using a Components node."
    },
    {
        "Name": "Hue",
        "imageFile": [
            "Hue"
        ],
        "dynFile": [
            "Hue"
        ],
        "folderPath": "Core/Color/Action",
        "inDepth": "Hue will return the hue value of an input color. In the example below, we create two colors using ByARGB nodes, and then add the two colors together. The hue value of the resulting color is found by using a Hue node."
    },
    {
        "Name": "Saturation",
        "imageFile": [
            "Saturation"
        ],
        "dynFile": [
            "Saturation"
        ],
        "folderPath": "Core/Color/Action",
        "inDepth": "Saturation will return the saturation value of an input color in the range 0 to 1. In the example below, we create two colors using ByARGB nodes, and then add the two colors together. The saturation value of the resulting color is found by using a Saturation node."
    },
    {
        "Name": "Alpha",
        "imageFile": [
            "Alpha"
        ],
        "dynFile": [
            "Alpha"
        ],
        "folderPath": "Core/Color/Query",
        "inDepth": "Alpha will return the alpha value of an input color in the range 0 to 255. In the example below, we create two colors using ByARGB nodes, and then add the two colors together. The alpha value of the resulting color is found by using an Alpha node."
    },
    {
        "Name": "Blue",
        "imageFile": [
            "Blue"
        ],
        "dynFile": [
            "Blue"
        ],
        "folderPath": "Core/Color/Query",
        "inDepth": "Blue will return the blue value of an input color in the range 0 to 255. In the example below, we create two colors using ByARGB nodes, and then add the two colors together. The blue value of the resulting color is found by using a Blue node."
    },
    {
        "Name": "Green",
        "imageFile": [
            "Green"
        ],
        "dynFile": [
            "Green"
        ],
        "folderPath": "Core/Color/Query",
        "inDepth": "Green will return the green value of an input color in the range 0 to 255. In the example below, we create two colors using ByARGB nodes, and then add the two colors together. The green value of the resulting color is found by using a Green node."
    },
    {
        "Name": "Red",
        "imageFile": [
            "Red"
        ],
        "dynFile": [
            "Red"
        ],
        "folderPath": "Core/Color/Query",
        "inDepth": "Red will return the red value of an input color in the range 0 to 255. In the example below, we create two colors using ByARGB nodes, and then add the two colors together. The red value of the resulting color is found by using a Red node."
    },
    {
        "Name": "ByColorsAndParameters",
        "imageFile": [
            "ByColorsAndParameters"
        ],
        "dynFile": [
            "ByColorsAndParameters"
        ],
        "folderPath": "Core/ColorRange2D/Create",
        "inDepth": "ByColorsAndParameters creates an  2D color range from a list of input colors and a corresponding list of specified UV parameters in the range 0 to 1. In the example below, we use a code block to create three different colors (in this case simply green, red, and blue) and to combine them into a list. We use a separate code block to create three UV parameters, one for each color. These two lists are used as inputs to a ByColorsAndParameters node. We use a subsequent GetColorAtParameter node, along with a Display.ByGeometryColor node to visualize the 2D color range across a set of cubes."
    },
    {
        "Name": "GetColorAtParameter",
        "imageFile": [
            "GetColorAtParameter"
        ],
        "dynFile": [
            "GetColorAtParameter"
        ],
        "folderPath": "Core/ColorRange2D/Action",
        "inDepth": "GetColorAtParameter takes an input 2D color range, and returns a list of colors at specified UV parameters in the range 0 to 1. In the example below, we first create a 2D Color Range using a ByColorsAndParameters node with a list of colors and list of parameters to set the range. A code block is used to generate a range of numbers between 0 and 1, which is used as the u and v inputs in a UV.ByCoordinates node. The lacing of this node is set to cross product. A set of cubes is created in a similar manner, which a Point.ByCoordinates node with cross product lacing used to created an array of cubes. We then use a Display.ByGeometryColor node with the array of cubes and the list of colors obtained from the GetColorAtParameter node."
    },
    {
        "Name": "AddTimeSpan",
        "imageFile": [
            "AddTimeSpan"
        ],
        "dynFile": [
            "AddTimeSpan"
        ],
        "folderPath": "Core/DateTime/Action",
        "inDepth": "AddTimeSpan will return a new dateTime with a timeSpan added to it. In the example below, one day and eight hours is added to the dateTime for Now, returning a date that is one day and eight hours ahead."
    },
    {
        "Name": "ByDate",
        "imageFile": [
            "ByDate"
        ],
        "dynFile": [
            "ByDate"
        ],
        "folderPath": "Core/DateTime/Action",
        "inDepth": "ByDate will return a dateTime from year, month, and day inputs. In the example below, a new dateTime of August 08, 2006 is created from those respective inputs."
    },
    {
        "Name": "ByDateAndTime",
        "imageFile": [
            "ByDateAndTime"
        ],
        "dynFile": [
            "ByDateAndTime"
        ],
        "folderPath": "Core/DateTime/Action",
        "inDepth": "ByDateAndTime will return a dateTime from year, month, day, hour, minute, second, and millisecond inputs. In the example below, a new dateTime of August 08, 2006 4:24PM is created from those respective inputs."
    },
    {
        "Name": "Components",
        "imageFile": [
            "Components"
        ],
        "dynFile": [
            "Components"
        ],
        "folderPath": "Core/DateTime/Action",
        "inDepth": "Components will return what makes up a DateTime such as the Year, Month, Day, Hour, etc. In the example below, a DateTime of Now returns 2016 for Year, 11 for Month, 9 for Day, and 17 for Hour."
    },
    {
        "Name": "Date",
        "imageFile": [
            "Date"
        ],
        "dynFile": [
            "Date"
        ],
        "folderPath": "Core/DateTime/Action",
        "inDepth": "Date will return only the date (year, month, day) from a dateTime. In the example below, only the date, August 08 2006, is extracted from a dateTime, August 08, 2006 4:24PM."
    },
    {
        "Name": "DayOfWeek",
        "imageFile": [
            "DayOfWeek"
        ],
        "dynFile": [
            "DayOfWeek"
        ],
        "folderPath": "Core/DateTime/Action",
        "inDepth": "DayOfWeek will return only the day from a dateTime. In the example below, only the day, Tuesday, is extracted from a dateTime, August 08, 2006 4:24PM."
    },
    {
        "Name": "DayOfYear",
        "imageFile": [
            "DayOfYear"
        ],
        "dynFile": [
            "DayOfYear"
        ],
        "folderPath": "Core/DateTime/Action",
        "inDepth": "DayOfYear will return the day of the year from a dateTime as a number. In the example below, the dateTime, August 08, 2006 4:24PM, is day 220 of the year."
    },
    {
        "Name": "DaysInMonth",
        "imageFile": [
            "DaysInMonth"
        ],
        "dynFile": [
            "DaysInMonth"
        ],
        "folderPath": "Core/DateTime/Action",
        "inDepth": "DaysInMonth will return the number of days in a month of a certain year. In the example below, August 2006 returns 31 days."
    },
    {
        "Name": "FromString",
        "imageFile": [
            "FromString"
        ],
        "dynFile": [
            "FromString"
        ],
        "folderPath": "Core/DateTime/Action",
        "inDepth": "FromString creates a dateTime from a string. The string can contain years through milliseconds. In the example below, a dateTime of November 14, 2016 12:36PM is created from a string."
    },
    {
        "Name": "IsDaylightSavingsTime",
        "imageFile": [
            "IsDaylightSavingsTime"
        ],
        "dynFile": [
            "IsDaylightSavingsTime"
        ],
        "folderPath": "Core/DateTime/Action",
        "inDepth": "IsDaylightSavingsTime will return a boolean value based on whether the dateTime falls within Daylight Saving Time. In the example below, a dateTime of November 14, 2016 12:36PM returns false."
    },
    {
        "Name": "IsLeapYear",
        "imageFile": [
            "IsLeapYear"
        ],
        "dynFile": [
            "IsLeapYear"
        ],
        "folderPath": "Core/DateTime/Action",
        "inDepth": "IsLeapYear will return a boolean value based on whether a dateTime falls within a Leap Year. In the example below, a dateTime of 2016 returns true!"
    },
    {
        "Name": "SubtractTimeSpan",
        "imageFile": [
            "SubtractTimeSpan"
        ],
        "dynFile": [
            "SubtractTimeSpan"
        ],
        "folderPath": "Core/DateTime/Action",
        "inDepth": "SubtractTimeSpan will return a new dateTime by subtracting a timeSpan from a dateTime. In the example below, a timeSpan of one day and eight hours is subtracted from a dateTime of Now, returning November 13, 2016 4:40AM."
    },
    {
        "Name": "TimeOfDay",
        "imageFile": [
            "TimeOfDay"
        ],
        "dynFile": [
            "TimeOfDay"
        ],
        "folderPath": "Core/DateTime/Action",
        "inDepth": "TimeOfDay will return the time past midnight of a dateTime. In the example below, a dateTime of Now returns 12:40:32 or roughly 12:40PM."
    },
    {
        "Name": "MaxValue",
        "imageFile": [
            "MaxValue"
        ],
        "dynFile": [
            "MaxValue"
        ],
        "folderPath": "Core/DateTime/Query",
        "inDepth": "MaxValue will return the maximum value that a dateTime can have. In the example below, a dateTime of December 31, 9999 11:59PM is returned."
    },
    {
        "Name": "MinValue (())",
        "imageFile": [
            "MinValue (())"
        ],
        "dynFile": [
            "MinValue (())"
        ],
        "folderPath": "Core/DateTime/Query",
        "inDepth": "MinValue will return the minimum value that a dateTime can have. In the example below, a dateTime of January 01, 0001 12:00AM is returned."
    },
    {
        "Name": "MinValue (year, month, day)",
        "imageFile": [],
        "dynFile": [],
        "folderPath": "Core/DateTime/Query",
        "inDepth": "Add in-depth information about MinValue (year, month, day)..."
    },
    {
        "Name": "Now",
        "imageFile": [
            "Now"
        ],
        "dynFile": [
            "Now"
        ],
        "folderPath": "Core/DateTime/Query",
        "inDepth": "Now will return the current system date and time. The example file below showed Now as returning November 14, 2016 12:48PM when it was created."
    },
    {
        "Name": "Today",
        "imageFile": [
            "Today"
        ],
        "dynFile": [
            "Today"
        ],
        "folderPath": "Core/DateTime/Query",
        "inDepth": "Today will return the current date. The example file below showed Today as returning November 14, 2016 12:00AM when it was created."
    },
    {
        "Name": "Friday",
        "imageFile": [
            "Friday"
        ],
        "dynFile": [
            "Friday"
        ],
        "folderPath": "Core/DayOfWeek/Query",
        "inDepth": "Friday will return Friday as a DayOfWeek."
    },
    {
        "Name": "Monday",
        "imageFile": [
            "Monday"
        ],
        "dynFile": [
            "Monday"
        ],
        "folderPath": "Core/DayOfWeek/Query",
        "inDepth": "Monday will return Monday as a DayOfWeek."
    },
    {
        "Name": "Saturday",
        "imageFile": [
            "Saturday"
        ],
        "dynFile": [
            "Saturday"
        ],
        "folderPath": "Core/DayOfWeek/Query",
        "inDepth": "Saturday will return Saturday as a DayOfWeek."
    },
    {
        "Name": "Sunday",
        "imageFile": [
            "Sunday"
        ],
        "dynFile": [
            "Sunday"
        ],
        "folderPath": "Core/DayOfWeek/Query",
        "inDepth": "Sunday will return Sunday as a DayOfWeek."
    },
    {
        "Name": "Thursday",
        "imageFile": [
            "Thursday"
        ],
        "dynFile": [
            "Thursday"
        ],
        "folderPath": "Core/DayOfWeek/Query",
        "inDepth": "Thursday will return Thursday as a DayOfWeek."
    },
    {
        "Name": "Tuesday",
        "imageFile": [
            "Tuesday"
        ],
        "dynFile": [
            "Tuesday"
        ],
        "folderPath": "Core/DayOfWeek/Query",
        "inDepth": "Tuesday will return Tuesday as a DayOfWeek."
    },
    {
        "Name": "Wednesday",
        "imageFile": [
            "Wednesday"
        ],
        "dynFile": [
            "Wednesday"
        ],
        "folderPath": "Core/DayOfWeek/Query",
        "inDepth": "Wednesday will return Wednesday as a DayOfWeek."
    },
    {
        "Name": "Function.Apply",
        "imageFile": [
            "Function.Apply"
        ],
        "dynFile": [
            "Function.Apply"
        ],
        "folderPath": "Core/Evaluate/Action",
        "inDepth": "Function.Apply will return the result of a function with supplied arguments. In the example below, arguments of a point and vector are applied to a translate function returning a translated point."
    },
    {
        "Name": "Function.Compose",
        "imageFile": [
            "Function.Compose"
        ],
        "dynFile": [
            "Function.Compose"
        ],
        "folderPath": "Core/Evaluate/Action",
        "inDepth": "Function.Compose will return a single function from multiple functions. In the example below, the modulus and divide functions are composed into a single function to apply to a list."
    },
    {
        "Name": "Directory.FromPath",
        "imageFile": [
            "DirectoryFromPath"
        ],
        "dynFile": [
            "DirectoryFromPath"
        ],
        "folderPath": "Core/File/Action",
        "inDepth": "Directory FromPath will create a directory object from an input directory path. In the example below, we use a Directory Path input node, which allows us to select a directory path by clicking the 'Browse...' button. A directory path can also be created as a string. A Directory.FromPath node is used to convert the directory path string into a directory object that can be used for directory inputs, such as a Contents node."
    },
    {
        "Name": "File.FromPath",
        "imageFile": [
            "FileFromPath"
        ],
        "dynFile": [
            "FileFromPath"
        ],
        "folderPath": "Core/File/Action",
        "inDepth": "File FromPath will create a file object from an input file path. In the example below, we use a File Path input node, which allows us to select a file path by clicking the 'Browse...' button. A file path can also be created manually as a string. A File.FromPath node is used to convert the file path string into a file object that can be used for file inputs, such as a ReadFromFile node"
    },
    {
        "Name": "ReadFromFile",
        "imageFile": [
            "ReadFromFile"
        ],
        "dynFile": [
            "ReadFromFile"
        ],
        "folderPath": "Core/File/CSV/Action",
        "inDepth": "Read From File takes a file as input. The file should be a text file that has data separated by commas. The different lines in the file correspond to the outer list, while the individual values in each line correspond to the inner lists. In the example below, we first use a File Path node and a File.FromPath node to create a file object that points to a text file. Then we use a ReadFromFile node to create a list from the CSV file."
    },
    {
        "Name": "WriteToFile",
        "imageFile": [
            "WriteToFile"
        ],
        "dynFile": [
            "WriteToFile"
        ],
        "folderPath": "Core/File/CSV/Action",
        "inDepth": "Write To File will produce a CSV file from list of data. The outer lists correspond to lines in the resulting file, while the inner lists correspond to individual values separated by commas in each line. In the example below, we use a File Path node to specify the file we want to write to. A Code Block node is used to create an example list that we will write as a CSV."
    },
    {
        "Name": "Contents",
        "imageFile": [
            "Contents"
        ],
        "dynFile": [
            "Contents"
        ],
        "folderPath": "Core/File/Directory/Action",
        "inDepth": "Contents will return a list of files and directories that are contained within a given directory. An optional searchString can be used to filter the results. In the example below, we first use a Directory Path node and a Directory.FromPath node to create a directory object. We can then get the contents of this directory with a Contents node. We use the search string '*.txt' to filter for only text files."
    },
    {
        "Name": "Copy",
        "imageFile": [
            "Copy"
        ],
        "dynFile": [
            "Copy"
        ],
        "folderPath": "Core/File/Directory/Action",
        "inDepth": "Copy will copy the files and subfolders from one directory to another. The directory to copy from is input as a director object, while the directory to copy to is input as a director path object. An additional boolean input gives the option to overwrite files or not. This node is automatically activated when the input values change.  In the example below, we first use a Directory Path node and a Directory.FromPath node to create a directory object. A second Directory Path node is used to specify the directory we want to copy to."
    },
    {
        "Name": "Delete",
        "imageFile": [
            "Delete"
        ],
        "dynFile": [
            "Delete"
        ],
        "folderPath": "Core/File/Directory/Action",
        "inDepth": "Delete will delete the directory specified by the input directory path. A second input accepts a boolean value to control whether the delete node is recursive or not. If recursive is set to false, this node will only delete empty directories. If recursive is set to true, the node will delete all the files and subfolders within the given directory. In the example below, we use a Directory Path node to set the directory to delete, and we use a boolean toggle to set the recursive input to true."
    },
    {
        "Name": "Exists",
        "imageFile": [
            "Exists"
        ],
        "dynFile": [
            "Exists"
        ],
        "folderPath": "Core/File/Directory/Action",
        "inDepth": "Exists takes a directory path as input and returns a boolean value based on whether that directory path exists or not. In the example below, we previously used a Delete node to delete the directory specified by the Directory Path. Using an Exists node with the same directory shows that the directory no longer exists."
    },
    {
        "Name": "Move",
        "imageFile": [
            "Move"
        ],
        "dynFile": [
            "Move"
        ],
        "folderPath": "Core/File/Directory/Action",
        "inDepth": "Move will move the files from the current directory to a new directory. If the new directory does not exist, this node will create it. This node is automatically activated when the input values change. In the example below, we use a Directory Path node to specify the directory to copy from. Since the directory we want to move to does not yet exist, we use a Code Block to manually specify the path of the directory to move to."
    },
    {
        "Name": "Copy",
        "imageFile": [
            "Copy"
        ],
        "dynFile": [
            "Copy"
        ],
        "folderPath": "Core/File/File/Action",
        "inDepth": "Copy will copy a file specified by an input file object to a new file specified by a file path. A boolean input gives the option to overwrite existing files. This node is automatically activated when the input values change. In the example below, we first use a File Path node followed by a File.FromPath node to create a file object to copy. A destination path is created by using a Combine node that allows us to combine a directory path with a file name."
    },
    {
        "Name": "Delete",
        "imageFile": [
            "Delete"
        ],
        "dynFile": [
            "Delete"
        ],
        "folderPath": "Core/File/File/Action",
        "inDepth": "Delete will delete a file specified by an input file path. In the example below, we use a File Path node to browse for the file we want to delete."
    },
    {
        "Name": "Exists",
        "imageFile": [
            "Exists"
        ],
        "dynFile": [
            "Exists"
        ],
        "folderPath": "Core/File/File/Action",
        "inDepth": "Exists will return a boolean value based on whether a file exists or not. In the example below, we use a File Path node to input a file path. After using a Delete node, we can see by using an Exists node that the file no longer exists."
    },
    {
        "Name": "Move",
        "imageFile": [
            "Move"
        ],
        "dynFile": [
            "Move"
        ],
        "folderPath": "Core/File/File/Action",
        "inDepth": "Move will move a file from a specifed path to a new path. A boolean input gives the option to overwrite any existing files. In the example below, we use a File Path node to browse for a file to move. We get the file name from that file by using a FileName node, and combine that with a Director Path to create a new file path to move the file to."
    },
    {
        "Name": "ReadText",
        "imageFile": [
            "ReadText"
        ],
        "dynFile": [
            "ReadText"
        ],
        "folderPath": "Core/File/File/Action",
        "inDepth": "ReadText will create a string from specified file path. In the example below, we use a File Path node to browse for the file to read. A Watch node is used to see the string that results from the ReadText node."
    },
    {
        "Name": "WriteText",
        "imageFile": [
            "WriteText"
        ],
        "dynFile": [
            "WriteText"
        ],
        "folderPath": "Core/File/File/Action",
        "inDepth": "WriteText will write a string to a specified file. If the file does not exists, this node will create the file. To create newlines in the output file, we can use the escape character '\\r\\n'. In the example below, we have a list of strings that we want to write as three separate lines in a text file. We join the list into a single string using '\\r\\n' as the separator. We then use a WriteText node to write this to a text file."
    },
    {
        "Name": "ChangeExtension",
        "imageFile": [
            "ChangeExtension"
        ],
        "dynFile": [
            "ChangeExtension"
        ],
        "folderPath": "Core/File/FilePath/Action",
        "inDepth": "Change Extension will replace the extension of an input file path object with a specified new extension input as a string. In the example below, we use a File Path node to browse for a .txt file. We then use a ChangeExtension node to create a new file path with a different extension by replacing the .txt with a .exp extension."
    },
    {
        "Name": "Combine",
        "imageFile": [
            "Combine"
        ],
        "dynFile": [
            "Combine"
        ],
        "folderPath": "Core/File/FilePath/Action",
        "inDepth": "Combine will join multiple inputs together into a single string. In the example below, we use a Director Path to select a director. We specify a file name by using a Code Block. We then use a Combine node to join the director path and file name together into a file path."
    },
    {
        "Name": "DirectoryName",
        "imageFile": [
            "DirectoryName"
        ],
        "dynFile": [
            "DirectoryName"
        ],
        "folderPath": "Core/File/FilePath/Action",
        "inDepth": "Directory Name will return the director of a file or director path. In the example below, we use a DirectorPath node to extract the directory from a file path. In addition to FileName and Extension, this allows us to break apart a file path into separate components."
    },
    {
        "Name": "Extension",
        "imageFile": [
            "Extension"
        ],
        "dynFile": [
            "Extension"
        ],
        "folderPath": "Core/File/FilePath/Action",
        "inDepth": "Extension will return the extension from a file path. In addition to FileName and DirectoryName, this allows us to break apart a file path into separate components."
    },
    {
        "Name": "FileName",
        "imageFile": [
            "FileName"
        ],
        "dynFile": [
            "FileName"
        ],
        "folderPath": "Core/File/FilePath/Action",
        "inDepth": "File Name will return the file name from an input file path. A boolean input provides to option to return the file name with or without the extension. In addition to DirectoryName and Extension, this allows us to break apart a file path into separate components."
    },
    {
        "Name": "HasExtension",
        "imageFile": [
            "HasExtension"
        ],
        "dynFile": [
            "HasExtension"
        ],
        "folderPath": "Core/File/FilePath/Action",
        "inDepth": "Has Extension returns a boolean value that is true if the input file path has an extension, and false if the input file path does not have an extension. In the example below, we use a File Path node to browse for a file. This path has the extension .txt, so HasExtension returns true."
    },
    {
        "Name": "Dimensions",
        "imageFile": [
            "Dimensions"
        ],
        "dynFile": [
            "Dimensions"
        ],
        "folderPath": "Core/File/Image/Action",
        "inDepth": "Dimensions will return the width and height of an input image in pixels. In the example below, we first use a File Path node and a File.FromPath to create a file object that points to an image. Image.ReadFromFile is then used to create an image object based on the file. A Dimensions node shows us that this image has a width and height of 270 pixels."
    },
    {
        "Name": "FromPixels (colors, width, height)",
        "imageFile": [
            "FromPixels_cwh"
        ],
        "dynFile": [
            "FromPixels_cwh"
        ],
        "folderPath": "Core/File/Image/Action",
        "inDepth": "From Pixels with width and height will create an image from an input flat list of colors, where each color will become one pixel. The width multiplied by the height should equal the total number of colors. In the example below, we first create a list of colors using a ByARGB node. A code block creates a range of values from 0 to 255, which when connected to the r and g inputs produces a series of colors from black to yellow. We create a image with a width of 8. A Count node and Division node are used to determine the height of the image. A Watch Image node can be used to preview the image created."
    },
    {
        "Name": "FromPixels (colors)",
        "imageFile": [
            "FromPixels_c"
        ],
        "dynFile": [
            "FromPixels_c"
        ],
        "folderPath": "Core/File/Image/Action",
        "inDepth": "From Pixels will create an image object from an input two-dimensional array of colors. In the example below, we first use a code block to generate a range of numbers from 0 to 255. A Color.ByARGB node is used to create colors from this range, and the lacing of this node is set to Cross Product to create a two-dimensional array. We then use an Image.FromPixels node to create an image. A Watch Image node can be used to preview the image created."
    },
    {
        "Name": "Pixels",
        "imageFile": [
            "Pixels"
        ],
        "dynFile": [
            "Pixels"
        ],
        "folderPath": "Core/File/Image/Action",
        "inDepth": "Pixels will return a list of colors from an input image as a two-dimensional array. The Pixels node has two additional inputs to specify the number of x and y samples to use to extract pixels from. In the example below, we read an image using a ReadFromFile node. This image is then input into a Pixels node to extract the pixel colors."
    },
    {
        "Name": "ReadFromFile",
        "imageFile": [
            "ReadFromFile"
        ],
        "dynFile": [
            "ReadFromFile"
        ],
        "folderPath": "Core/File/Image/Action",
        "inDepth": "Read From File will create an image object from an input file object. In the example below, we use a FilePath node followed by a File.FromPath node to create a file object to use as the input to a ReadFromFile node. A Watch Image node is used to preview the loaded image."
    },
    {
        "Name": "WriteToFile",
        "imageFile": [
            "WriteToFile"
        ],
        "dynFile": [
            "WriteToFile"
        ],
        "folderPath": "Core/File/Image/Action",
        "inDepth": "Write to File will write an image to a specified file path. This node is automatically activated when the inputs change. In the example below, we use an Image.FromPixels node to create an image object based on a generated set of colors. A FilePath node is used to specify the directory and file name to write this image to."
    },
    {
        "Name": "Evaluate",
        "imageFile": [
            "Evaluate"
        ],
        "dynFile": [
            "Evaluate"
        ],
        "folderPath": "Core/Formula/Action",
        "inDepth": "Evaluate will return a result based on a supplied formula as string, it's parameters, and arguments. In the example below, the radius lengths of two circles are compared using a conditional formula to return a boolean value."
    },
    {
        "Name": "Boolean",
        "imageFile": ["Boolean"],
        "dynFile": ["Boolean"],
        "folderPath": "Core/Input/Action",
        "inDepth": "The Boolean node allows the user to toggle between two boolean values 'true' or 'false' by selecting the appropriate radio button. "
    },
    {
        "Name": "Code Block (())",
        "imageFile": ["CodeBlock"],
        "dynFile": ["CodeBlock"],
        "folderPath": "Core/Input/Action",
        "inDepth": "The Code Block is universal and can be useful in all definitions. With this node, we can fully customize the Dynamo functionality and experience by coding directly into the graph. In this example, we see a range of possible uses including Numbers, Strings, Booleans for item based code, and Ranges and Sequences for creating lists of values."
    },
    {
        "Name": "Code Block ()",
        "imageFile": ["CodeBlock"],
        "dynFile": ["CodeBlock"],
        "folderPath": "Core/Input/Action",
        "inDepth": "The Code Block is universal and can be useful in all definitions. With this node, we can fully customize the Dynamo functionality and experience by coding directly into the graph. In this example, we see a range of possible uses including Numbers, Strings, Booleans for item based code, and Ranges and Sequences for creating lists of values."
    },
    {
        "Name": "Date Time",
        "imageFile": ["DateTime"],
        "dynFile": ["DateTime"],
        "folderPath": "Core/Input/Action",
        "inDepth": "DateTime will create a datetime object with the specified input month, day, year, and time. The format must be in the form: 'January 01, 1900 12:00 AM' The month must be capitalized and written out in full. The day must be two digits, the year must be four digits."
    },
    {
        "Name": "Directory Path",
        "imageFile": ["DirectoryPath"],
        "dynFile": ["DirectoryPath"],
        "folderPath": "Core/Input/Action",
        "inDepth": "Directory Path allows the user to select a directory from their computer. To set the directory path, click the 'Browse...' button on the Directory Path node, then navigate to the desired directory. If this node is added to a previously saved .dyn file, this node will default to the directory of the .dyn file."
    },
    {
        "Name": "File Path",
        "imageFile": ["FilePath"],
        "dynFile": ["FilePath"],
        "folderPath": "Core/Input/Action",
        "inDepth": "File Path allows the user to select a file from their computer. To set the file path, click the 'Browse...' button on the File Path node, then navigate to the desired file."
    },
    {
        "Name": "Input",
        "imageFile": [
            "Input"
        ],
        "dynFile": [
            "Input"
        ],
        "folderPath": "Core/Input/Action",
        "inDepth": "Input will create an input port for a custom node. The syntax for an input node is input_name : datatype = default_value(optional) and an optional custom comment. In the example below, x and y inputs are created with double data type, default values of 2 and 10, and a custom comment. It is important to note that this node is only available while creating a custom node."
    },
    {
        "Name": "Integer Slider",
        "imageFile": ["IntegerSlider"],
        "dynFile": ["IntegerSlider"],
        "folderPath": "Core/Input/Action",
        "inDepth": "An Integer Slider works in the same way as a Number Slider but only outputs integers. The Integer Slider in the example definition allows us to control the list length, ensuring that we always have whole-number of list outputs. "
    },
    {
        "Name": "Number",
        "imageFile": ["Number"],
        "dynFile": ["Number"],
        "folderPath": "Core/Input/Action",
        "inDepth": "The Number node allows a user to enter a static number. This node is useful for things like constants that don't change values. Numbers can also be created by using a Code Block node. In the example below, the number is paired with a code block to create a list sequence with a variable step size."
    },
    {
        "Name": "Number Slider",
        "imageFile": ["NumberSlider"],
        "dynFile": ["NumberSlider"],
        "folderPath": "Core/Input/Action",
        "inDepth": "The Number Slider is a customizable, tactile node that allows us to interface with the data driving our Dynamo definitions. Here, the number slider is paired with a code block to create a dynamic list sequence with a variable step size."
    },
    {
        "Name": "Output",
        "imageFile": [
            "Output"
        ],
        "dynFile": [
            "Output"
        ],
        "folderPath": "Core/Input/Action",
        "inDepth": "Output will create an output port for a custom node. The syntax for an output node is simply its name, along with an optional custom comment. In the example below, an output named Percentage is created with a custom comment. It is important to note that this node is only available while creating a custom node."
    },
    {
        "Name": "String",
        "imageFile": ["String"],
        "dynFile": ["String"],
        "folderPath": "Core/Input/Action",
        "inDepth": "The String node allows a user to enter a string value. A string can also be created with a Code Block by surrounding the string in quotes. In the example below, we use a String node and a Code Block to create the strings 'Hello' and 'World'. A String.Join node is used to combine the two strings together. A second String node is used with a blank space to act as the separator, resulting in the output string 'Hello World'."
    },
    {
        "Name": "List.Create",
        "imageFile": [
            "ListCreate"
        ],
        "dynFile": [
            "ListCreate"
        ],
        "folderPath": "Core/List/Create",
        "inDepth": "List.Create allows a list to be created manually by connecting each individual element to be included in the list. Use the '+' and '-' buttons to increase or decrease the number of available input nodes. In the example, we have three number sliders combined together into a list."
    },
    {
        "Name": "Range",
        "imageFile": [
            "Range"
        ],
        "dynFile": [
            "Range"
        ],
        "folderPath": "Core/List/Create",
        "inDepth": "Range will produce a list of numbers between the specified Start and End inputs. The numbers will increase from the Start input according to the Step. In the example below, we start with 1 and end with 25. By using a step of 2 the result is odd numbers between 1 and 25."
    },
    {
        "Name": "Sequence",
        "imageFile": [
            "Sequence"
        ],
        "dynFile": [
            "Sequence"
        ],
        "folderPath": "Core/List/Create",
        "inDepth": "Sequence will produce a list of numbers. The list begins at the Start input, and then increments by the Step input. The Amount input determines the number of items in the list. In the example, we create a list of 25 numbers, starting at 1 and incrementing by 2."
    },
    {
        "Name": "AddItemToEnd",
        "imageFile": [
            "AddItemToEnd"
        ],
        "dynFile": [
            "AddItemToEnd"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Add Item to End will insert a specified item at the end of a given list. Note that if a list object is used as the item to add, the entire list is added as a single object, producing a list within a list. To combine two lists together into a single flat list, see List.Join. In the example below, we use a code block to generate a range of numbers from zero to five, stepping by one. We then add a new item, the number 20, to the end of that list using AddItemToEnd."
    },
    {
        "Name": "AddItemToFront",
        "imageFile": [
            "AddItemToFront"
        ],
        "dynFile": [
            "AddItemToFront"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Add Item to Front will insert a specified item at the beginning of a given list. The new item will have index 0, while the original items will all be shifted by an index of 1. Note that if a list object is used as the item to add, the entire list is added as a single object, producing a list within a list. To combine two lists together into a single flat list, see List.Join. In the example below, we use a code block to generate a range of numbers from zero to five, stepping by one. We then add a new item, the number 20, to the front of that list using AddItemToFront."
    },
    {
        "Name": "AllIndicesOf",
        "imageFile": [
            "AllIndicesOf"
        ],
        "dynFile": [
            "AllIndicesOf"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "All Indicies Of will search a given list for the input item, and returns a list of the indices at which that item is found. In the example below, we first generate a list of random numbers between zero and 5. We can then use AllIndiciesOf to search that list for an input number."
    },
    {
        "Name": "Chop",
        "imageFile": [
            "Chop"
        ],
        "dynFile": [
            "Chop"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Chop will split a given list into smaller lists according to a list of input integer lengths. It returns a nested list with the first list containing a number of elements equal to the first number of the list input into 'lengths', the second list containing a number of elements equal to the second number of the list input into 'lengths' and so on. Chop will repeat the last number in the 'lengths' input until all elements from the input list are chopped. In the example below, we use a code block to generate a range of numbers between 0 and 5, stepping by one. This list has 6 elements in it. We use a second code block to create a list of lengths to chop the first list into."
    },
    {
        "Name": "Clean",
        "imageFile": [
            "Clean"
        ],
        "dynFile": [
            "Clean"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Clean will return a list without nulls and empty lists. In the example below, a list is cleaned of two null values, returning only the integers. The preserveIndices input can be toggled by a boolean value to keep the indices that once contained nulls."
    },
    {
        "Name": "Combinations",
        "imageFile": [
            "Combinations"
        ],
        "dynFile": [
            "Combinations"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Combinations will return a nested list that includes all possible combinations of the items in the input list with a given length. For combinations, the order of the elements does not matter, so the output list {0,1} is considered the same combination as {1,0}. If 'replace' is set to true, the items will be replaced back into the original list, allowing for elements to be used repeatedly in a combination. In the example below, we use a code block to generate a range of numbers from 0 to 5, stepping by one. We use Combinations with an input length of 3 to generate all the different ways to combine 3 of those numbers. A boolean toggle allows to select whether numbers are replaced or not."
    },
    {
        "Name": "ContainsItem",
        "imageFile": [
            "ContainsItem"
        ],
        "dynFile": [
            "ContainsItem"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Contains Item searches through a given list for an input item and returns a boolean value based on whether the item is found within the list or not. In the example below, we use a code block to generate a range of numbers from zero to 5, stepping by one. We then use a ContainsItem node to search for the number 3. Since 3 is contained within the list, ContainItem returns the value 'true'."
    },
    {
        "Name": "Count",
        "imageFile": [
            "Count"
        ],
        "dynFile": [
            "Count"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Count returns the number of items within a list. This only counts first level items, so if one of the items is a nested list itself, that item is still counted once. In the example below, we use a code block to generate a range of numbers from 0 to 5 stepping by one. By using a Count node, we can see that this list has 6 items. "
    },
    {
        "Name": "Cycle",
        "imageFile": [
            "Cycle"
        ],
        "dynFile": [
            "Cycle"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Cycle will take an input list and return a new list comprised of the input list repeated according the input 'amount'. In the example below, we first use a code block to generate a range of numbers from zero to five, stepping by one. We then use a Cycle node with an input amount of 3. The result is a list with 18 elements, consisting of 3 cycles of the original list."
    },
    {
        "Name": "Deconstruct",
        "imageFile": [
            "Deconstruct"
        ],
        "dynFile": [
            "Deconstruct"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Deconstruct will take an input list and separate the first item in the list from the remainder. This node has two outputs. The first output is the first item of the original list. The second output is a list with the remaining elements from the original list. In the example below, we first use a code block to generate a range of numbers from zero to five, stepping by one. We then use a Deconstruct node to separate the first item from the remainder. The result is the item '0' as one output, and a list of the range from 1 to 5 as a second output."
    },
    {
        "Name": "DiagonalLeft",
        "imageFile": [
            "DiagonalLeft"
        ],
        "dynFile": [
            "DiagonalLeft"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "DiagonalLeft will return a new list of lists of elements along each diagonal in the list matrix from top right to the lower left. In the example below, a list created by DiagonalLeft is compared to it's source list."
    },
    {
        "Name": "DiagonalRight",
        "imageFile": [
            "DiagonalRight"
        ],
        "dynFile": [
            "DiagonalRight"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "DiagonalRight will return a new list of lists of values along each diagonal in the list matrix from lower right to the top left. In the example below, a list created by DiagonalRight is compared to it's source list."
    },
    {
        "Name": "DropEveryNthItem",
        "imageFile": [
            "DropEveryNthItem"
        ],
        "dynFile": [
            "DropEveryNthItem"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Drop Every Nth Item will remove items from the input list at intervals of the input 'n' value. The starting point of the interval can be changed with the 'offset' input. For example, putting 3 into 'n' and leaving the 'offset' as the default of zero will removie items with indices 2, 5, 8, etc. Changing the offset to 1 would instead remove items with indices 0, 3, 6, etc. Notice that the offset 'wraps' through the entire list. To keep selected items instead of removing, see 'TakeEveryNthItem'. In the example below, we first generate a list of numbers using Range, and then remove every other number by using 2 as the input for 'n'."
    },
    {
        "Name": "DropItems",
        "imageFile": [
            "DropItems"
        ],
        "dynFile": [
            "DropItems"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Drop Items will remove the input 'amount' number of items from the list. If the 'amount' is positive, the numbers will be removed from the beginning of the list. If the 'amount' is negative, the items will be removed from the end of the list.  In the example below, we first create a list using Range, then drop the first item in the list by using Drop Item with an 'amount' of 1."
    },
    {
        "Name": "FilterByBoolMask",
        "imageFile": [
            "FilterByBoolMask"
        ],
        "dynFile": [
            "FilterByBoolMask"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Filter By Bool Mask takes two lists as inputs. The first list will be split into two separate lists according to a corresponding list of boolean (True or False) values. Items from the 'list' input that correspond to a True in the 'mask' input will go to the output labelled 'in', while those items that correspond to a 'False' value will go the 'out' output. In the example below, we use a modulus operator (%) and an equality operator (==) to test each item in the list for divisibility by three. The result after FilterByBoolMask is two lists, the first containing the items that are divisible by 3, and the second containing items that are not divisible by 3. "
    },
    {
        "Name": "FirstIndexOf",
        "imageFile": [
            "FirstIndexOf"
        ],
        "dynFile": [
            "FirstIndexOf"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "First Index Of will search through a given list and return the index of the first instance of the input item to search for. In the example below, we first generate list of ten random numbers between 0 and 4. By using a FirstIndexOf node, we can search for a specific item, and get the index of the first time that item is found in the last."
    },
    {
        "Name": "FirstItem",
        "imageFile": [
            "FirstItem"
        ],
        "dynFile": [
            "FirstItem"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "First Item simply returns the first item of an input list. In the example below, we generate a list of ten random numbers between zero and five. We then use FirstItem node to return the first item of the list. "
    },
    {
        "Name": "Flatten",
        "imageFile": [
            "Flatten"
        ],
        "dynFile": [
            "Flatten"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Flatten will take a nested list and flatten levels of the list by combining the first levels into a single level. The 'amt' input determines how many levels to flatten. Flatten starts from the first branch. In the example below, we first generate a range of numbers from 1 to 5, stepping by one. This creates a list of 5 elements. We use this list as the input for the lengths of a cuboid, producing a list of 5 cuboids. By exploding the cuboids, we get a list of 6 faces for each cuboid. We now have 5 lists of 6 faces, for a total of 30 elements. We go one step further by finding the edges of each face. The result is 5 lists of 6 lists of 4 edges, or a total of 120 elements. By using a Flatten node, we take the first level, the initial 5 different lists, and combine that into a single list. The resulting output is 30 lists of 4 edges. "
    },
    {
        "Name": "GetItemAtIndex",
        "imageFile": [
            "GetItemAtIndex"
        ],
        "dynFile": [
            "GetItemAtIndex"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Get Item At Index takes an input list, and an integer and returns the item from the list found at the input index. In the example below, we first use a code block to generate a range of numbers from zero to 5, stepping by one. We can then extract a single element at a specified index by using a GetItemAtIndex node."
    },
    {
        "Name": "GroupByKey",
        "imageFile": [
            "GroupByKey"
        ],
        "dynFile": [
            "GroupByKey"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Group By Key takes an input list of items to group, and a list of keys to determine how the first list is grouped. The list of keys should have the same number of elements as the input list. Items in the original list that correspond to matching keys will be grouped together in an output list. In the example below, we use a range of numbers between 0 and 9 as the input list. We also generate a list of 10 random numbers between 0 and 4 to use as the keys. GroupByKey outputs a nested list of elements, grouped according to the corresponding key. It also outputs a list of the unique keys."
    },
    {
        "Name": "IsEmpty",
        "imageFile": [
            "IsEmpty"
        ],
        "dynFile": [
            "IsEmpty"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Is Empty takes a list as input, and returns a boolean value based on whether or not the input list is empty. In the example below, we first use a code block to generate a range of numbers from zero to 5, stepping by one. We input this list into an IsEmpty node. Since the list is not empty, IsEmpty returns a 'false' value."
    },
    {
        "Name": "Join",
        "imageFile": [
            "Join"
        ],
        "dynFile": [
            "Join"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Join will take the input lists and join them together into a single list. You adjust the number of input points by using the '+' and '-' buttons on the Join node. In the example below, we first use two codes blocks to generate two ranges of numbers. One is the odd numbers {1,3,5}, while the second is the even numbers {0,2,4}. By using a Join node, we can join these two lists into a single list {1,3,5,0,2,6}. "
    },
    {
        "Name": "LastItem",
        "imageFile": [
            "LastItem"
        ],
        "dynFile": [
            "LastItem"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Last Item simply returns the last item of an input list. In the example below, we generate a list of ten random numbers between zero and five. We then use LastItem node to return the last item of the list. "
    },
    {
        "Name": "List.CartesianProduct",
        "imageFile": [
            "ListCartesianProduct"
        ],
        "dynFile": [
            "ListCartesianProduct"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Cartesian Product will apply an input combinator to each pair of items across two lists. The first item of the first input list will be combined with each element of the second list in turn, followed by the second item in the first list combined with each element of the second list, and so on. In the example below, we use addition as our combinator. Note that we leave the inputs to the Addition empty, causing the node to return a 'function', which will act as the combinator for our Cartesian Product node. We then use two code blocks to create two ranges of numbers: {0,1,2,3,4,5} and {1,3,5} to combine together. For a simple operation like addition with two numbers, using Cartesian Product is equivalent to using an Addition node directly and changing the lacing to Cross Product. Both are shown in the example below as a comparison."
    },
    {
        "Name": "List.Combine",
        "imageFile": [
            "ListCombine"
        ],
        "dynFile": [
            "ListCombine"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Combine will apply an input combinator to corresponding elements in two input lists. In the example below, we use addition as our combinator. Note that we leave the inputs to the Addition empty, causing the node to return a 'function'.  We then use two code blocks to create two ranges of numbers: {0,1,2,3,4,5} and {1,3,5} to combine together. If the two lists do not have the same number of elements, Combine will return 'null' for the unmatched elements."
    },
    {
        "Name": "List.Filter",
        "imageFile": [
            "ListFilter"
        ],
        "dynFile": [
            "ListFilter"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Filter takes an input list and splits it into two new list according to an input condition test. The condition is applied to each element in the list. If the condition evaluates to 'true', that list item will be put in the 'in' output, otherwise it will be in the 'out' output. In the example below, we first use a code block to generate a range of numbers from zero to five, stepping by one. For the condition input, we use a Greater Than node with the number '2' input as the y value. Note that the x input is left blank. This causes the Greater Node to return a function. When applied as the condition for a Filter node, the items from the input list to filter will be used as the x input for the Greater Than function. The result is two list, the first list containing the elements greater than 2, and the second containing the elements less than or equal to 2."
    },
    {
        "Name": "List.LaceLongest",
        "imageFile": [
            "ListLaceLongest"
        ],
        "dynFile": [
            "ListLaceLongest"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Lace Longest will apply an input combinator to corresponding elements in two input lists. In the example below, we use addition as our combinator. Note that we leave the inputs to the Addition empty, causing the node to return a 'function'.  We then use two code blocks to create two ranges of numbers: {0,1,2,3,4,5} and {1,3,5} to combine together. Lace Longest behaves in the same way as List.Combine, except instead of returning 'null' for unmatched elements it will repeat the last element of the shorter list. For a simple operation like addition of two elements, this is equivalent to using the Addition node directly and changing the lacing to 'Longest'."
    },
    {
        "Name": "List.LaceShortest",
        "imageFile": [
            "ListLaceShortest"
        ],
        "dynFile": [
            "ListLaceShortest"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Lace Shortest will apply an input combinator to corresponding elements in two input lists. In the example below, we use addition as our combinator. Note that we leave the inputs to the Addition empty, causing the node to return a 'function'.  We then use two code blocks to create two ranges of numbers: {0,1,2,3,4,5} and {1,3,5} to combine together. Lace Shortest behaves in the same way as List.Combine, except instead of returning 'null' for unmatched elements it will ignore the unmatched elements of the longer list. For a simple operation like addition of two elements, this is equivalent to using the Addition node directly and changing the lacing to 'Shortest'."
    },
    {
        "Name": "List.Map",
        "imageFile": [
            "ListMap"
        ],
        "dynFile": [
            "ListMap"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Map will take an input function and apply it to each element of an input list. In the example below, we first use a code block to generate a range of numbers from zero to five with a step of one. We use an Addition node with a y input of 3 as the f(x) input. Note that by leaving the x input blank on the Addition node, it returns a function. The output from List.Map contains each number from the original increased by 3."
    },
    {
        "Name": "List.Reduce",
        "imageFile": [
            "ListReduce"
        ],
        "dynFile": [
            "ListReduce"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "List.Reduce will combine the elements in a list together by applying a reductor function sequentially to each item in the list, using the accumulated result as the first argument to combine with each subsequent element. The 'seed' input is the initial first argument to combine with the first element of the list. In the example below, we use an Addition node as our reductor function. The two inputs to the Addition node are left blank. A seed of 10 is used, and a range {0,1,2,3,4,5} is used as the list to reduce. List.Reduce will start with the seed 10 and combine it with the first element from the list using addition. The result will then be combined with the second element, and so on until the whole list is completed."
    },
    {
        "Name": "List.Scan",
        "imageFile": [
            "ListScan"
        ],
        "dynFile": [
            "ListScan"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "List.Scan will combine the elements in a list together by applying a reductor function sequentially to each item in the list, using the accumulated result as the first argument to combine with each subsequent element. Each result is output to a list showing the accumulated values. The 'seed' input is the initial first argument to combine with the first element of the list. In the example below, we use an Addition node as our reductor function. The two inputs to the Addition node are left blank. A seed of 10 is used, and a range {0,1,2,3,4,5} is used as the list to reduce. List.Scan will start with the seed 10 and combine it with the first element from the list using addition. The result will then be combined with the second element, and so on until the whole list is completed."
    },
    {
        "Name": "MaximumItem",
        "imageFile": [
            "MaximumItem"
        ],
        "dynFile": [
            "MaximumItem"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Maximum Item will search through a list of values and return the item with the maximum value. In the example below we generate a list of 10 random numbers between 0 and 49. We then use a MaximumItem node to find the largest item in the list."
    },
    {
        "Name": "MinimumItem",
        "imageFile": [
            "MinimumItem"
        ],
        "dynFile": [
            "MinimumItem"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Minimum Item will search through a list of values and return the item with the minimum value. In the example below we generate a list of 10 random numbers between 0 and 49. We then use a MinimumItem node to find the smallest item in the list."
    },
    {
        "Name": "OfRepeatedItem",
        "imageFile": [
            "OfRepeatedItem"
        ],
        "dynFile": [
            "OfRepeatedItem"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Of Repeated Item will create a list by repeated a given item a certain number of times specified by the 'amount' input. In the example below, we create a list consisting of the number 4 repeated ten times."
    },
    {
        "Name": "Permutations",
        "imageFile": [
            "Permutations"
        ],
        "dynFile": [
            "Permutations"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Permutations will create a nested list consisting of all permutations of a specified length from a given input list. In the example below, we use a code block to create a range of numbers from 0 to 5, stepping by one. We then use a Permutation node with an length input of 3 to generate all permutations of three elements from the range {0,1,2,3,4,5}."
    },
    {
        "Name": "RemoveItemAtIndex",
        "imageFile": [
            "RemoveItemAtIndex"
        ],
        "dynFile": [
            "RemoveItemAtIndex"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Remove Item At Index will take an input list of items, and create a new list by removing the items at specified indices. In the example below we start with a range of numbers from zero to five. We then remove the item with index 3."
    },
    {
        "Name": "ReplaceByCondition",
        "imageFile": [
            "ReplaceByCondition"
        ],
        "dynFile": [
            "ReplaceByCondition"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Replace By Condition will take a given list and evaluate each item with a given condition. If the condition evaluates to 'true', the corresponding item will be replaced in the output list with the item specified in the replaceWith input. In the example below, we use a Formula node and enter the formula x%2==0, which finds the remainder of a given item after dividing by 2, and then checks to see if that remainder is equal to zero. This formula will return 'true' for even integers. Note that the input x is left blank. Using this formula as the condition in a ReplaceByCondition node results in an output list where each even number is replaced by the specified item, in this case the integer 10."
    },
    {
        "Name": "ReplaceItemAtIndex",
        "imageFile": [
            "ReplaceItemAtIndex"
        ],
        "dynFile": [
            "ReplaceItemAtIndex"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Replace Item At Index will take an input list, a list of indices at which to replace items, and a new item to replace with. In the example below, we start with a range of numbers from zero to five. We then use a ReplaceItemAtIndex node to replace the item at index 3 with a new item, in this case the integer 10."
    },
    {
        "Name": "RestOfItems",
        "imageFile": [
            "RestOfItems"
        ],
        "dynFile": [
            "RestOfItems"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Rest Of Items will remove the first element from a list and return the remaining elements in a new list. In the example below, we start with a range of numbers from zero to five. After using a RestOfItems node, the output list is a range of numbers from one to five. The first element from the original list has been removed."
    },
    {
        "Name": "Reverse",
        "imageFile": [
            "Reverse"
        ],
        "dynFile": [
            "Reverse"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Reverse simply takes the items in a list and creates a new list with the order of items reversed. In the example, we first generate a list using Range, which produces numbers in increasing order, then we use Reverse to switch the order of the items in the list."
    },
    {
        "Name": "ShiftIndices",
        "imageFile": [
            "ShiftIndices"
        ],
        "dynFile": [
            "ShiftIndices"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Shift Indices will shift the position of the items in a list by the 'amount' input. A positive amount will shift the numbers up, while a negative amount will shift the indices backwards. The items wrap around, causing items at the back of the list to wrap to the beginning. In the example we first generate a list with Range, then shift the indices forward by 3."
    },
    {
        "Name": "Shuffle",
        "imageFile": [
            "Shuffle"
        ],
        "dynFile": [
            "Shuffle"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Shuffle will take an input list and randomize the order of the items. In the example, we first generate a list using Range, and then use Shuffle to produce a randomized list."
    },
    {
        "Name": "Slice",
        "imageFile": [
            "Slice"
        ],
        "dynFile": [
            "Slice"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Slice will return a sublist from an input last. The start input specifies which index the output list will start with. The end input specifies when to stop taking elements from the input. This end index is not included in the output list. In the example below, using a start index of 2 and an end input of 5 results in a new list consisting of the items with indices 2,3, and 4 from the orginal list."
    },
    {
        "Name": "Sort",
        "imageFile": [
            "Sort"
        ],
        "dynFile": [
            "Sort"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Sort will sort a list of items according to the built-in ordering for the data type. For example, a list of numbers will be sorted into numerical order from least to greatest, while a list of strings will be sorted alphabetically. In the example below, we use Random List to first generate a list of random numbers between 0 and 1. We then multiply by 10 and use a Floor operation to get a list of random integers between 0 and 9. Sort then creates a sorted list from least to greatest."
    },
    {
        "Name": "SortByKey",
        "imageFile": [
            "SortByKey"
        ],
        "dynFile": [
            "SortByKey"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Sort By Key takes an input list to sort, and a list of corresponding sortable keys. Sort By Key will sort the list of keys in ascending order, and will rearrange the input list to correspond to the new order of the sorted keys. This node outputs both the rearranged list, and the sorted list of keys. In the example below, we use a range from zero to nine as our input list. For the list of keys, we generate a list of 10 random numbers between zero and four. The list of keys is sorted numerically, while the range from 0 to 9 is rearranged according to the order of the corresponding elements from the list of keys."
    },
    {
        "Name": "Sublists",
        "imageFile": [
            "Sublists"
        ],
        "dynFile": [
            "Sublists"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Sublists will take a input list and return a series of sublists based on the input range and offset. The range determines which elements of the input list to put into the first sublist. The offset is applied to the range, and the new range will determine the second sublist. This process repeats, increasing the range by the given offset until the resulting sublist is empty. In the example below, we start with a range of numbers from zero to nine. The range 0 to 5 is used as the sublist range, and we use an offset of 2. In the output of nested sublists, the first list contains the elements with indicies in the range 0..5, the second list contains the elements with indicies 2..7. As this is repeated, the subsequent sublists get shorter as the end of the range becomes larger than the length of the initial list."
    },
    {
        "Name": "TakeEveryNthItem",
        "imageFile": [
            "TakeEveryNthItem"
        ],
        "dynFile": [
            "TakeEveryNthItem"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Drop Every Nth Item will produce a new list keeping items from the input list at intervals of the input 'n' value. The starting point of the interval can be changed with the 'offset' input. For example, putting 3 into 'n' and leaving the 'offset' as the default of zero will keep items with indices 2, 5, 8, etc. Changing the offset to 1 would instead keep items with indices 0, 3, 6, etc. Notice that the offset 'wraps' through the entire list. To remove selected items instead of keeping them, see 'DropEveryNthItem'. In the example below, we first generate a list of numbers using Range, and then keep every other number by using 2 as the input for 'n'."
    },
    {
        "Name": "TakeItems",
        "imageFile": [
            "TakeItems"
        ],
        "dynFile": [
            "TakeItems"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Take Items will return a new list with the input number of elements taking from the beginning of the input list. In the example below, we start with a range of numbers from zero to nine. We use an integer slider to specify the amount of elements to take from the original list. With an input of 4, the output list will be the first 4 elemenst from the original list."
    },
    {
        "Name": "Transpose",
        "imageFile": [
            "Transpose"
        ],
        "dynFile": [
            "Transpose"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Transpose will take a list a lists and swap the rows and columns. For example, a list that contains 5 sub-lists of 10 items each would be transposed to 10 lists of 5 items each. In the example, we generate two Random Lists, and then use List.Create to combine them. The result is two lists with 3 and 4 items. Transpose switches this to 4 lists of 2 items each. Notice that since one of the original lists was longer than the other, Transpose inserted a null value for the unpaired item."
    },
    {
        "Name": "UniqueItems",
        "imageFile": [
            "UniqueItems"
        ],
        "dynFile": [
            "UniqueItems"
        ],
        "folderPath": "Core/List/Action",
        "inDepth": "Unique Item will remove all duplicate items from a input list. In the example below, we use Random List to first generate a list of random numbers between 0 and 1. We then multiply by 10 and use a Floor operation to get a list of random integers between 0 and 9, with many of them repeated multiple times. After using Unique Item, we are left with a list in which each integer only occurs once. The order of the output list will be according to the first found instance of an item. "
    },
    {
        "Name": "Empty",
        "imageFile": [
            "Empty"
        ],
        "dynFile": [
            "Empty"
        ],
        "folderPath": "Core/List/Query",
        "inDepth": "Empty will return an empty list. In the example, a list is created with several integers and an empty list."
    },
    {
        "Name": "ByLatitudeAndLongitude",
        "imageFile": [
            "ByLatitudeAndLongitude"
        ],
        "dynFile": [
            "ByLatitudeAndLongitude"
        ],
        "folderPath": "Core/Location/Create",
        "inDepth": "ByLatitudeAndLongitude will return a Location from input latitude and longitude values (doubles) and a input name (string). In the example below, a Location is created from latitude 45.5231, longitude -122.679565, and a name: Portland."
    },
    {
        "Name": "Latitude",
        "imageFile": [
            "Latitude"
        ],
        "dynFile": [
            "Latitude"
        ],
        "folderPath": "Core/Location/Query",
        "inDepth": "Latitude will return the latitude value from a Location. In the example below, a latitude of 45.5231 is returned from input Location."
    },
    {
        "Name": "Longitude",
        "imageFile": [
            "Longitude"
        ],
        "dynFile": [
            "Longitude"
        ],
        "folderPath": "Core/Location/Query",
        "inDepth": "Longitude will return the longitude value from a Location. In the example below, a longitude of -122.679565 is returned from the input Location."
    },
    {
        "Name": "Name",
        "imageFile": [
            "Name"
        ],
        "dynFile": [
            "Name"
        ],
        "folderPath": "Core/Location/Query",
        "inDepth": "Name will return the name value from a Location. In the example below, a name of Portland is returned from the input Location."
    },
    {
        "Name": "And",
        "imageFile": [
            "And"
        ],
        "dynFile": [
            "And"
        ],
        "folderPath": "Core/Logic/Action",
        "inDepth": "And will take a variable number of boolean inputs. You can increase or decrease the number of inputs by using the '+' and '-' buttons on the And node. Each input must be a single boolean value. And will return 'true' if all of the inputs are true, otherwise it will return 'false'. In the example below, we have three boolean toggles used as inputs for an And node. When all three are set to 'true', And will return 'true'."
    },
    {
        "Name": "If",
        "imageFile": [
            "If",
            "If - Ex 2"
        ],
        "dynFile": [
            "If",
            "If - Ex 2"
        ],
        "folderPath": "Core/Logic/Action",
        "inDepth": "If acts as a conditional control node. The 'test' input takes a boolean value, while the 'true' and 'false' inputs can accept any data type. If the test value is 'true', the node will return the item from the 'true' input, if test is 'false', the node will return the item from the 'false' input. In the example below, we first generate a list of random numbers between zero and 99. The number of items in the list is controlled by an integer slider. We use a code block with the formula 'x%a==0' to test for divisibility by a second number, determined by a second number slider. This generates a list of boolean values corresponding to whether the items in the random list are divisible by the number determined by the second integer slider. This list of boolean values is used as the 'test' input for an If node. We use a default Sphere as the 'true' input, and a default Cuboid as the 'false' input. The result from the If node is a list of either spheres or cuboids. Finally, we use a Translate node to spread the list of geometries apart.\n\nIF replicates on all nodes AS THOUGH SET TO SHORTEST. You can see the reason for this in the attached examples, especially when looking at what the results are when LONGEST is applied to a formula node and the \"short\" branch of the conditional is passes through. These changes were also made to allow predictable behavior when using single boolean inputs or a list of booleans."
    },
    {
        "Name": "Or",
        "imageFile": [
            "Or"
        ],
        "dynFile": [
            "Or"
        ],
        "folderPath": "Core/Logic/Action",
        "inDepth": "Or will take a variable number of boolean inputs. You can increase or decrease the number of inputs by using the '+' and '-' buttons on the Or node. Each input must be a single boolean value. Or will return 'true' if at least one of the inputs are true, otherwise if all inputs are 'false', it will return 'false'. In the example below, we have three boolean toggles used as inputs for an Or node. When all three are set to 'false', Or will return 'false'."
    },
    {
        "Name": "ScopeIf",
        "imageFile": [
            "ScopeIf"
        ],
        "dynFile": [
            "ScopeIf"
        ],
        "folderPath": "Core/Logic/Action",
        "inDepth": "ScopeIf will return the input of either the True or False input depending on what boolean value is toggled in the test input. In the example file below, a large and small list of numbers is plugged into the true and false inputs. By sending the result of ScopeIfThrough a point creation node, we can toggle between two different sizes of point grids."
    },
    {
        "Name": "Xor",
        "imageFile": [
            "Xor"
        ],
        "dynFile": [
            "Xor"
        ],
        "folderPath": "Core/Logic/Action",
        "inDepth": "Xor will accept two boolean values, or two lists of boolean values and determines whether the values are the same or different. Xor compares two values and returns 'true' if exactly one of the inputs is 'true'. If both values are 'true' or if both values are 'false', Xor will return 'false'. In the example below, we start with two lists of boolean values. Together, these lists represent the four possible combinations of true and false values. Notice that unlike And and Or nodes, Xor only allows two values."
    },
    {
        "Name": "Abs (number)",
        "imageFile": [
            "Abs"
        ],
        "dynFile": [
            "Abs"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Abs will return the absolute value of an input value. In the example below, we use a number slider to control the input to an Abs node."
    },
    {
        "Name": "Abs (integer)",
        "imageFile": [
            "Abs"
        ],
        "dynFile": [
            "Abs"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Abs will return the absolute value of an input value. In the example below, we use an integer slider to control the input to an Abs node."
    },
    {
        "Name": "Acos",
        "imageFile": [
            "Acos"
        ],
        "dynFile": [
            "Acos"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Acos will return the inverse cosine, also known as the ArcCosine, of an input number between -1 and 1. This output angle is returned in degrees. In the example below we use a number slider set to the range -1 to 1 to control the input to an Acos node."
    },
    {
        "Name": "Asin",
        "imageFile": [
            "Asin"
        ],
        "dynFile": [
            "Asin"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Asin will return the inverse sine, also known as the ArcSine, of an input number between -1 and 1. This output angle is returned in degrees. In the example below we use a number slider set to the range -1 to 1 to control the input to an Asin node."
    },
    {
        "Name": "Atan",
        "imageFile": [
            "Atan"
        ],
        "dynFile": [
            "Atan"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Atan will return the inverse sine, also known as the ArcTangent, of an input number. This output angle is returned in degrees. In the example below we use a number slider to control the input to an Atan node."
    },
    {
        "Name": "Atan2",
        "imageFile": [
            "Atan2"
        ],
        "dynFile": [
            "Atan2"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Atan2 will return the inverse sine, also known as the ArcTangen, of the ratio of an input numerator and denomnator. This output angle is returned in degrees. In the example below we use two number sliders to control the inputs to an Atan2 node."
    },
    {
        "Name": "Average",
        "imageFile": [
            "Average"
        ],
        "dynFile": [
            "Average"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Average will return the average (arithmetic mean) of a list of numbers. In the example below, we first use three number sliders to create three numbers to find the average of. We then use a List.Create node combine these three numbers into a list that we can then use as the input for an Average node."
    },
    {
        "Name": "Ceiling",
        "imageFile": [
            "Ceiling"
        ],
        "dynFile": [
            "Ceiling"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Ceiling will find the nearest integer that greater than an input number. This can also be thought of as rounding up to the nearest integer. In the example below, we use a number slider to control the input to a Ceiling node."
    },
    {
        "Name": "Cos",
        "imageFile": [
            "Cos"
        ],
        "dynFile": [
            "Cos"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Cos will return the cosine of an input angle in degrees. In the example below, we use a number slider set to the range -360 to 360 to control the input angle to a Cos node."
    },
    {
        "Name": "Cosh",
        "imageFile": [
            "Cosh"
        ],
        "dynFile": [
            "Cosh"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Cosh will return the hyperbolic cosine of an input angle in radians. In the example below, we use a number slider set to the range -6.28 to 6.28 to control the input angle to a Cosh node."
    },
    {
        "Name": "DegreesToRadians",
        "imageFile": [
            "DegreesToRadians"
        ],
        "dynFile": [
            "DegreesToRadians"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "DegreesToRadians will convert an input angle from degrees to radians. In the example below, we use a number slider set to the range -360 to 360 to control the input angle to a DegreesToRadians node."
    },
    {
        "Name": "DivRem",
        "imageFile": [
            "DivRem"
        ],
        "dynFile": [
            "DivRem"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "DivRem will return the remainder of an input number after dividing by a given divisor. This is also known as Modulus, and is equivalent to the operator '%'. In the example below, we use two number sliders to set the dividend and divisor for a DivRem node."
    },
    {
        "Name": "Exp",
        "imageFile": [
            "Exp"
        ],
        "dynFile": [
            "Exp"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Exp is the exponential function with a base of 'e'. The input number is applied as an exponent to the constant 'e'. In the example below we use a number slider to control the input number to an Exp node. "
    },
    {
        "Name": "Factorial",
        "imageFile": [
            "Factorial"
        ],
        "dynFile": [
            "Factorial"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Factorial will return the factorial of an input positive integer. If a decimal value is input, factorial will first round the input to the nearest integer. In the example below we use a number slider to control the input to a Factorial node."
    },
    {
        "Name": "Floor",
        "imageFile": [
            "Floor"
        ],
        "dynFile": [
            "Floor"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Floor will find the nearest integer that less than an input number. This can also be thought of as rounding down to the nearest integer. In the example below, we use a number slider to control the input to a Floo node."
    },
    {
        "Name": "Log (number, logBase)",
        "imageFile": [
            "Log_base"
        ],
        "dynFile": [
            "Log_base"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Log with logBase allows the use to specify the base to use for a logarithm with the logBase input. In the example below, we use two number sliders, one to control the input number to find the logarithm of and a second number slider to set the base of the logarithm."
    },
    {
        "Name": "Log (number)",
        "imageFile": [
            "Log"
        ],
        "dynFile": [
            "Log"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Log will return the natural log (base e) of an input number. In the example below, we use a number slider to control the input to a Log node."
    },
    {
        "Name": "Log10",
        "imageFile": [
            "Log10"
        ],
        "dynFile": [
            "Log10"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Log10 will return the log base 10 of an input number. In the example below, we use a number slider to control the input to a Log10 node."
    },
    {
        "Name": "Max (int1, int2)",
        "imageFile": [
            "Max_int"
        ],
        "dynFile": [
            "Max_int"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Max will return the greater of two input integers. In the example below, we use two integer sliders to control the inputs to a Max node."
    },
    {
        "Name": "Max (value1, value2)",
        "imageFile": [
            "Max"
        ],
        "dynFile": [
            "Max"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Max will return the greater of two input number. In the example below, we use two number sliders to control the inputs to a Max node."
    },
    {
        "Name": "Min (int1, int2)",
        "imageFile": [
            "Min_int"
        ],
        "dynFile": [
            "Min_int"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Min will return the lesser of two input integers. In the example below, we use two integer sliders to control the inputs to a Min node."
    },
    {
        "Name": "Min (value1, value2)",
        "imageFile": [
            "Min"
        ],
        "dynFile": [
            "Min"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Min will return the lesser of two input number. In the example below, we use two number sliders to control the inputs to a Min node."
    },
    {
        "Name": "Pow",
        "imageFile": [
            "Pow"
        ],
        "dynFile": [
            "Pow"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Pow will return the result of an input number raised to an input power. In the example below, we use two number sliders to control the two inputs to a Pow node."
    },
    {
        "Name": "RadiansToDegrees",
        "imageFile": [
            "RadiansToDegrees"
        ],
        "dynFile": [
            "RadiansToDegrees"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "RadiansToDegrees will convert an input angle from radians to degrees. In the example below, we use a number slider to control the input angle to a RadiansToDegrees node."
    },
    {
        "Name": "Rand",
        "imageFile": [
            "Rand"
        ],
        "dynFile": [
            "Rand"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Rand will generate a random number in the range 0 to 1. Each instance of Rand will produce a different random number, but the number for a specific instance will remain constant."
    },
    {
        "Name": "Random (seed)",
        "imageFile": [
            "Random"
        ],
        "dynFile": [
            "Random"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Random with a given seed allows the user to input a seed number to produce a pseudo-random number. Every Rand node with the same seed number will produce the same pseudo-random number. In the example below, we use an integer slider as the input seed into a Rand node."
    },
    {
        "Name": "Random (value1, value2)",
        "imageFile": [
            "Random_range"
        ],
        "dynFile": [
            "Random_range"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Random with two value inputs allows the user to control the range of the generated random number. It will produce a random number between the two input values. In the example below, we use two number sliders to control the two inputs into a Random node."
    },
    {
        "Name": "RandomList",
        "imageFile": [
            "RandomList"
        ],
        "dynFile": [
            "RandomList"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "RandomList will generate a list of random numbers in the range 0 to 1. The amount of random to generate is controlled by a number slider."
    },
    {
        "Name": "RemapRange",
        "imageFile": [
            "RemapRange"
        ],
        "dynFile": [
            "RemapRange"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "RemapRange will take a list of numbers and produce a linear scaling of those numbers into a new specified range. The minimum value of the original list is mapped to the newMin input, while the maximum value of the orginila list is mapped to the newMax input. The remaining numbers are scaled to maintain the distribution ratio. In the example below, we use a RandomList node to generate a list of numbers to remap. We use two number sliders to control the new minimum and maximum values of the resulting list."
    },
    {
        "Name": "Round (number)",
        "imageFile": [
            "Round"
        ],
        "dynFile": [
            "Round"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Round will round the input number to the nearest integer. In the example below, we use a number slider to control the input to a Round node."
    },
    {
        "Name": "Round (number, digits)",
        "imageFile": [
            "Round_digits"
        ],
        "dynFile": [
            "Round_digits"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Round with digits allows the user to select the number of decimal places to round the input number to. An input of zero will round to the nearest whole number. Values less than zero are not permitted. In the example below, we use a Rand node to generate a random number. An integer slider is used to control the 'digits' input in a Round node."
    },
    {
        "Name": "Sign (integer)",
        "imageFile": [
            "Sign"
        ],
        "dynFile": [
            "Sign"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Sign will return 1, 0, or -1 depending on whether the input number is greater than, equal to, or less than zero. In the example below, we use a number slider to control the input to a Sign node."
    },
    {
        "Name": "Sign (number)",
        "imageFile": [
            "Sign"
        ],
        "dynFile": [
            "Sign"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Sign will return 1, 0, or -1 depending on whether the input number is greater than, equal to, or less than zero. In the example below, we use a number slider to control the input to a Sign node."
    },
    {
        "Name": "Sin",
        "imageFile": [
            "Sin"
        ],
        "dynFile": [
            "Sin"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Sin will return the sine of an input angle in degrees. In the example below, we use a number slider set to the range -360 to 360 to control the input angle to a Sin node."
    },
    {
        "Name": "Sinh",
        "imageFile": [
            "Sinh"
        ],
        "dynFile": [
            "Sinh"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Sinh will return the hyperbolic sine of an input angle in radians. In the example below, we use a number slider set to the range -6.28 to 6.28 to control the input angle to a Sinh node."
    },
    {
        "Name": "Sqrt",
        "imageFile": [
            "Sqrt"
        ],
        "dynFile": [
            "Sqrt"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Sqrt will return the square root of an input number. Sqrt will only accept positive numbers. In the example below we use a number slider to control the input to a Sqrt node."
    },
    {
        "Name": "Sum",
        "imageFile": [
            "Sum"
        ],
        "dynFile": [
            "Sum"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Sum will find the sum of the values of an input list. In the example below, we use three number sliders to create three numbers. We then use a List.Create node to combine them into a list that can be used as the input to a Sum node."
    },
    {
        "Name": "Tan",
        "imageFile": [
            "Tan"
        ],
        "dynFile": [
            "Tan"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Tan will return the tangent of an input angle in degrees. In the example below, we use a number slider set to the range -360 to 360 to control the input angle to a Tan node."
    },
    {
        "Name": "Tanh",
        "imageFile": [
            "Tanh"
        ],
        "dynFile": [
            "Tanh"
        ],
        "folderPath": "Core/Math/Action",
        "inDepth": "Tanh will return the hyperbolic tangent of an input angle in radians. In the example below, we use a number slider set to the range -6.28 to 6.28 to control the input angle to a Tanh node."
    },
    {
        "Name": "E",
        "imageFile": [
            "E"
        ],
        "dynFile": [
            "E"
        ],
        "folderPath": "Core/Math/Query",
        "inDepth": "E will return the constant e = 2.71828..."
    },
    {
        "Name": "GoldenRatio",
        "imageFile": [
            "GoldenRatio"
        ],
        "dynFile": [
            "GoldenRatio"
        ],
        "folderPath": "Core/Math/Query",
        "inDepth": "GoldenRatio will return the golden ratio constant, also known as 'phi', equal to 1.61803... "
    },
    {
        "Name": "PI",
        "imageFile": [
            "Pi"
        ],
        "dynFile": [
            "Pi"
        ],
        "folderPath": "Core/Math/Query",
        "inDepth": "Pi will return the constant pi = 3.14159265..."
    },
    {
        "Name": "PiTimes2",
        "imageFile": [
            "PiTimes2"
        ],
        "dynFile": [
            "PiTimes2"
        ],
        "folderPath": "Core/Math/Query",
        "inDepth": "PiTimes2 will return the constant pi multiplied by 2 = 6.28318..."
    },
    {
        "Name": "Identity",
        "imageFile": [
            "Identity"
        ],
        "dynFile": [
            "Identity"
        ],
        "folderPath": "Core/Object/Action",
        "inDepth": "Identity will return what is passed in. In the example below, the Identity node is used to preview each piece of geometry created inside a Code Block."
    },
    {
        "Name": "IsNull",
        "imageFile": [
            "IsNull"
        ],
        "dynFile": [
            "IsNull"
        ],
        "folderPath": "Core/Object/Action",
        "inDepth": "IsNull will return a boolean value based on whether an object is null. In the example below, a grid of circles is drawn with varying radii based on the Red level in a bitmap. Where there is no Red value, no circle is drawn and returns a null in the list of circles. Passing this list through IsNull returns a list of boolean values, with true representing every location of a null value. This list of booleans can be used with List.FilterByBoolMask to return a list without nulls."
    },
    {
        "Name": "Type",
        "imageFile": [
            "Type"
        ],
        "dynFile": [
            "Type"
        ],
        "folderPath": "Core/Object/Action",
        "inDepth": "Type will return the type of object passed through the node as a string. In the example below, several types of geometry are passed through the node to show the resulting strings. A Point will return Autodesk.DesignScript.Geometry.Point, a NurbsSurface will return Autodesk.DesignScript.Geometry.NurbsSurface, and an integer will return System.Int32."
    },
    {
        "Name": "Formula (IN[0])",
        "imageFile": [],
        "dynFile": [],
        "folderPath": "Core/Scripting/Action",
        "inDepth": "Add in-depth information about Formula..."
    },
    {
        "Name": "Formula (())",
        "imageFile": [
            "Formula (())"
        ],
        "dynFile": [
            "Formula (())"
        ],
        "folderPath": "Core/Scripting/Action",
        "inDepth": "Formula uses the NCalc mathematical expressions evaluator to return the result of a formula. In the example below, the result of an if statement using NCalc is drawn as a NurbsCurve."
    },
    {
        "Name": "Python Script",
        "imageFile": [
            "Python Script"
        ],
        "dynFile": [
            "Python Script"
        ],
        "folderPath": "Core/Scripting/Action",
        "inDepth": "Python Script will return the result of the node's inputs passed through an embedded IronPython script. In the example below, a cube created from Cuboid.ByCorners is arrayed and translated by a Python script that loops through both X and Y. Double clicking the node will bring up an editor for the script."
    },
    {
        "Name": "Python Script From String",
        "imageFile": [
            "Python Script From String"
        ],
        "dynFile": [
            "Python Script From String"
        ],
        "folderPath": "Core/Scripting/Action",
        "inDepth": "Python Script From String will return the result of the node's inputs passed through a string Python script. In the example below, a Python script is retrieved from a text file and converted into a string. A cube created from Cuboid.ByCorners is arrayed and translated by the Python script by looping through both X and Y."
    },
    {
        "Name": "Center",
        "imageFile": ["Center"],
        "dynFile": ["Center"],
        "folderPath": "Core/String/Action",
        "inDepth": "Center will increase the width of an input string according to the newWidth input by adding the padChars input on both sides of the original string. If the original string is longer than the newWidth input, this node will return the original string unchanged. In the example below, we use the string 'Hello World' as the input string. A string with an underscore character is used as the padding character, while an integer slider is used to control the new width of the centered string."
    },
    {
        "Name": "ChangeCase",
        "imageFile": ["ChangeCase"],
        "dynFile": ["ChangeCase"],
        "folderPath": "Core/String/Action",
        "inDepth": "Change Case takes a string and a boolean value as input. If the boolean input is 'true', it will change the input string to upper case. If the boolean input is false, it will change the input string to lower case. In the example below, we use an example string 'Hello World' as the input string, and a boolean toggle to specify whether to change the string to all upper case or all lower case letters."
    },
    {
        "Name": "Concat",
        "imageFile": ["Concat"],
        "dynFile": ["Concat"],
        "folderPath": "Core/String/Action",
        "inDepth": "Concat will concatenate multiple strings together into a single string. The number of input strings can be changed by using the '+' and '-' buttons on the Concat node. In the example below, we start with two separate strings 'Hello' and 'World'. They are concatenated together to 'HelloWorld' using the Concat node."
    },
    {
        "Name": "Contains",
        "imageFile": ["Contains"],
        "dynFile": ["Contains"],
        "folderPath": "Core/String/Action",
        "inDepth": "Contains will search one given string for a second input string. If the first string contains the second, it will return true. If not, it will return false. By default, this node is case sensitive. A boolean value can be used to ignore the case of the strings when searching. In the example below we use the string 'Hello World' and search for the string 'E'. By using a boolean toggle set to true for the ignoreCase input, the Contains node returns true."
    },
    {
        "Name": "CountOccurrences",
        "imageFile": ["CountOccurrences"],
        "dynFile": ["CountOccurrences"],
        "folderPath": "Core/String/Action",
        "inDepth": "Count Occurrences will search a given string for a second input string, and will return the number of times that second string is found within the first string. By default this node is case sensitive. A boolean value can be used in the 'ignoreCase' input to make the node ignore the case of the strings. In the example below, we using the string 'Hello World' and search for the string 'L'. Because ignoreCase is set to true, the CountOccurrences finds the given string three times within 'Hello World'."
    },
    {
        "Name": "EndsWith",
        "imageFile": ["EndsWith"],
        "dynFile": ["EndsWith"],
        "folderPath": "Core/String/Action",
        "inDepth": "Ends With will return a boolean value based on whether a given string ends with a second input string. By default this node is case sensitive. A boolean value can be used in the 'ignoreCase' input to make the node ignore the case of the strings. In the example below, we use the string 'Hello World' as the original string, and use a second string 'orld' as the string to search for. Because 'Hello World' ends in the string 'orld', the EndsWith node returns true."
    },
    {
        "Name": "IndexOf",
        "imageFile": ["IndexOf"],
        "dynFile": ["IndexOf"],
        "folderPath": "Core/String/Action",
        "inDepth": "IndexOf will search a given string for a second input string. If the second string is found, this node will return the index of the first character of the first occurrence of the string.  By default this node is case sensitive. A boolean value can be used in the 'ignoreCase' input to make the node ignore the case of the strings. In the example below, we use the string 'Hello World', and search for the character 'o', This letter occurs twice in the string, but only the index of the first occurrence is returned by the IndexOf node."
    },
    {
        "Name": "Insert",
        "imageFile": ["Insert"],
        "dynFile": ["Insert"],
        "folderPath": "Core/String/Action",
        "inDepth": "Insert will insert a given string into a base string at a specified index. In the example below, we start with the base string 'Hello World'. We use a second string 'Hi!' as the string to insert. An integery slider is used to control the index at which the second string will be inserted into the base string."
    },
    {
        "Name": "Join",
        "imageFile": ["Join"],
        "dynFile": ["Join"],
        "folderPath": "Core/String/Action",
        "inDepth": "Join will concatenate a series of strings together into a single string using a specified separator string between them. In the example below, we use an underscore character as the separator. We create three strings to concatenate together. The number of string inputs this node will accept can be changed by using the '+' and '-' buttons on the node."
    },
    {
        "Name": "LastIndexOf",
        "imageFile": ["LastIndexOf"],
        "dynFile": ["LastIndexOf"],
        "folderPath": "Core/String/Action",
        "inDepth": "Last Index Of will search a given string for a second input string. If the second string is found, this node will return the index of the last occurrence. By default this node is case sensitive. A boolean value can be used in the 'ignoreCase' input to make the node ignore the case of the strings. In the example below, we use the string 'Hello World', and search for the string 'o'. This string is found twice within the base string, and the index of the final occurrence of the string is returned."
    },
    {
        "Name": "Length",
        "imageFile": ["Length"],
        "dynFile": ["Length"],
        "folderPath": "Core/String/Action",
        "inDepth": "Length returns the number of characters in an input string. In the example below, we start with the string 'Hello World'. By using a Length node, we see that this string has 11 characters."
    },
    {
        "Name": "PadLeft",
        "imageFile": ["PadLeft"],
        "dynFile": ["PadLeft"],
        "folderPath": "Core/String/Action",
        "inDepth": "PadLeft will increase the width of an input string according to the newWidth input by adding the padChars input on the left side of the original string. If the original string is longer than the newWidth input, this node will return the original string unchanged. In the example below, we use the string 'Hello World' as the input string. A string with an underscore character is used as the padding character, while an integer slider is used to control the new width of the string."
    },
    {
        "Name": "PadRight",
        "imageFile": ["PadRight"],
        "dynFile": ["PadRight"],
        "folderPath": "Core/String/Action",
        "inDepth": "PadRight will increase the width of an input string according to the newWidth input by adding the padChars input on the right side of the original string. If the original string is longer than the newWidth input, this node will return the original string unchanged. In the example below, we use the string 'Hello World' as the input string. A string with an underscore character is used as the padding character, while an integer slider is used to control the new width of the string."
    },
    {
        "Name": "Remove",
        "imageFile": ["Remove"],
        "dynFile": ["Remove"],
        "folderPath": "Core/String/Action",
        "inDepth": "Remove takes a string as input, and will remove characters from that string starting at the 'startIndex' input. The number of characters to be removed is specified by the 'count' index. In the example below, we start with the string 'Hello World'. Two integer sliders are used to control the startIndex and count of the characters to be removed by a Remove node."
    },
    {
        "Name": "Replace",
        "imageFile": ["Replace"],
        "dynFile": ["Replace"],
        "folderPath": "Core/String/Action",
        "inDepth": "Replace will search a given string for a second input string. If that string is found, it will be replaced by a third input string. This node is case sensitive. In the example below, we start with the string 'Hello World'. The string 'o' is used as the string to search for, and a third string 'Hi!' is input as the string to replace with. Because the letter 'o' occurs twice within the original string, it is replaced in both occurrence with the string 'Hi!'."
    },
    {
        "Name": "Split",
        "imageFile": ["Split"],
        "dynFile": ["Split"],
        "folderPath": "Core/String/Action",
        "inDepth": "Split takes an input string and splits it according to a series of separators. The separator strings, if found, are removed from the original string, and a list of the fragments are returned. The number of separators to split by can be adjusted by using the '+' and '-' buttons on the node. In the example below, we start with the string 'Hello World'. The string 'o' is used as the separators string. The result is three fragments of the original string."
    },
    {
        "Name": "StartsWith",
        "imageFile": ["StartsWith"],
        "dynFile": ["StartsWith"],
        "folderPath": "Core/String/Action",
        "inDepth": "Starts With will return a boolean value based on whether a given string starts with a second input string. By default this node is case sensitive. A boolean value can be used in the 'ignoreCase' input to make the node ignore the case of the strings. In the example below, we use the string 'Hello World' as the original string, and use a second string 'h' as the string to search for. Because 'Hello World' starts with the string 'h' and ignoreCase is set to true, the StartsWith node returns true."
    },
    {
        "Name": "String from Array",
        "imageFile": [],
        "dynFile": [],
        "folderPath": "Core/String/Action",
        "inDepth": "Add in-depth information about String from Array..."
    },
    {
        "Name": "String from Object",
        "imageFile": ["String from Object"],
        "dynFile": ["String from Object"],
        "folderPath": "Core/String/Action",
        "inDepth": "Add in-depth information about String from Object..."
    },
    {
        "Name": "Substring",
        "imageFile": ["Substring"],
        "dynFile": ["Substring"],
        "folderPath": "Core/String/Action",
        "inDepth": "Substring takes an input string and returns a sub string based on the start index and length inputs. In the example below, we start with the string 'Hello World'. Two integer sliders are used to control where to start the substring and how many characters to take."
    },
    {
        "Name": "ToLower",
        "imageFile": ["ToLower"],
        "dynFile": ["ToLower"],
        "folderPath": "Core/String/Action",
        "inDepth": "To Lower will convert an input string to lower case letters. In the example below we start with the string 'Hello World'. By using a ToLower node, we change this string to 'hello world'."
    },
    {
        "Name": "ToNumber",
        "imageFile": ["ToNumber"],
        "dynFile": ["ToNumber"],
        "folderPath": "Core/String/Action",
        "inDepth": "To Number will convert an input string to a number data type. This node requires a string that has the format of a number. In the example below, we can see that the string 'Hello World' cannot be converted to a number, while the string '5.2' can be converted to number 5.2 "
    },
    {
        "Name": "ToUpper",
        "imageFile": ["ToUpper"],
        "dynFile": ["ToUpper"],
        "folderPath": "Core/String/Action",
        "inDepth": "To Upper will convert an input string to upper case letters. In the example below we start with the string 'Hello World'. By using a ToUpper node, we change this string to 'HELLO WORLD'."
    },
    {
        "Name": "TrimLeadingWhitespace",
        "imageFile": ["TrimLeadingWhitespace"],
        "dynFile": ["TrimLeadingWhitespace"],
        "folderPath": "Core/String/Action",
        "inDepth": "TrimLeadingWhitespace will remove the whitespace at the beginning of an input string. In the example below, we start with the string '     Hello World', which has several leading and trailing spaces. By using TrimLeadingWhitespace, we can remove the spaces at the beginning of the string."
    },
    {
        "Name": "TrimTrailingWhitespace",
        "imageFile": ["TrimTrailingWhitespace"],
        "dynFile": ["TrimTrailingWhitespace"],
        "folderPath": "Core/String/Action",
        "inDepth": "TrimTrailingWhitespace will remove the whitespace at the end of an input string. In the example below, we start with the string '     Hello World     ', which has several leading and trailing spaces. By using TrimTrailingWhitespace, we can remove the spaces at the end of the string."
    },
    {
        "Name": "TrimWhitespace",
        "imageFile": ["TrimWhitespace"],
        "dynFile": ["TrimWhitespace"],
        "folderPath": "Core/String/Action",
        "inDepth": "TrimWhitespace will remove all the whitespace of an input string. In the example below, we start with the string '     Hello World     ', which has several leading and trailing spaces. By using TrigWhitespace, we can remove the spaces at the beginning and end of the string, as well as the space between 'Hello' and 'World'."
    },
    {
        "Name": "Pause",
        "imageFile": [
            "Pause"
        ],
        "dynFile": [
            "Pause"
        ],
        "folderPath": "Core/Thread/Action",
        "inDepth": "Pause will return the result of a node after pausing the thread for a specified amount of time. In the example below, a circle is extruded into a surface 5 seconds after the thread is run. To use the time delay, the program should be run in Manual."
    },
    {
        "Name": "Add",
        "imageFile": [
            "Add"
        ],
        "dynFile": [
            "Add"
        ],
        "folderPath": "Core/TimeSpan/Action",
        "inDepth": "Add will return a new TimeSpan as the sum of two TimeSpans. In the example below, a TimeSpan of 10 Days is added to one of 5 Hours, returning a new TimeSpan of 10 Days and 5 Hours."
    },
    {
        "Name": "ByDateDifference",
        "imageFile": [
            "ByDateDifference"
        ],
        "dynFile": [
            "ByDateDifference"
        ],
        "folderPath": "Core/TimeSpan/Action",
        "inDepth": "ByDateDifference will return the difference of two DateTimes as a new TimeSpan. In the example below, the difference between Now and November 14, 2000 11:57AM was returned as 5844 Days, and roughly 4 Seconds."
    },
    {
        "Name": "Components",
        "imageFile": [
            "Components"
        ],
        "dynFile": [
            "Components"
        ],
        "folderPath": "Core/TimeSpan/Action",
        "inDepth": "Components will return the Days, Hours, Minutes, etc of a TimeSpan. In the example below, a TimeSpan of 5:16:21 returns 0 Days, 5 Hours, 6 Minutes, 21 Seconds, and 0 Milliseconds."
    },
    {
        "Name": "Create",
        "imageFile": [
            "Create"
        ],
        "dynFile": [
            "Create"
        ],
        "folderPath": "Core/TimeSpan/Action",
        "inDepth": "Create will return a new TimeSpan based on days, hours, minutes, seconds, and milliseconds. In the example below, we create the TimeSpan 2.03:30:00, or 2 Days, 3 Hours, and 30 Minutes."
    },
    {
        "Name": "FromString",
        "imageFile": [
            "FromString"
        ],
        "dynFile": [
            "FromString"
        ],
        "folderPath": "Core/TimeSpan/Action",
        "inDepth": "FromString will return a TimeSpan from a String. In the example below, a String \"5:6:21\" will return a TimeSpan of 5 Hours, 6 Minutes, and 21 Seconds."
    },
    {
        "Name": "Negate",
        "imageFile": [
            "Negate"
        ],
        "dynFile": [
            "Negate"
        ],
        "folderPath": "Core/TimeSpan/Action",
        "inDepth": "Negate will return the negative of a TimeSpan. In the example below, a TimeSpan of 2 Days, 3 Hours, and 30 minutes is made negative (-2.03:30:00)."
    },
    {
        "Name": "Scale",
        "imageFile": [
            "Scale"
        ],
        "dynFile": [
            "Scale"
        ],
        "folderPath": "Core/TimeSpan/Action",
        "inDepth": "Scale will return a new TimeSpan scaled by a factor. In the example below, a TimeSpan (2.03:30:00) is scaled by a factor of 2 (4.07:00:00)."
    },
    {
        "Name": "Subtract",
        "imageFile": [
            "Subtract"
        ],
        "dynFile": [
            "Subtract"
        ],
        "folderPath": "Core/TimeSpan/Action",
        "inDepth": "Subtract will return a new TimeSpan by subtracting one TimeSpan from another. In the example below, a new TimeSpan of 9 Days and 19 Hours is created by subtracting a TimeSpan of 5 Hours from one of 10 Days."
    },
    {
        "Name": "TotalDays",
        "imageFile": [
            "TotalDays"
        ],
        "dynFile": [
            "TotalDays"
        ],
        "folderPath": "Core/TimeSpan/Action",
        "inDepth": "TotalDays will return the number of days in a TimeSpan as a double. In the example below, the total number of days returned from the TimeSpan 2.03:00:00 is ~2.1458333."
    },
    {
        "Name": "TotalHours",
        "imageFile": [
            "TotalHours"
        ],
        "dynFile": [
            "TotalHours"
        ],
        "folderPath": "Core/TimeSpan/Action",
        "inDepth": "TotalHours will return the number of hours in a TimeSpan as a double. In the example below, the total number of hours returned from the TimeSpan 2.03:00:00 is 51.5."
    },
    {
        "Name": "TotalMilliseconds",
        "imageFile": [
            "TotalMilliseconds"
        ],
        "dynFile": [
            "TotalMilliseconds"
        ],
        "folderPath": "Core/TimeSpan/Action",
        "inDepth": "TotalMilliseconds will return the number of milliseconds in a TimeSpan as a double. In the example below, the total number of milliseconds returned from the TimeSpan 2.03:00:00 is 185400000."
    },
    {
        "Name": "TotalMinutes",
        "imageFile": [
            "TotalMinutes"
        ],
        "dynFile": [
            "TotalMinutes"
        ],
        "folderPath": "Core/TimeSpan/Action",
        "inDepth": "TotalMinutes will return the number of minutes in a TimeSpan as a double. In the example below, the total number of minutes returned from the TimeSpan 2.03:00:00 is 3090."
    },
    {
        "Name": "TotalSeconds",
        "imageFile": [
            "TotalSeconds"
        ],
        "dynFile": [
            "TotalSeconds"
        ],
        "folderPath": "Core/TimeSpan/Action",
        "inDepth": "TotalSeconds will return the number of seconds in a TimeSpan as a double. In the example below, the total number of seconds returned from the TimeSpan 2.03:00:00 is 185400."
    },
    {
        "Name": "MaxValue",
        "imageFile": [
            "MaxValue"
        ],
        "dynFile": [
            "MaxValue"
        ],
        "folderPath": "Core/TimeSpan/Query",
        "inDepth": "MaxValue will return the maximum value that a TimeSpan can have. In the example below, a TimeSpan of 10,675,199 Days, 2 Hours, 28 Minutes, 5 Seconds, 477 Milliseconds is returned."
    },
    {
        "Name": "MinValue",
        "imageFile": [
            "MinValue"
        ],
        "dynFile": [
            "MinValue"
        ],
        "folderPath": "Core/TimeSpan/Query",
        "inDepth": "MinValue will return the minimum value that a TimeSpan can have. In the example below, a TimeSpan of 10,675,199 Days, 2 Hours, 28 Minutes, 5 Seconds, 477 Milliseconds is returned."
    },
    {
        "Name": "Zero",
        "imageFile": [
            "Zero"
        ],
        "dynFile": [
            "Zero"
        ],
        "folderPath": "Core/TimeSpan/Query",
        "inDepth": "Zero will return a new TimeSpan with no elapsed time. In the example below, a TimeSpan of Zero is displayed as 00:00:00."
    },
    {
        "Name": "Convert Between Units",
        "imageFile": [
            "Convert Between Units"
        ],
        "dynFile": [
            "Convert Between Units"
        ],
        "folderPath": "Core/Units/Action",
        "inDepth": "Convert Between Units will return a converted value based on input and output units. In the example below, 4 meters is converted to feet returning a value of ~13.1234."
    },
    {
        "Name": "Number From Feet and Inches",
        "imageFile": [
            "Number From Feet and Inches"
        ],
        "dynFile": [
            "Number From Feet and Inches"
        ],
        "folderPath": "Core/Units/Action",
        "inDepth": "Number From Feet and Inches will return a double from feet and inches inputs. In the example below, 2ft 1in returns a double of 2.08333"
    },
    {
        "Name": "Unit Types",
        "imageFile": [
            "Unit Types"
        ],
        "dynFile": [
            "Unit Types"
        ],
        "folderPath": "Core/Units/Action",
        "inDepth": "Add in-depth information about Unit Types..."
    },
    {
        "Name": "Watch",
        "imageFile": [
            "Watch"
        ],
        "dynFile": [
            "Watch"
        ],
        "folderPath": "Core/View/Action",
        "inDepth": "Watch will display the output of a node in list format. In the example below, the contents of an Excel file are returned as a list and displayed in a Watch node. Watch is useful for understanding the list structures, geometry types, etc that different nodes return."
    },
    {
        "Name": "Watch 3D",
        "imageFile": [
            "Watch 3D"
        ],
        "dynFile": [
            "Watch 3D"
        ],
        "folderPath": "Core/View/Action",
        "inDepth": "Watch 3D will preview the geometry output of a node in a new workspace window. In the example below, a Solid is previewed in the Watch3D node while its PolySurface bounding box is previewed in the workspace."
    },
    {
        "Name": "Watch Image",
        "imageFile": [
            "Watch Image"
        ],
        "dynFile": [
            "Watch Image"
        ],
        "folderPath": "Core/View/Action",
        "inDepth": "Watch Image will preview a bitmap. In the example below, a bitmap used as a height field is previewed in a Watch Image node. This allows us to compare the resulting geometry with the original image."
    },
    {
        "Name": "Web Request",
        "imageFile": [
            "Web Request"
        ],
        "dynFile": [
            "Web Request"
        ],
        "folderPath": "Core/Web/Action",
        "inDepth": "Web Request will return the content of a webpage from an input URL as a string. In the example below, a web request is made to http://www.google.com and its HTML content is returned."
    },
    {
        "Name": "ByGeometryColor",
        "imageFile": [
            "ByGeometryColor"
        ],
        "dynFile": [
            "ByGeometryColor"
        ],
        "folderPath": "Display/Display/Display/Create",
        "inDepth": "ByGeometryColor will display a piece of geometry with an input color. In the example below, a circle is displayed with an RGB color of 227, 136, 200 and an Alpha value of 200. Unless it is turned off, the preview of the original geometry will cover up the new colored one."
    },
    {
        "Name": "BySurfaceColors",
        "imageFile": [
            "BySurfaceColors"
        ],
        "dynFile": [
            "BySurfaceColors"
        ],
        "folderPath": "Display/Display/Display/Create",
        "inDepth": "BySurfaceColors will display the input geometry with a gradient of colors. In the example below, a circle is displayed with a gradient of two RGB colors. Unless it is turned off, the preview of the original geometry will cover up the new colored one."
    },
    {
        "Name": "ByBestFitThroughPoints",
        "imageFile": [
            "ByBestFitThroughPoints"
        ],
        "dynFile": [
            "ByBestFitThroughPoints"
        ],
        "folderPath": "Geometry/Arc/Create",
        "inDepth": "<p>Arc.ByBestFitThroughPoints draws an arc that best represents three or more points. This example creates an arc from a list of random points ranging from 0 to 4 in the X and Y directions.</p>"
    },
    {
        "Name": "ByCenterPointRadiusAngle",
        "imageFile": [
            "ByCenterPointRadiusAngle"
        ],
        "dynFile": [
            "ByCenterPointRadiusAngle"
        ],
        "folderPath": "Geometry/Arc/Create",
        "inDepth": "Arc ByCenterPointRadiusAngle draws an arc relative to its center and normal direction. By entering the start and end angle, you are essentially drawing a portion of a circle. In this example, a random point is generated on the XY plane and an arc is constructed around it.  "
    },
    {
        "Name": "ByCenterPointStartPointEndPoint",
        "imageFile": [
            "ByCenterPointStartPointEndPoint"
        ],
        "dynFile": [
            "ByCenterPointStartPointEndPoint"
        ],
        "folderPath": "Geometry/Arc/Create",
        "inDepth": "Arc ByCenterPointStartPointEndPoint draws a best-fit arc around a specified Center. The arc will always begin at the Start Point and end at the closest point possible to the given End Point. This example demonstrates this property by randomly feeding the node three random points for the center, start and end point."
    },
    {
        "Name": "ByCenterPointStartPointSweepAngle",
        "imageFile": [
            "ByCenterPointStartPointSweepAngle"
        ],
        "dynFile": [
            "ByCenterPointStartPointSweepAngle"
        ],
        "folderPath": "Geometry/Arc/Create",
        "inDepth": "The Arc ByCenterPointStartPointSweepAngle creates an arc around a Center Point with a given Sweep Angle. The Start Point tells Dynamo where to begin drawing the arc. This example draws an arc around a randomly generated point."
    },
    {
        "Name": "ByFillet",
        "imageFile": [
            "ByFillet"
        ],
        "dynFile": [
            "ByFillet"
        ],
        "folderPath": "Geometry/Arc/Create",
        "inDepth": "Arc ByFillet draws a portion of a tangential circle along two input curves. In this example, two intersecting lines are drawn and then filleted at a controlled radius."
    },
    {
        "Name": "ByFilletTangentToCurve",
        "imageFile": [
            "ByFilletTangentToCurve"
        ],
        "dynFile": [
            "ByFilletTangentToCurve"
        ],
        "folderPath": "Geometry/Arc/Create",
        "inDepth": "Arc ByFilletTangentToCurve draws the best fit arc that is tangent to three input curves. In this example, we are using two input lines as reference curves and a circle for the arc to be tangent to."
    },
    {
        "Name": "ByStartPointEndPointStartTangent",
        "imageFile": [
            "ByStartPointEndPointStartTangent"
        ],
        "dynFile": [
            "ByStartPointEndPointStartTangent"
        ],
        "folderPath": "Geometry/Arc/Create",
        "inDepth": "Arc ByStartPointEndPointStartTangent draws an arc from two specified points and any given start vector. This example draws an arc from two random points that is always tangent to the X-Axis."
    },
    {
        "Name": "ByThreePoints",
        "imageFile": [
            "ByThreePoints"
        ],
        "dynFile": [
            "ByThreePoints"
        ],
        "folderPath": "Geometry/Arc/Create",
        "inDepth": "Arc ByThreePoints draws an arc from three points, given the Start Point, End Point and a point in-between along the arc. This example draws an arc from three randomly created points."
    },
    {
        "Name": "ByStartEndAndTangencies",
        "imageFile": [
            "ByStartAndEndTangencies"
        ],
        "dynFile": [
            "ByStartAndEndTangencies"
        ],
        "folderPath": "Geometry/Arc/Action",
        "inDepth": "The Arc ByStartEndAndTangencies Action creates a compound arc using two Input Points and their corresponding Vectors. In this example, two points are connected by a compound arc that is always tangent to the Y-Axis at its Start and End Points."
    },
    {
        "Name": "CenterPoint",
        "imageFile": [
            "CenterPoint"
        ],
        "dynFile": [
            "CenterPoint"
        ],
        "folderPath": "Geometry/Arc/Query",
        "inDepth": "Arc CenterPoint returns a Point at the Center of an Arc – the same point as the corresponding circle center. This example uses a randomly generated ArcByThreePoints to create the center point."
    },
    {
        "Name": "Radius",
        "imageFile": [
            "Radius"
        ],
        "dynFile": [
            "Radius"
        ],
        "folderPath": "Geometry/Arc/Query",
        "inDepth": "Arc Radius returns the Radius value of Arc geometry. In this example, we can visualize the change in Radius as the input points change in the Y-direction."
    },
    {
        "Name": "StartAngle",
        "imageFile": [
            "StartAngle"
        ],
        "dynFile": [
            "StartAngle"
        ],
        "folderPath": "Geometry/Arc/Query",
        "inDepth": "Arc StartAngle returns the Angle of the Arc relative to its corresponding Circle. Since this example uses a Start Point to generate the Arc, our Start Angle should always be equal to zero."
    },
    {
        "Name": "SweepAngle",
        "imageFile": [
            "SweepAngle"
        ],
        "dynFile": [
            "SweepAngle"
        ],
        "folderPath": "Geometry/Arc/Query",
        "inDepth": "Arc SweepAngle returns the total angle of the reference circle that the Arc traverses. This example shows how this property is accessed from an Arc ByThreePoints."
    },
    {
        "Name": "ByCorners",
        "imageFile": [
            "ByCorners"
        ],
        "dynFile": [
            "ByCorners"
        ],
        "folderPath": "Geometry/BoundingBox/Create",
        "inDepth": "Bounding Box ByCorners creates a Bounding Box from two input points. In this example we are using the diagonal vector to Translate the Start Point of the box to create its End Point. In order to visualize the Box, we are converting the box to a Polysurface and extracting its edge curves."
    },
    {
        "Name": "ByGeometry (geom)",
        "imageFile": [
            "ByGeometry_gg"
        ],
        "dynFile": [
            "ByGeometry_gg"
        ],
        "folderPath": "Geometry/BoundingBox/Create",
        "inDepth": "Bounding Box ByGeometry solves a Bounding Box of multiple input Geometry. This example shows a Bounding Box drawn around multiple Cones. In order to visualize the Box, we are converting the box to a Polysurface and extracting its edge curves."
    },
    {
        "Name": "ByGeometry (geom)",
        "imageFile": [
            "ByGeometry_gg"
        ],
        "dynFile": [
            "ByGeometry_gg"
        ],
        "folderPath": "Geometry/BoundingBox/Create",
        "inDepth": "Bounding Box ByGeometry solves a Bounding Box of multiple input Geometry. This example shows a Bounding Box drawn around multiple Cones. In order to visualize the Box, we are converting the box to a Polysurface and extracting its edge curves."
    },
    {
        "Name": "Contains",
        "imageFile": [
            "Contains"
        ],
        "dynFile": [
            "Contains"
        ],
        "folderPath": "Geometry/BoundingBox/Action",
        "inDepth": "Bounding Box Contains tests if a specified Point is inside of a Bounding Box. Because the Point in this example is at (5,5,5), and our Origin Sphere’s Radius is larger than 5, the Contains node will return True."
    },
    {
        "Name": "Intersection",
        "imageFile": [
            "Intersection"
        ],
        "dynFile": [
            "Intersection"
        ],
        "folderPath": "Geometry/BoundingBox/Action",
        "inDepth": "Bounding Box Intersection solves for the Intersection for two Bounding Boxes and returns the overlapping Bounding Box. This example uses two cones to demonstrate the use of this node. In order to visualize the Box we are converting it to a Cuboid."
    },
    {
        "Name": "Intersects",
        "imageFile": [
            "Intersects"
        ],
        "dynFile": [
            "Intersects"
        ],
        "folderPath": "Geometry/BoundingBox/Action",
        "inDepth": "Bounding Box Intersects tests two bounding boxes for overlap. If the boxes intersect, the node will return True, otherwise it will return False. This example tests for an intersection between the Bounding Boxes of two input Cones."
    },
    {
        "Name": "IsEmpty",
        "imageFile": [
            "IsEmpty"
        ],
        "dynFile": [
            "IsEmpty"
        ],
        "folderPath": "Geometry/BoundingBox/Action",
        "inDepth": "IsEmpty will return a boolean value based on whether the Bounding Box is empty or not."
    },
    {
        "Name": "ToCuboid",
        "imageFile": [
            "ToCuboid"
        ],
        "dynFile": [
            "ToCuboid"
        ],
        "folderPath": "Geometry/BoundingBox/Action",
        "inDepth": "Bounding Box ToCuboid creates a Cuboid geometry from a Bounding Box. In order to visualize the relationship of the input Sphere to the Cuboid in the example, we are extracting its edge curves."
    },
    {
        "Name": "ToPolySurface",
        "imageFile": [
            "ToPolySurface"
        ],
        "dynFile": [
            "ToPolySurface"
        ],
        "folderPath": "Geometry/BoundingBox/Action",
        "inDepth": "ToPolySurface will return a bounding box as a PolySurface. In the example below, the bounding box of several unioned spheres is returned as a PolySurface. The resulting PolySurface is displayed with a color and transparency to show the original geometry inside."
    },
    {
        "Name": "MaxPoint",
        "imageFile": [
            "MaxPoint"
        ],
        "dynFile": [
            "MaxPoint"
        ],
        "folderPath": "Geometry/BoundingBox/Query",
        "inDepth": "Bounding Box MaxPoint returns the point that has the largest X, Y and Z values. This example shows a Bounding Box MaxPoint of a Sphere."
    },
    {
        "Name": "MinPoint",
        "imageFile": [
            "MinPoint"
        ],
        "dynFile": [
            "MinPoint"
        ],
        "folderPath": "Geometry/BoundingBox/Query",
        "inDepth": "Bounding Box MinPoint returns the point that has the smallest X, Y and Z values. This example shows a Bounding Box MinPoint of a Sphere."
    },
    {
        "Name": "ByBestFitThroughPoints",
        "imageFile": [
            "ByBestFitThroughPoints"
        ],
        "dynFile": [
            "ByBestFitThroughPoints"
        ],
        "folderPath": "Geometry/Circle/Create",
        "inDepth": "Circle By Best Fit Through Points receives point inputs and creates a best fit circle through them. In this example, we can dynamically increase the number of randomly generated points with a Number Slider, altering the shape of the best-fit circle. "
    },
    {
        "Name": "ByCenterPointRadius",
        "imageFile": [
            "ByCenterPointRadius"
        ],
        "dynFile": [
            "ByCenterPointRadius"
        ],
        "folderPath": "Geometry/Circle/Create",
        "inDepth": "Circle By Center Point Radius is a simplified node to create a circle with a the Z-Plane normal. This definition uses a code block to create a point in three-dimensional space, and locates the circle around the point. The radius is controlled dynamically with a Number Slider."
    },
    {
        "Name": "ByCenterPointRadiusNormal",
        "imageFile": [
            "ByCenterPointRadiusNormal"
        ],
        "dynFile": [
            "ByCenterPointRadiusNormal"
        ],
        "folderPath": "Geometry/Circle/Create",
        "inDepth": "Circle By Center Point Radius Normal creates a circle at a point with a controllable radius and normal. In this example, we create a vector from the Origin Point to the Point By Coordinates to control the direction of the circle."
    },
    {
        "Name": "ByPlaneRadius",
        "imageFile": [
            "ByPlaneRadius"
        ],
        "dynFile": [
            "ByPlaneRadius"
        ],
        "folderPath": "Geometry/Circle/Create",
        "inDepth": "Circle By Plane Radius is a condensed node to create any type of circle. In this example, we use the YZ plane to determine the circle direction, and a Number slider to dynamically control the circle’s radius."
    },
    {
        "Name": "ByThreePoints",
        "imageFile": [
            "ByThreePoints"
        ],
        "dynFile": [
            "ByThreePoints"
        ],
        "folderPath": "Geometry/Circle/Create",
        "inDepth": "Circle By Three Points receives point inputs and creates a circle. This example shows how thee randomly generated points on the Z-plane will always result in a circle."
    },
    {
        "Name": "CenterPoint",
        "imageFile": [
            "CenterPoint"
        ],
        "dynFile": [
            "CenterPoint"
        ],
        "folderPath": "Geometry/Circle/Query",
        "inDepth": "Center Point will find the center point of a given circle. In the example below, we create a circle using Best Fit Through Points, and then extract the center point of the generated circle. "
    },
    {
        "Name": "Radius",
        "imageFile": [
            "Radius"
        ],
        "dynFile": [
            "Radius"
        ],
        "folderPath": "Geometry/Circle/Query",
        "inDepth": "Radius will find the center point of a given circle. In the example below, we create a circle using Best Fit Through Points, and then extract the radius of the generated circle.  "
    },
    {
        "Name": "ByCoordinateSystemHeightRadii",
        "imageFile": [
            "ByCoordinateSystemHeightRadii"
        ],
        "dynFile": [
            "ByCoordinateSystemHeightRadii"
        ],
        "folderPath": "Geometry/Cone/Create",
        "inDepth": "Cone ByCoordinateSystemHeightRadii creates a truncated Cone geometry from two Radii, the starting Origin, and a Height value. This example shows a dynamic Cone around the World Origin, constructed with three Number Sliders."
    },
    {
        "Name": "ByCoordinateSystemHeightRadius",
        "imageFile": [
            "ByCoordinateSystemHeightRadius"
        ],
        "dynFile": [
            "ByCoordinateSystemHeightRadius"
        ],
        "folderPath": "Geometry/Cone/Create",
        "inDepth": "Cone ByCoordinateSystemHeightRadius creates a Cone geometry from a Radius, the Cone Origin, and a Height value. This example shows a dynamic Cone around the World Origin, constructed with two Number Sliders."
    },
    {
        "Name": "ByPointsRadii",
        "imageFile": [
            "ByPointsRadii"
        ],
        "dynFile": [
            "ByPointsRadii"
        ],
        "folderPath": "Geometry/Cone/Create",
        "inDepth": "Cone ByPointsRadii creates a truncated Cone geometry from a Start Point, End Point, and two Radius values. This example shows a dynamic Cone around the World Origin, constructed with three Number Sliders controlling its Height and Radius sizes."
    },
    {
        "Name": "ByPointsRadius",
        "imageFile": [
            "ByPointsRadius"
        ],
        "dynFile": [
            "ByPointsRadius"
        ],
        "folderPath": "Geometry/Cone/Create",
        "inDepth": "Cone ByPointsRadius creates a Cone geometry from a Start Point, End Point, and a Radius value. This example shows a dynamic Cone around the World Origin, constructed with two Number Sliders controlling its Height and Radius size."
    },
    {
        "Name": "EndPoint",
        "imageFile": [
            "EndPoint"
        ],
        "dynFile": [
            "EndPoint"
        ],
        "folderPath": "Geometry/Cone/Query",
        "inDepth": "End Point will find the apex of a cone, or the center of the top circle of a truncated cone. In the example below, we create a cone by specifying a Coordinate System and two radii. We then use End Point to find the center of the top circle of the cone. "
    },
    {
        "Name": "EndRadius",
        "imageFile": [
            "EndRadius"
        ],
        "dynFile": [
            "EndRadius"
        ],
        "folderPath": "Geometry/Cone/Query",
        "inDepth": "End Radius will find the radius of the top circle of a truncated cone. In the example below, we create a cone by specifying a start and end point, as well as a start and end radius. We can then extract the End Radius back from the cone."
    },
    {
        "Name": "Height",
        "imageFile": [
            "Height"
        ],
        "dynFile": [
            "Height"
        ],
        "folderPath": "Geometry/Cone/Query",
        "inDepth": "Height will find the height of the cone, which is equal to the distance between the start point and end point. In the example below, we create a cone by specifying a start and end point, as well as a start and end radius. We can then extract the height out from the cone."
    },
    {
        "Name": "RadiusRatio",
        "imageFile": [
            "RadiusRatio"
        ],
        "dynFile": [
            "RadiusRatio"
        ],
        "folderPath": "Geometry/Cone/Query",
        "inDepth": "Radius Ratio will find the ratio between the top and bottom radii of the cone. This is equivalent to taking the top radius and dividing it by the bottom radius. In the example below, we create a cone by specifying a start and end point, as well as a start and end radius. We can then extract the Radius Ratio from the cone."
    },
    {
        "Name": "StartPoint",
        "imageFile": [
            "StartPoint"
        ],
        "dynFile": [
            "StartPoint"
        ],
        "folderPath": "Geometry/Cone/Query",
        "inDepth": "Start Point will find the center of the base of a cone. In the example below, we create a cone by specifying a Coordinate System and two radii. We then use Start Point to find the center of the bottom circle of the cone. "
    },
    {
        "Name": "StartRadius",
        "imageFile": [
            "StartRadius"
        ],
        "dynFile": [
            "StartRadius"
        ],
        "folderPath": "Geometry/Cone/Query",
        "inDepth": "Start Radius will find the radius of the base circle of a cone. In the example below, we create a cone by specifying a start and end point, as well as a start and end radius. We can then extract the Start Radius back from the cone."
    },
    {
        "Name": "ByCylindricalCoordinates",
        "imageFile": [
            "ByCylindricalCoordinates"
        ],
        "dynFile": [
            "ByCylindricalCoordinates"
        ],
        "folderPath": "Geometry/CoordinateSystem/Create",
        "inDepth": "ByCylindricalCoordinates will return a CoordinateSystem at a cylindrical coordinate location. Instead of X, Y, and Z describing the coordinate location, we use radius, theta, and height. This allows us to create CoordinateSystems around a circle or spiral. In the example below, a set of CoordinateSystems at cylindrical coordinate locations are used for a finer degree of control in a boolean difference operation. The CoordinateSystem allows us to move Spheres into or out of the cylinder, producing indents of variable size."
    },
    {
        "Name": "ByMatrix",
        "imageFile": [],
        "dynFile": [],
        "folderPath": "Geometry/CoordinateSystem/Create",
        "inDepth": "Add in-depth information about ByMatrix..."
    },
    {
        "Name": "ByOrigin (origin)",
        "imageFile": [
            "ByOrigin (origin)"
        ],
        "dynFile": [
            "ByOrigin (origin)"
        ],
        "folderPath": "Geometry/CoordinateSystem/Create",
        "inDepth": "ByOrigin (origin) will return a new CoordinateSystem with it's origin at the input Point. In the example below, a new CoordinateSystem is created with its origin at (4,4,0)."
    },
    {
        "Name": "ByOrigin (x, y)",
        "imageFile": [
            "ByOrigin (x, y)"
        ],
        "dynFile": [
            "ByOrigin (x, y)"
        ],
        "folderPath": "Geometry/CoordinateSystem/Create",
        "inDepth": "ByOrigin (x, y) will return a new CoordinateSystem with the X and Y values of its origin as inputs. In the example below, a new CoordinateSystem is created with it's origin at (4,2,0) from inputs 4 and 2 into X and Y respectively."
    },
    {
        "Name": "ByOrigin (x, y, z)",
        "imageFile": [
            "ByOrigin (x, y, z)"
        ],
        "dynFile": [
            "ByOrigin (x, y, z)"
        ],
        "folderPath": "Geometry/CoordinateSystem/Create",
        "inDepth": "ByOrigin (x, y, z) will return a new CoordinateSystem with the X, Y, and Z values of its origin as the node's inputs. In the example below, a new CoordinateSystem is created with it's origin at (4,2,1) from inputs 4, 2, and 1 into X, Y, and Z respectively."
    },
    {
        "Name": "ByOriginVectors (origin, xAxis, yAxis, zAxis)",
        "imageFile": [],
        "dynFile": [],
        "folderPath": "Geometry/CoordinateSystem/Create",
        "inDepth": "Add in-depth information about ByOriginVectors (origin, xAxis, yAxis, zAxis)..."
    },
    {
        "Name": "ByOriginVectors (origin, xAxis, yAxis)",
        "imageFile": [
            "ByOriginVectors (origin, xAxis, yAxis)"
        ],
        "dynFile": [
            "ByOriginVectors (origin, xAxis, yAxis)"
        ],
        "folderPath": "Geometry/CoordinateSystem/Create",
        "inDepth": "ByOriginVectors (origin, xAxis, yAxis) will return a new CoordinateSystem at an input origin point with input X and Y axes. In the example below, the CoordinateSystem is placed at an origin with new vectors for the X and Y axes. The result is a CoordinateSystem rotated relative to the original CoordinateSystem."
    },
    {
        "Name": "ByPlane",
        "imageFile": [
            "ByPlane"
        ],
        "dynFile": [
            "ByPlane"
        ],
        "folderPath": "Geometry/CoordinateSystem/Create",
        "inDepth": "ByPlane will return a new CoordinateSystem based on an input Plane. In the example below, the normal of the input Plane has been repositioned, resulting in a new CoordinateSystem rotated about the X axis."
    },
    {
        "Name": "BySphericalCoordinates",
        "imageFile": [
            "BySphericalCoordinates"
        ],
        "dynFile": [
            "BySphericalCoordinates"
        ],
        "folderPath": "Geometry/CoordinateSystem/Create",
        "inDepth": "BySphericalCoordinates will return a CoordinateSystem at a spherical coordinate location. Instead of X, Y, and Z describing the coordinate location, we use radius, theta, and phi. In the example below, a Surface is mapped to a Sphere by using Lists of phi and theta values. The number sliders can be adjusted to change how the Surface wraps the Sphere."
    },
    {
        "Name": "Identity (())",
        "imageFile": [
            "Identity"
        ],
        "dynFile": [
            "Identity"
        ],
        "folderPath": "Geometry/CoordinateSystem/Create",
        "inDepth": "Identity will return a CoordinateSystem equal to the World CoordinateSystem. In the example below, the CoordinateSystem returned has an origin of (0,0,0), X, Y, Z axes of (1,0,0), (0,1,0), (0,0,1) respectively, and scale factors of 1."
    },
    {
        "Name": "Identity (matrix)",
        "imageFile": [],
        "dynFile": [],
        "folderPath": "Geometry/CoordinateSystem/Create",
        "inDepth": "Add in-depth information about Identity (matrix)..."
    },
    {
        "Name": "Inverse",
        "imageFile": [
            "Inverse"
        ],
        "dynFile": [
            "Inverse"
        ],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Inverse will return an inverted CoordinateSystem from the input. In the example below, a CoordinateSystem at (1,2,0) is inverted into a CoordinateSystem at (-1,-2,0). The geometry drawn on the CoordinateSystems will be opposite the WCS origin from each other."
    },
    {
        "Name": "IsEqualTo",
        "imageFile": [
            "IsEqualTo"
        ],
        "dynFile": [
            "IsEqualTo"
        ],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "IsEqualTo will return a boolean value based on whether the values of the input CoordinateSystems are equal to each other. In the example below, two CoordinateSystems with identical, positive and negative origin positions are passed through IsEqualTo, returning a false boolean value. However, inverting the positive CoordinateSystem returns a true boolean value from IsEqualTo because it's origin point X and Y values are now negative."
    },
    {
        "Name": "Mirror",
        "imageFile": [
            "Mirror"
        ],
        "dynFile": [
            "Mirror"
        ],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Mirror will return a new CoordinateSystem mirrored across a Plane. In the example below, a CoordinateSystem at coordinates (2,3,1) is mirrored across the YZ Plane of the WCS and returns a CoordinateSystem at (-2,3,1)."
    },
    {
        "Name": "PostMultiplyBy",
        "imageFile": [
            "PostMultiplyBy"
        ],
        "dynFile": [
            "PostMultiplyBy"
        ],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "PostMultiplyBy will return a new CoordinateSystem from multiplying it by a CoordinateSystem and other (argument) CoordinateSystem. In the example below, a new CoordinateSystem is returned that is translated and rotated relative to the CS it was multiplied by and it's argument. Switching the coordinatesystem and other inputs will produce a different result as one is applied after the other."
    },
    {
        "Name": "PreMultiplyBy",
        "imageFile": [
            "PreMultiplyBy"
        ],
        "dynFile": [
            "PreMultiplyBy"
        ],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "PreMultiplyBy will return a new CoordinateSystem from multiplying it by an other (argument) CoordinateSystem and a CoordinateSystem. In the example below, a new CoordinateSystem is returned that is translated and rotated relative to the CoordinateSystem it was multiplied by and it's argument. This node is similar to the PostMultiplyBy node with the only difference being that the other input is applied before the coordinatesystem input."
    },
    {
        "Name": "Rotate (coordinateSystem, origin, degrees)",
        "imageFile": [],
        "dynFile": [],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Add in-depth information about Rotate..."
    },
    {
        "Name": "Rotate (coordinateSystem, origin, axis, degrees)",
        "imageFile": [
            "Rotate (coordinateSystem, origin, axis, degrees)"
        ],
        "dynFile": [
            "Rotate (coordinateSystem, origin, axis, degrees)"
        ],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Rotate (coordinateSystem, origin, axis, degrees) will return a new CoordinateSystem rotated about an origin and vector. In the example below, a CoordinateSystem is rotated about an origin point at (2,0,0) and a vector equivalent to the Y Axis. More complex rotations can be achieved with more complex vectors."
    },
    {
        "Name": "Scale (coordinateSystem, xamount, yamount, zamount)",
        "imageFile": [],
        "dynFile": [],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Add in-depth information about Scale (coordinateSystem, xamount, yamount, zamount)..."
    },
    {
        "Name": "Scale (coordinateSystem, plane, xamount, yamount, zamount)",
        "imageFile": [],
        "dynFile": [],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Add in-depth information about Scale (coordinateSystem, plane, xamount, yamount, zamount)..."
    },
    {
        "Name": "Scale (coordinateSystem, basePoint, from, to)",
        "imageFile": [
            "Scale (coordinateSystem, basePoint, from, to)"
        ],
        "dynFile": [
            "Scale (coordinateSystem, basePoint, from, to)"
        ],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Scale (coordinateSystem, basePoint, from, to) will return a scaled CoordinateSystem based on basePoint, from, and to inputs. The basePoint input will define where the scaling begins from (how much the CoordinateSystem is moved). The distance between the from and to values defines the amount to scale by. In the example below, a basePoint of (0,2,0) defines where to scale from. The distance between the from (1,1,0) and to (4.2,4.2,0) points determines how much to scale by."
    },
    {
        "Name": "Scale (coordinateSystem, amount)",
        "imageFile": [
            "Scale (coordinateSystem, amount)"
        ],
        "dynFile": [
            "Scale (coordinateSystem, amount)"
        ],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Scale (coordinateSystem, amount) will return a new CoordinateSystem scaled by a factor. In the example below, a CoordinateSystem at the origin is scaled by a factor of 3.5. The resulting CoordinateSystem has vector lengths and scale factors of 3.5. Adjust the slider for different scale factors."
    },
    {
        "Name": "Scale1D",
        "imageFile": [],
        "dynFile": [],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Scale1D will return a new Plane "
    },
    {
        "Name": "Scale2D",
        "imageFile": [],
        "dynFile": [],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Add in-depth information about Scale2D..."
    },
    {
        "Name": "ScaleFactor",
        "imageFile": [
            "ScaleFactor"
        ],
        "dynFile": [
            "ScaleFactor"
        ],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "ScaleFactor will return a Vector consisting of the X, Y, and Z scale factors of a CoordinateSystem. In the example below, a scaled CoordinateSystem returns a Vector with X, Y, and Z values of 4.4 and a length of 7.621."
    },
    {
        "Name": "Transform (coordinateSystem, fromCoordinateSystem, contextCoordinateSystem)",
        "imageFile": [
            "Transform (coordinateSystem, fromCoordinateSystem, contextCoordinateSystem)"
        ],
        "dynFile": [
            "Transform (coordinateSystem, fromCoordinateSystem, contextCoordinateSystem)"
        ],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Transform (coordinateSystem, fromCoordinateSystem, contextCoordinateSystem) will return a new CoordinateSystem by transforming a CoordinateSystem from one CS to another CS. In the example below, a CoordinateSystem at the origin is translated from a source CS and rotated by a context CS. Cylinders have been created at the original and new CoordinateSystems to show the transformation."
    },
    {
        "Name": "Transform (coordinateSystem, cs)",
        "imageFile": [
            "Transform (coordinateSystem, cs)"
        ],
        "dynFile": [
            "Transform (coordinateSystem, cs)"
        ],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Transform (coordinateSystem, cs) will return a new CoordinateSystem transformed by two input CoordinateSystems. In the example below, the two input CoordinateSystems result in a new CoordinateSystem even further from the origin. The new CoordinateSystem is identified with a Cylinder created on it."
    },
    {
        "Name": "Translate (coordinateSystem, direction)",
        "imageFile": [
            "Translate (coordinateSystem, direction)"
        ],
        "dynFile": [
            "Translate (coordinateSystem, direction)"
        ],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Translate (coordinateSystem, direction) will return a new CoordinateSystem translated by an input vector. In the example below, a CoordinateSystem at the origin is translated a certain distance and direction as defined by the input Vector of (3.8, 2.7,0). The new CoordinateSystem is identified with a Cylinder created on it."
    },
    {
        "Name": "Translate (coordinateSystem, direction, distance)",
        "imageFile": [
            "Translate (coordinateSystem, direction, distance)"
        ],
        "dynFile": [
            "Translate (coordinateSystem, direction, distance)"
        ],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Translate (coordinateSystem, direction, distance) will return a new CoordinateSystem translated by an input vector and distance. In the example below, a CoordinateSystem at the origin is translated in a direction by the input Vector of (3.1, 4.1,0) and a distance of 3. The distance input will override the vector input's length. The new CoordinateSystem is identified with a Cylinder created on it."
    },
    {
        "Name": "Translate (coordinateSystem, xTranslation, yTranslation, zTranslation)",
        "imageFile": [
            "Translate (coordinateSystem, xTranslation, yTranslation, zTranslation)"
        ],
        "dynFile": [
            "Translate (coordinateSystem, xTranslation, yTranslation, zTranslation)"
        ],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Translate (coordinateSystem, xTranslation, yTranslation, zTranslation) will return a new CoordinateSystem based on translation distances in the X, Y, Z directions. In the example below, a new CoordinateSystem is returned from translation distances of 3.8 in the X, 2.7 in the Y, and 0.8 in the Z. The new CoordinateSystem is identified with a Cylinder created on it."
    },
    {
        "Name": "Determinant",
        "imageFile": [],
        "dynFile": [],
        "folderPath": "Geometry/CoordinateSystem/Query",
        "inDepth": "Add in-depth information about Determinant..."
    },
    {
        "Name": "IsScaledOrtho",
        "imageFile": [],
        "dynFile": [],
        "folderPath": "Geometry/CoordinateSystem/Query",
        "inDepth": "Add in-depth information about IsScaledOrtho..."
    },
    {
        "Name": "IsSingular",
        "imageFile": [],
        "dynFile": [],
        "folderPath": "Geometry/CoordinateSystem/Query",
        "inDepth": "Add in-depth information about IsSingular..."
    },
    {
        "Name": "IsUniscaledOrtho",
        "imageFile": [],
        "dynFile": [],
        "folderPath": "Geometry/CoordinateSystem/Query",
        "inDepth": "Add in-depth information about IsUniscaledOrtho..."
    },
    {
        "Name": "Origin",
        "imageFile": [
            "Origin"
        ],
        "dynFile": [
            "Origin"
        ],
        "folderPath": "Geometry/CoordinateSystem/Query",
        "inDepth": "Origin will return a Point at the origin of a CoordinateSystem. In the example below, the origins of a set of CoordinateSystems are returned as Points. The CoordinateSystems have been placed by spherical coordinates."
    },
    {
        "Name": "XAxis",
        "imageFile": [
            "XAxis"
        ],
        "dynFile": [
            "XAxis"
        ],
        "folderPath": "Geometry/CoordinateSystem/Query",
        "inDepth": "XAxis will return the X Axis of a CoordinateSystem as a Vector. In the example below, the X Axis of a CoordinateSystem is represented as a Line."
    },
    {
        "Name": "XScaleFactor",
        "imageFile": [
            "XScaleFactor"
        ],
        "dynFile": [
            "XScaleFactor"
        ],
        "folderPath": "Geometry/CoordinateSystem/Query",
        "inDepth": "XScaleFactor will return a double representing the scale factor along the X Axis. In the example below, a cylinder is scaled by 2.3, returning an X scale factor of 2.3."
    },
    {
        "Name": "XYPlane",
        "imageFile": [
            "XYPlane"
        ],
        "dynFile": [
            "XYPlane"
        ],
        "folderPath": "Geometry/CoordinateSystem/Query",
        "inDepth": "XYPlane will return a plane on the X and Y axes of a CoordinateSystem. In the example below, a plane is placed on the XY axes of a rotated CoordinateSystem."
    },
    {
        "Name": "YAxis",
        "imageFile": [
            "YAxis"
        ],
        "dynFile": [
            "YAxis"
        ],
        "folderPath": "Geometry/CoordinateSystem/Query",
        "inDepth": "YAxis will return the Y Axis of a CoordinateSystem as a Vector. In the example below, the Y Axis of a CoordinateSystem is represented as a Line."
    },
    {
        "Name": "YScaleFactor",
        "imageFile": [
            "YScaleFactor"
        ],
        "dynFile": [
            "YScaleFactor"
        ],
        "folderPath": "Geometry/CoordinateSystem/Query",
        "inDepth": "YScaleFactor will return a double representing the scale factor along the Y Axis. In the example below, a cylinder is scaled by 2.3, returning an Y scale factor of 2.3."
    },
    {
        "Name": "YZPlane",
        "imageFile": [
            "YZPlane"
        ],
        "dynFile": [
            "YZPlane"
        ],
        "folderPath": "Geometry/CoordinateSystem/Query",
        "inDepth": "YZPlane will return a plane on the Y and Z axes of a CoordinateSystem. In the example below, a plane is placed on the YZ axes of a rotated CoordinateSystem."
    },
    {
        "Name": "ZAxis",
        "imageFile": [
            "ZAxis"
        ],
        "dynFile": [
            "ZAxis"
        ],
        "folderPath": "Geometry/CoordinateSystem/Query",
        "inDepth": "ZAxis will return a Vector that represents the ZAxis of a CoordinateSystem. In the example below, the ZAxis vector of a rotated CoordinateSystem is used to construct a line."
    },
    {
        "Name": "ZScaleFactor",
        "imageFile": [
            "ZScaleFactor"
        ],
        "dynFile": [
            "ZScaleFactor"
        ],
        "folderPath": "Geometry/CoordinateSystem/Query",
        "inDepth": "ZScaleFactor will return a double representing the scale factor along the Z Axis. In the example below, a cylinder is scaled by 2.3, returning an Z scale factor of 2.3."
    },
    {
        "Name": "ZXPlane",
        "imageFile": ["ZXPlane"],
        "dynFile": ["ZXPlane"],
        "folderPath": "Geometry/CoordinateSystem/Query",
        "inDepth": "ZXPlane will return a plane on the Z and X axes of a CoordinateSystem. In the example below, a plane is placed on the ZX axes of a rotated CoordinateSystem."
    },
    {
        "Name": "ByCorners",
        "imageFile": [
            "ByCorners"
        ],
        "dynFile": [
            "ByCorners"
        ],
        "folderPath": "Geometry/Cuboid/Create",
        "inDepth": "Cuboid By Corners creates a cuboid where the two input points are used as the opposite corners of the cuboid. In the example file, two points are randomly generated and used to create a cuboid."
    },
    {
        "Name": "ByLengths (cs, width, length, height)",
        "imageFile": [
            "ByLengths_cs"
        ],
        "dynFile": [
            "ByLengths_cs"
        ],
        "folderPath": "Geometry/Cuboid/Create",
        "inDepth": "This Cuboid By Lengths allows the user to input a Coordinate System. The cuboid will be created at the origin of the input Coordinate System, with the length, width, and heigh oriented according to the Coordinate System. In the example, we use three number sliders to input the length, width, and heigh, and generate random coordinates to use to create a Coordinate System."
    },
    {
        "Name": "ByLengths (origin, width, length, height)",
        "imageFile": [
            "ByLengths_origin"
        ],
        "dynFile": [
            "ByLengths_origin"
        ],
        "folderPath": "Geometry/Cuboid/Create",
        "inDepth": "This Cuboid By Lengths allows the user to input an origin point for the center of the cuboid, as well as the length, width and height of the cuboid. In the example file, we use three number sliders to input the length, width, and height, and generate a random point to use as the origin."
    },
    {
        "Name": "ByLengths (width, length, height)",
        "imageFile": [
            "ByLengths"
        ],
        "dynFile": [
            "ByLengths"
        ],
        "folderPath": "Geometry/Cuboid/Create",
        "inDepth": "Cuboid By Lengths creates a cuboid with the input width, legth, and height, and is centered at the origin. In the example, we use three number sliders to input the length, width and height."
    },
    {
        "Name": "Height",
        "imageFile": [
            "Height"
        ],
        "dynFile": [
            "Height"
        ],
        "folderPath": "Geometry/Cuboid/Query",
        "inDepth": "This returns the height of the input cuboid. In the example, we generate a cuboid by corners, and then use a Height query to find the height. Note that if the cuboid has been transformed to a different coordinate system with a scale factor, this will return the orignal dimension of the cuboid, not the world space dimensions."
    },
    {
        "Name": "Length",
        "imageFile": [
            "Length"
        ],
        "dynFile": [
            "Length"
        ],
        "folderPath": "Geometry/Cuboid/Query",
        "inDepth": "This returns the Length of the input cuboid. In the example, we generate a cuboid by corners, and then use a Length query to find the height.  Note that if the cuboid has been transformed to a different coordinate system with a scale factor, this will return the orignal dimension of the cuboid, not the world space dimensions."
    },
    {
        "Name": "Width",
        "imageFile": [
            "Width"
        ],
        "dynFile": [
            "Width"
        ],
        "folderPath": "Geometry/Cuboid/Query",
        "inDepth": "This returns the width of the input cuboid. In the example, we generate a cuboid by corners, and then use a Width query to find the height. Note that if the cuboid has been transformed to a different coordinate system with a scale factor, this will return the orignal dimension of the cuboid, not the world space dimensions."
    },
    {
        "Name": "ByBlendBetweenCurves",
        "imageFile": [
            "ByBlendBetweenCurves"
        ],
        "dynFile": [
            "ByBlendBetweenCurves"
        ],
        "folderPath": "Geometry/Curve/Create",
        "inDepth": "Curve by Blend Between Curves will create a new curve that connects two input curves. The two 'endOrStart' inputs determine whether to connect the end or start points of each curve. The created curve will match the curvature of the original curves at the connection points. In the example below, we start with one arc and one line. We blend between the start of the arch and the end of the line to connect the two curves. Two boolean toggle nodes let us control which ends of the two curves to blend between."
    },
    {
        "Name": "ByIsoCurveOnSurface",
        "imageFile": [
            "ByIsoCurveOnSurface"
        ],
        "dynFile": [
            "ByIsoCurveOnSurface"
        ],
        "folderPath": "Geometry/Curve/Create",
        "inDepth": "Curve by IsoCurve on Surface will create a curve that is the isocurve on a surface by specifying the U or V direction, and specifying the parameter in the opposite direction at which to create the curve. The 'direction' input determines which direction of isocurve to create. A value of one corresponds to the u-direction, while a value of zero corresponds to the v-direction. In the example below, we first create grid of points, and translate them in the Z-direction by a random amount. These points are used to create surface by using a NurbsSurface.ByPoints node. This surface is used as the baseSurface of a ByIsoCurveOnSurface node. A number slider set to a range of 0 to 1 and a step of 1 is used to control whether we extract the isocurve in the u or in the v direction. A second number slider is used to determine the parameter at which the isocurve is extracted."
    },
    {
        "Name": "ByParameterLineOnSurface",
        "imageFile": [
            "ByParameterLineOnSurface"
        ],
        "dynFile": [
            "ByParameterLineOnSurface"
        ],
        "folderPath": "Geometry/Curve/Create",
        "inDepth": "Curve by Parameter Line On Surface will create a line along a surface between two input UV coordinates. n the example below, we first create grid of points, and translate them in the Z-direction by a random amount. These points are used to create surface by using a NurbsSurface.ByPoints node. This surface is used as the baseSurface of a ByParameterLineOnSurface node. A set of number sliders are used to adjust the U and V inputs of two UV.ByCoordinates nodes, which are then used to determing the start and end point of the line on the surface."
    },
    {
        "Name": "ApproximateWithArcAndLineSegments",
        "imageFile": [
            "ApproximateWithArcAndLineSegments"
        ],
        "dynFile": [
            "ApproximateWithArcAndLineSegments"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Approximate with Arc and Line Segments takes a curve as input, and returns a list of straight line and arc curves that approximate the original curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. This curve is then used as the input for an ApproximateWithArcAndLineSegments node."
    },
    {
        "Name": "CoordinateSystemAtParameter",
        "imageFile": [
            "CoordinateSystemAtParameter"
        ],
        "dynFile": [
            "CoordinateSystemAtParameter"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Coordinate System At Parameter will return a coordinate system aligned with the input curve at the specified parameter. The parameterization of a curve is measured in the range from zero to one, with zero representing the start of the curve and one representing the end of the curve. The resulting coordinate system will have its x-axis in the direction of the normal of the curve and the y-axis in the direction of the tangent of the curve at the specified parameter. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider set to the range 0 to 1 is used to control the parameter input for a CoordinateSystemAtParameter node."
    },
    {
        "Name": "CoordinateSystemAtSegmentLength",
        "imageFile": [
            "CoordinateSystemAtSegmentLength"
        ],
        "dynFile": [
            "CoordinateSystemAtSegmentLength"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Coordinate System At Segment Length will return a coordinate system aligned with the input curve at the specified curve length, measured from the start point of the curve. The resulting coordinate system will have its x-axis in the direction of the normal of the curve and the y-axis in the direction of the tangent of the curve at the specified length. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider is used to control the segment length input for a CoordinateSystemAtParameter node. If the specified length is longer than the length of the curve, this node will return a Coordinate System at the end point of the curve."
    },
    {
        "Name": "EndParameter",
        "imageFile": [
            "EndParameter"
        ],
        "dynFile": [
            "EndParameter"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "End Parameter will return a number that represents the end of the domain in which the input curve can be evaluated. In most cases the end parameter will be one. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. This curve is then used as the input to an EndParameter node. "
    },
    {
        "Name": "Extend",
        "imageFile": [
            "Extend"
        ],
        "dynFile": [
            "Extend"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Extend will extend a input curve by a given input distance. The pickSide input takes the start or end point of the curve as input, and determines which end of the curve to extend. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. We use the query node Curve.EndPoint to find the end point of the curve, to use as the 'pickSide' input. A number slider allows us to control the distance of the extension."
    },
    {
        "Name": "ExtendEnd",
        "imageFile": [
            "ExtendEnd"
        ],
        "dynFile": [
            "ExtendEnd"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Extend End will extend a input curve by a given input distance, starting from the end point of the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider allows us to control the distance of the extension."
    },
    {
        "Name": "ExtendStart",
        "imageFile": [
            "ExtendStart"
        ],
        "dynFile": [
            "ExtendStart"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Extend Start will extend a input curve by a given input distance, starting from the start point of the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider allows us to control the distance of the extension."
    },
    {
        "Name": "Extrude (curve, distance)",
        "imageFile": [
            "Extrude_distance"
        ],
        "dynFile": [
            "Extrude_distance"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Extrude by distance will extrude an input curve using an input number to determine the distance of the extrusion. The direction of the normal vector along the curve will be used for the extrusion direction. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider is used as the distance input in an Extrude node."
    },
    {
        "Name": "Extrude (curve, direction)",
        "imageFile": [
            "Extrude_direction"
        ],
        "dynFile": [
            "Extrude_direction"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Extrude by direction will extrude an input curve using an input vector to determine the direction of the extrusion. The length of the vector will be used for the extrusion distance. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A Code Block is used to specify the x,y, and z components of a Vector.ByCoordinates node. This vector is then used as the direction input in an Extrude node."
    },
    {
        "Name": "Extrude (curve, direction, distance)",
        "imageFile": [
            "Extrude_direction_distance"
        ],
        "dynFile": [
            "Extrude_direction_distance"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Extrude by direction and distance will extrude an input curve using an input vector to determine the direction of the extrusion. A separate distance input will be used for the extrusion distance. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A Code Block is used to specify the x,y, and z components of a Vector.ByCoordinates node. This vector is then used as the direction input in an Extrude node while a number slider is used to control the distance input."
    },
    {
        "Name": "ExtrudeAsSolid (curve, distance)",
        "imageFile": [
            "ExtrudeAsSolid_distance"
        ],
        "dynFile": [
            "ExtrudeAsSolid_distance"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Extrude As Solid by distance will extrude an input closed, planar curve using an input number to determine the distance of the extrusion. The direction of the extrusion is determined by the normal vector of the plane the curve lies in. This node will cap the the ends of the extrusion to create a solid. In the example below, we first create a Nurbs Curve using a ByPoints node, with a set of randomly generated points as the input. A Number Slider is used as the distance input in an ExtrudeAsSolid node."
    },
    {
        "Name": "ExtrudeAsSolid (curve, direction)",
        "imageFile": [
            "ExtrudeAsSolid_direction"
        ],
        "dynFile": [
            "ExtrudeAsSolid_direction"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Extrude As Solid by direction will extrude an input closed, planar curve using an input vector to determine the direction of the extrusion. The length of the vector will be used for the extrusion distance. This node will cap the the ends of the extrusion to create a solid. In the example below, we first create a Nurbs Curve using a ByPoints node, with a set of randomly generated points as the input. A Code Block is used to specify the x,y, and z components of a Vector.ByCoordinates node. This vector is then used as the direction input in an ExtrudeAsSolid node."
    },
    {
        "Name": "ExtrudeAsSolid (curve, direction, distance)",
        "imageFile": [
            "ExtrudeAsSolid_direction_distance"
        ],
        "dynFile": [
            "ExtrudeAsSolid_direction_distance"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Extrude As Solid by direction and distance will extrude an input closed, planar curve using an input vector to determine the direction of the extrusion. A separate distance input will be used for the extrusion distance. This node will cap the the ends of the extrusion to create a solid. In the example below, we first create a Nurbs Curve using a ByPoints node, with a set of randomly generated points as the input. A Code Block is used to specify the x,y, and z components of a Vector.ByCoordinates node. This vector is then used as the direction input in an ExtrudeAsSolid node while a number slider is used to control the distance input."
    },
    {
        "Name": "HorizontalFrameAtParameter",
        "imageFile": [
            "HorizontalFrameAtParameter"
        ],
        "dynFile": [
            "HorizontalFrameAtParameter"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Horizontal Frame At Parameter will return a coordinate system aligned with the input curve at the specified parameter. The parameterization of a curve is measured in the range from zero to one, with zero representing the start of the curve and one representing the end of the curve. The resulting coordinate system will have its z-axis in the world Z direction, and the y-axis in the direction of the tangent of the curve at the specified parameter. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider set to the range 0 to 1 is used to control the parameter input for a HorizontalFrameAtParameter node."
    },
    {
        "Name": "Join (curve, curves)",
        "imageFile": [
            "Join_curves"
        ],
        "dynFile": [
            "Join_curves"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Join will take one input curve and one list of input curves, and will return a PolyCurve that results from joining the curves together.  In the example below, we start with one arc and one line. We blend between the start of the arch and the end of the line to connect the two curves. The arc and line are put into a single list by using a List.Create node. This list is then used as the input along with the blended curve in a Join node to create a single PolyCurve out of the three curves."
    },
    {
        "Name": "Join (curve, curve)",
        "imageFile": [
            "Join_curve"
        ],
        "dynFile": [
            "Join_curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Join will take two curves as input and return a PolyCurve that results from joining the two curves together.  In the example below, we start with one arc and one line. We blend between the start of the arch and the end of the line to connect the two curves. The Arc and the resulting blended curve are then joined into a PolyCurve using a Join node."
    },
    {
        "Name": "NormalAtParameter",
        "imageFile": [
            "NormalAtParameter"
        ],
        "dynFile": [
            "NormalAtParameter"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Normal At Parameter will return a vector aligned with the normal direction at the specified parameter of a curve. The parameterization of a curve is measured in the range from zero to one, with zero representing the start of the curve and one representing the end of the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider set to the range 0 to 1 is used to control the parameter input for a NormalAtParameter node."
    },
    {
        "Name": "Offset",
        "imageFile": [
            "Offset"
        ],
        "dynFile": [
            "Offset"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Offset will create a new curve offset by a specified distance from an input curve. The input curve must be planar. A negative direction will produce an offset on the opposite side of the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider set to the range 0 to 1 is used to control the parameter input for an Offset node."
    },
    {
        "Name": "ParameterAtChordLength",
        "imageFile": [
            "ParameterAtChordLength"
        ],
        "dynFile": [
            "ParameterAtChordLength"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Parameter At Chord Length will return the parameter of a point that is a given chord length from an initial specified parameter. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider is used to control the straight-line chord distance to find a parameter at. A second number slider set to the range 0 to 1 is used to control the initial point along the curve from which the chord distance will be measured. Finally, a boolean toggle is used to determine which direction to measure the chord distance from."
    },
    {
        "Name": "ParameterAtPoint",
        "imageFile": [
            "ParameterAtPoint"
        ],
        "dynFile": [
            "ParameterAtPoint"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Parameter at Point will return the parameter value of a specified point along a curve. If the input point is not on the curve, Parameter At Point will return the parameter of the point on the curve closes to the input point. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. An extra single point is created with a Code Block to specify the x and y coordinates. The ParameterAtPoint node returns the parameter along the curve at the point that is closest to the input point."
    },
    {
        "Name": "ParameterAtSegmentLength",
        "imageFile": [
            "ParameterAtSegmentLength"
        ],
        "dynFile": [
            "ParameterAtSegmentLength"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Parameter At Segment Length will return the parameter of a point that is a given length along the curve from the start point. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider is used to control the segment length to find a parameter at. If the input segment length is longer than the curve, this node will return the parameter value of the end point of the curve."
    },
    {
        "Name": "Patch",
        "imageFile": [
            "Patch"
        ],
        "dynFile": [
            "Patch"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Patch will attempt to create a surface using an input curve as the boundary. The input curve must be closed. In the example below, we first use a Point.ByCylindricalCoordinates node to create a set of points at set intervals in a circle, but with random elevations and radii. We then use a NurbsCurve.ByPoints node to create a closed curve based on these points. A Patch node is cused to create a surface from the boundary closed curve. Note that because the points were created with random radii and elevations, not all arrangements result in a curve that is able to be patched."
    },
    {
        "Name": "PlaneAtParameter",
        "imageFile": [
            "PlaneAtParameter"
        ],
        "dynFile": [
            "PlaneAtParameter"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Plane At Parameter will return a plane aligned with a curve at a specified parameter. The normal vector of the resulting plane will correspond to the tangent of the curve. The parameterization of a curve is measured in the range from zero to one, with zero representing the start of the curve and one representing the end of the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider set to the range 0 to 1 is used to control the parameter input for a PlaneAtParameter node."
    },
    {
        "Name": "PlaneAtSegmentLength",
        "imageFile": [
            "PlaneAtSegmentLength"
        ],
        "dynFile": [
            "PlaneAtSegmentLength"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Plane At Segment Length will return a plane aligned with a curve at a point that is a specified distance along the curve, measured from the start point. If the input length is greater than the total length of the curve, this node will use the end point of the curve. The normal vector of the resulting plane will correspond to the tangent of the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider is used to control the parameter input for a PlaneAtSegmentLength node."
    },
    {
        "Name": "PointAtChordLength",
        "imageFile": [
            "PointAtChordLength"
        ],
        "dynFile": [
            "PointAtChordLength"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Point At Chord Length will return the point that is a given chord length from an initial specified parameter. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider is used to control the straight-line chord distance to find a point at. A second number slider set to the range 0 to 1 is used to control the initial point along the curve from which the chord distance will be measured. Finally, a boolean toggle is used to determine which direction to measure the chord distance from."
    },
    {
        "Name": "PointAtParameter",
        "imageFile": [
            "PointAtParameter"
        ],
        "dynFile": [
            "PointAtParameter"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Point At Parameter will return a point at a given parameter along an input curve. The parameterization of a curve is bounded between zero and one, where the start of the curve has a parameter of zero, and the end of the curve has a parameter of one. In the example below, we use two sets of random numbers to generate a list of points. These points are used to create a Nurbs Curve by Control Points. A number slider is set to the range of zero to one, and used as the input parameter to a Point At Parameter node."
    },
    {
        "Name": "PointAtSegmentLength",
        "imageFile": [
            "PointAtSegmentLength"
        ],
        "dynFile": [
            "PointAtSegmentLength"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Point At Segment Length will return the point on a curve at a given length along the curve, measured from the start point of the curve. If the input length is greater than the length of the curve, the node will return the end point of the curve. In the example below, we use two sets of random numbers to generate a list of points. These points are used to create a Nurbs Curve by Control Points. A number slider is and used as the input length to a Point At Segment Length node. "
    },
    {
        "Name": "PointsAtChordLengthFromPoint",
        "imageFile": [
            "PointsAtChordLengthFromPoint"
        ],
        "dynFile": [
            "PointsAtChordLengthFromPoint"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Points At Chord Length From Point will return a list of points along a curve, measured sequentially according to an input chord length starting from a specified point along the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A PointAtParameter node is used with a number slider set to the range 0 to 1 to determine the initial point along the curve for a PointsAtChordLengthFromPoint node. Finally, a second number slider is used to adjust the straight-line chord length to use."
    },
    {
        "Name": "PointsAtEqualChordLength",
        "imageFile": [
            "PointsAtEqualChordLength"
        ],
        "dynFile": [
            "PointsAtEqualChordLength"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Points At Equal Chord Length will return a list of points along an input curve by dividing the curve into equal straight-line chord lengths. The number of divisions to use is input as an integer, and will result in that number of points divided equally in the interior of the curve. This node will not include the end points of the curve. In the example below, we use two sets of random numbers to generate a list of points. These points are used to create a Nurbs Curve by Control Points. An integer slider is used for the divisions input in a PointsAtEqualChordLength node."
    },
    {
        "Name": "PointsAtEqualSegmentLength",
        "imageFile": [
            "PointsAtEqualSegmentLength"
        ],
        "dynFile": [
            "PointsAtEqualSegmentLength"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Points At Equal Segment Length will return a list of points along an input curve by dividing the curve into equal length segments. The number of divisions to use is input as an integer, and will result in that number of points divided equally in the interior of the curve. This node will not include the end points of the curve. In the example below, we use two sets of random numbers to generate a list of points. These points are used to create a Nurbs Curve by Control Points. An integer slider is used for the divisions input in a PointsAtEqualSegmentLength node."
    },
    {
        "Name": "PointsAtSegmentLengthFromPoint",
        "imageFile": [
            "PointsAtSegmentLengthFromPoint"
        ],
        "dynFile": [
            "PointsAtSegmentLengthFromPoint"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Points At Segment Length From Point will return a list of points along a curve, measured sequentially according to an input segment length starting from a specified point along the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A PointAtParameter node is used with a number slider set to the range 0 to 1 to determine the initial point along the curve for a PointsAtSegmentLengthFromPoint node. Finally, a second number slider is used to adjust the curve segment length to use"
    },
    {
        "Name": "Project",
        "imageFile": [
            "Project"
        ],
        "dynFile": [
            "Project"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Project will project an input curve along a given projection direction onto a specified baseGeometry. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A sphere is created with a default radius of 1, and using a Code Block to specify the coordinates of the centerPoint. We use the world Y-axis as the direction vector for projection in a Project node. The output is a curve that results from the original curve being projected in the Y direction onto the sphere."
    },
    {
        "Name": "PullOntoPlane",
        "imageFile": [
            "PullOntoPlane"
        ],
        "dynFile": [
            "PullOntoPlane"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Pull Onto Plane will create a new curve by projecting an input curve onto an input plane, using the normal of the plane as the direction of projection. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. We use the world XY plane as the plane to project onto in a PullOntoPlane node. The result is a planar curve on the XY plane."
    },
    {
        "Name": "PullOntoSurface",
        "imageFile": [
            "PullOntoSurface"
        ],
        "dynFile": [
            "PullOntoSurface"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Pull Onto Surface will create a new curve by projecting an input curve onto an input surface, using the normal vectors of the surface as the directions of projection. In the example below, we first create surface by using a Surface.BySweep node that uses curves generated according to a sine curve. This surface is used as the base surface to pull onto in a PullOntoSurface node. For the curve, we create a circle by using a Code Block to specify the coordinates of the center point, and a number slider to control the radius of the circle. The result is a projection of the cirle onto the surface. "
    },
    {
        "Name": "Reverse",
        "imageFile": [
            "Reverse"
        ],
        "dynFile": [
            "Reverse"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Reverse will reverse the inherent direction of a given curve. This will switch the start point and end point of the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. We then use a Reverse node to change the direction of the curve."
    },
    {
        "Name": "SegmentLengthAtParameter",
        "imageFile": [
            "SegmentLengthAtParameter"
        ],
        "dynFile": [
            "SegmentLengthAtParameter"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Segment Length At Parameter will return the length of a curve between the start point and the input parameter, where zero is the parameter at the beginning of the curve, and one is the parameter at the end of the curve. In the example below, we use two sets of random numbers to generate a list of points. These points are used to create a Nurbs Curve by Control Points. A number slider set to the range zero to one is used for the parameter input in a SegmentLengthAtParameter node."
    },
    {
        "Name": "SegmentLengthBetweenParameters",
        "imageFile": [
            "SegmentLengthBetweenParameters"
        ],
        "dynFile": [
            "SegmentLengthBetweenParameters"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Segment Length Between Parameters will return the length of a curve between the input start parameter and the input end parameter, where a value of zero is the parameter at the beginning of the curve and a value of one is the parameter at the end of the curve. In the example below, we use two sets of random numbers to generate a list of points. These points are used to create a Nurbs Curve by Control Points. Two number sliders set to the range zero to one is used for the parameter inputs in a SegmentLengthBetweenParameters node."
    },
    {
        "Name": "Simplify",
        "imageFile": ["Simplify"],
        "dynFile": ["Simplify"],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Add in-depth information about Simplify..."
    },
    {
        "Name": "SplitByParameter (curve, parameter)",
        "imageFile": [
            "SplitByParameter"
        ],
        "dynFile": [
            "SplitByParameter"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Split By Parameter (curve, parameter) will take a curve and a single parameter as input. It will split the curve at the specified parameter, and return the two resulting curves as a list. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider set to the range of 0 to 1 is used to adjust the parameter to split the curve at."
    },
    {
        "Name": "SplitByParameter (curve, parameters)",
        "imageFile": [
            "SplitByParameters"
        ],
        "dynFile": [
            "SplitByParameters"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Split By Parameter (curve, parameters) will take a curve and a list of parameters as input. It will split the curve at the specified parameters, and return a list of resulting curves. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A Code Block is used to create a series of numbers between 0 and 1 to use as the list of parameters to split the cure at."
    },
    {
        "Name": "SplitByPoints",
        "imageFile": [
            "SplitByPoints"
        ],
        "dynFile": [
            "SplitByPoints"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Split By Points will split an input curve at specified points, and will return a list of resulting segments. If the specified points are not on the curve, this node will find the points along the curve that are closest to the input points and split the curve at those resulting points. In the example below, we first create a Nurbs Curve using a ByPoints node, with a set of randomly generated points as the input. The same set of points is used as the list of points in a SplitByPoints node. The result is a list of curve segments between the generated points."
    },
    {
        "Name": "StartParameter",
        "imageFile": [
            "StartParameter"
        ],
        "dynFile": [
            "StartParameter"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Start Parameter will return a number that represents the start of the domain in which the input curve can be evaluated. In most cases the start parameter will be zero. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. This curve is then used as the input to an StartParameter node."
    },
    {
        "Name": "SweepAsSolid",
        "imageFile": [
            "SweepAsSolid"
        ],
        "dynFile": [
            "SweepAsSolid"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Sweep As Solid will create a solid by sweeping an input closed profile curve along a specified path. In the example below, we use a rectangle as the base profile curve. The path is created by using a cosine function with a sequence of angles to vary the x-coordinates of a set of points. The points are used as the input to a NurbsCurve.ByPoints node. We then create a solid by sweeping the rectangle along the created cosine curve."
    },
    {
        "Name": "SweepAsSurface",
        "imageFile": [
            "SweepAsSurface"
        ],
        "dynFile": [
            "SweepAsSurface"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "SweepAsSurface will create a surface by sweeping an input curve along a specfied path. In the example below, we create a curve to sweep by useing a Code Block to create three points of an Arc.ByThreePoints node. A path curve is created a simple line along the x-axis. SweepAsSurface moves the profile curve along the path curve creating a surface."
    },
    {
        "Name": "TangentAtParameter",
        "imageFile": [
            "TangentAtParameter"
        ],
        "dynFile": [
            "TangentAtParameter"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Tangent At Parameter will return a vector aligned with the tangent direction at the specified parameter of a curve. The parameterization of a curve is measured in the range from zero to one, with zero representing the start of the curve and one representing the end of the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider set to the range 0 to 1 is used to control the parameter input for a TangentAtParameter node."
    },
    {
        "Name": "ToNurbsCurve",
        "imageFile": [
            "ToNurbsCurve"
        ],
        "dynFile": [
            "ToNurbsCurve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "To Nurbs Curve takes a curve as input, and returns a Nurbs curve that approximates the input curve. In the example below, we create an arc by using a Code Block to define three points and using an Arc.ByThreePoints node. This arc is converted to a Nurbs Curve by using a ToNurbsCurve node. Note that the default degree of the resulting Nurbs Curve is 3."
    },
    {
        "Name": "TrimByEndParameter",
        "imageFile": [
            "TrimByEndParameter"
        ],
        "dynFile": [
            "TrimByEndParameter"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Trim By End Parameter will remove the end of an input curve by trimming the curve at the specified parameter. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider set to the range 0 to 1 is used to control the parameter input for a TrimByEndParameter node."
    },
    {
        "Name": "TrimByParameter",
        "imageFile": [
            "TrimByParameter"
        ],
        "dynFile": [
            "TrimByParameter"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Trim By Parameter will remove the start and end of an input curve by trimming the curve at the specified parameters, and will return the resulting middle section of the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. Two number sliders set to the range 0 to 1 are used to control the start and end parameter inputs for a TrimByParameter node."
    },
    {
        "Name": "TrimByStartParameter",
        "imageFile": [
            "TrimByStartParameter"
        ],
        "dynFile": [
            "TrimByStartParameter"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Trim By Start Parameter will remove the beginning of an input curve by trimming the curve at the specified parameter. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider set to the range 0 to 1 is used to control the parameter input for a TrimByStartParameter node."
    },
    {
        "Name": "TrimInteriorByParameter",
        "imageFile": [
            "TrimInteriorByParameter"
        ],
        "dynFile": [
            "TrimInteriorByParameter"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Trim Interior By Parameter will remove the interior portion of a given curve, based on the two input parameters. This node will output the two remaining exterior parts of the curve as a list of two curves.  In the example below, we use two sets of random numbers to generate a list of points. These points are used to create a Nurbs Curve by Control Points. Two number sliders set to the range zero to one is used for the parameter inputs in a TrimInteriorByParameter node."
    },
    {
        "Name": "TrimSegmentsByParameter (curve, parameters, discardEvenSegments)",
        "imageFile": [
            "TrimSegmentsByParameter_even"
        ],
        "dynFile": [
            "TrimSegmentsByParameter_even"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Trim Segments By Parameter, with discardEvenSegments first splits a curve at points determined by an input list of parameters. It then returns either the odd numbered segments or the even numbered sugements, as determined by the boolean value of the discardEvenSegments input. In the example below,  we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A Code Block is used to create a range of number between zero and one, stepping by 0.1. Using this as the input parameters for a TrimSegmentsByParameter node results in a list of curve that are effectively a dashed line version of the original curve."
    },
    {
        "Name": "TrimSegmentsByParameter (curve, parameters)",
        "imageFile": [
            "TrimSegmentsByParameter"
        ],
        "dynFile": [
            "TrimSegmentsByParameter"
        ],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Trim Segments By Parameter first splits a curve at points determined by an input list of parameters. It then returns only the even numbered segments that result from the split. In the example below,  we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A Code Block is used to create a range of number between zero and one, stepping by 0.1. Using this as the input parameters for a TrimSegmentsByParameter node results in a list of curve that are effectively a dashed line version of the original curve."
    },
    {
        "Name": "EndPoint",
        "imageFile": [
            "EndPoint"
        ],
        "dynFile": [
            "EndPoint"
        ],
        "folderPath": "Geometry/Curve/Query",
        "inDepth": "End Point will return the end point of an input curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. We can find the end point of this curve by using an EndPoint node."
    },
    {
        "Name": "IsClosed",
        "imageFile": [
            "IsClosed"
        ],
        "dynFile": [
            "IsClosed"
        ],
        "folderPath": "Geometry/Curve/Query",
        "inDepth": "Is Closed will return a boolean value that corresponds to whether the input curve is closed or not. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. We can then test whether this curve is closed by using a IsClosed node. "
    },
    {
        "Name": "IsPlanar",
        "imageFile": [
            "IsPlanar"
        ],
        "dynFile": [
            "IsPlanar"
        ],
        "folderPath": "Geometry/Curve/Query",
        "inDepth": "Is Planar will return a boolean value that corresponds to whether the input curve is planar or not. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. We can then test whether this curve is planar by using a IsPlanar node."
    },
    {
        "Name": "Length",
        "imageFile": [
            "Length"
        ],
        "dynFile": [
            "Length"
        ],
        "folderPath": "Geometry/Curve/Query",
        "inDepth": "Length will return the length of an input curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. We can find the length of this curve by using an Length node."
    },
    {
        "Name": "Normal",
        "imageFile": [
            "Normal"
        ],
        "dynFile": [
            "Normal"
        ],
        "folderPath": "Geometry/Curve/Query",
        "inDepth": "Normal will return the normal vector of an input curve. The curve must be planar for this node. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. We can find the normal of this curve by using a Normal node."
    },
    {
        "Name": "StartPoint",
        "imageFile": [
            "StartPoint"
        ],
        "dynFile": [
            "StartPoint"
        ],
        "folderPath": "Geometry/Curve/Query",
        "inDepth": "Start Point will return the start point of an input curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. We can find the start point of this curve by using a StartPoint node."
    },
    {
        "Name": "ByPointsRadius",
        "imageFile": [
            "ByPointsRadius"
        ],
        "dynFile": [
            "ByPointsRadius"
        ],
        "folderPath": "Geometry/Cylinder/Create",
        "inDepth": "ByPointsRadius will return a Cylinder from a start Point, end Point, and radius value. In the example below, adjusting the number sliders will change the point positions as well as the Cylinder's radius."
    },
    {
        "Name": "ByRadiusHeight",
        "imageFile": [
            "ByRadiusHeight"
        ],
        "dynFile": [
            "ByRadiusHeight"
        ],
        "folderPath": "Geometry/Cylinder/Create",
        "inDepth": "ByRadiusHeight will return a Cylinder based on a CoordinateSystem. In the example below, a CoordinateSystem from an origin point and a YAxis vector is used to create Cylinder that appears rotated."
    },
    {
        "Name": "Radius",
        "imageFile": [
            "Radius"
        ],
        "dynFile": [
            "Radius"
        ],
        "folderPath": "Geometry/Cylinder/Query",
        "inDepth": "Radius will return the radius of a Cylinder as a double. In the example below, adjusting the number slider will change the Cylinder's radius."
    },
    {
        "Name": "AdjacentFaces",
        "imageFile": [
            "AdjacentFaces"
        ],
        "dynFile": [
            "AdjacentFaces"
        ],
        "folderPath": "Geometry/Edge/Query",
        "inDepth": "AdjacentFaces will return the Faces adjacent to an input Edge. In the example below, an edge on a solid is identified as having two adjacent faces. The edges are gathered from the solid using Topology.Edges."
    },
    {
        "Name": "CurveGeometry",
        "imageFile": [
            "CurveGeometry"
        ],
        "dynFile": [
            "CurveGeometry"
        ],
        "folderPath": "Geometry/Edge/Query",
        "inDepth": "CurveGeometry will return an Edge as a Curve. In the example below, an identified Edge is represented as a Curve."
    },
    {
        "Name": "EndVertex",
        "imageFile": [
            "EndVertex"
        ],
        "dynFile": [
            "EndVertex"
        ],
        "folderPath": "Geometry/Edge/Query",
        "inDepth": "EndVertex will return the Vertex at the end of an Edge. In the example below, an end Vertex is represented as a Point."
    },
    {
        "Name": "StartVertex",
        "imageFile": [
            "StartVertex"
        ],
        "dynFile": [
            "StartVertex"
        ],
        "folderPath": "Geometry/Edge/Query",
        "inDepth": "StartVertex will return the Vertex at the start of an Edge. In the example below, a start Vertex is represented as a Point."
    },
    {
        "Name": "ByCoordinateSystemRadii",
        "imageFile": [
            "ByCoordinateSystemRadii"
        ],
        "dynFile": [
            "ByCoordinateSystemRadii"
        ],
        "folderPath": "Geometry/Ellipse/Create",
        "inDepth": "Ellipse by Coordinate System Radii takes a coordinate system as an input, then creates an ellipse using the inputted radii. The input xAxisRadius and yAxisRadius correspond to the X and Y directions of the input Coordinate System (not the World X and Y directions). In the example file, we generate two random values to create a Coordinate System, then use that Coordinate System with two number sliders for the x and y radii."
    },
    {
        "Name": "ByOriginRadii",
        "imageFile": [
            "ByOriginRadii"
        ],
        "dynFile": [
            "ByOriginRadii"
        ],
        "folderPath": "Geometry/Ellipse/Create",
        "inDepth": "Ellipse by Origin Radii creates an ellipse centered on the input Origin point, and has an x and y radius from the input xAxisRadius and yAxisRadius. This ellipse will be aligned with the World XY plane. In the example below, we generate two random numbers to create an origin point, then use two number sliders for the x and y axis radii."
    },
    {
        "Name": "ByOriginVectors",
        "imageFile": [
            "ByOriginVectors"
        ],
        "dynFile": [
            "ByOriginVectors"
        ],
        "folderPath": "Geometry/Ellipse/Create",
        "inDepth": "Ellipse by Origin Vectors creates an ellipse centered on the input origin points. In this case, the XAxisRadius and YAxisRadius require vectors as inputs. The two vectors must be orthogonal (at right angles) to each other. The two vectors will determine the plane of the ellipse. They need not be in the world X and Y directions. In the example, we first create an origin point by generating two random numbers. We then use a unit X and unit Y vector, which are then scaled by number sliders."
    },
    {
        "Name": "ByPlaneRadii",
        "imageFile": [
            "ByPlaneRadii"
        ],
        "dynFile": [
            "ByPlaneRadii"
        ],
        "folderPath": "Geometry/Ellipse/Create",
        "inDepth": "Ellipse by Plane Radii creates an ellipse centered at the input plane. The xAxisRadius and yAxisRadius take numbers as inputs, and correspond to the X and Y diretions of the input plane, which may be different from world X and Y directions. In the example below, we use a YZ plane as the input, then use two number sliders for the xAxisRadius and yAxisRadius. Because we used a YZ plane, the input xAxisRadius will correspond to the world Y direction, while the yAxisRadius will correspond to the world Z direction."
    },
    {
        "Name": "CenterPoint",
        "imageFile": [
            "CenterPoint"
        ],
        "dynFile": [
            "CenterPoint"
        ],
        "folderPath": "Geometry/Ellipse/Query",
        "inDepth": "Center Point will return the center point of an input ellipse. Note that this point does not contain any information about the orientation or plane of the ellipse. In the example below, we first create an ellipse by Plane Radii, then find the center point."
    },
    {
        "Name": "MajorAxis",
        "imageFile": [
            "MajorAxis"
        ],
        "dynFile": [
            "MajorAxis"
        ],
        "folderPath": "Geometry/Ellipse/Query",
        "inDepth": "Major Axis will return the longer of the two axes of the ellipse. The axis is output as a vector, which has a magnitude equal to the larger of the two radii. Note that Major and Minor axes are determined by length, not by direction. That is, the major axis might correspond to the xAxisRadius of one ellipse, but the yAxisRadius of a different ellipse."
    },
    {
        "Name": "MinorAxis",
        "imageFile": [
            "MinorAxis"
        ],
        "dynFile": [
            "MinorAxis"
        ],
        "folderPath": "Geometry/Ellipse/Query",
        "inDepth": "Minor Axis will return the shorter of the two axes of the ellipse. The axis is output as a vector, which has a magnitude equal to the shorter of the two radii. Note that Major and Minor axes are determined by length, not by direction. That is, the minor axis might correspond to the xAxisRadius of one ellipse, but the yAxisRadius of a different ellipse."
    },
    {
        "Name": "ByPlaneRadiiAngles",
        "imageFile": [
            "ByPlaneRadiiAngles"
        ],
        "dynFile": [
            "ByPlaneRadiiAngles"
        ],
        "folderPath": "Geometry/EllipseArc/Create",
        "inDepth": "Ellipse Arc by Plane Radii Angles creates a portion of an ellipse. The input xRadius and yRadius give the radii of the ellipse along the X and Y directions of the input plane (which may be different than world X and Y). The startAngle input defines the beginning point of the arc along the ellipse in degrees, starting counter-clockwise from the plane X-axis, and continuing for a total arc length of the sweepAngle input. In the example below, we use the XY plane, and a series of number sliders to control the other input parameters."
    },
    {
        "Name": "CenterPoint",
        "imageFile": [
            "CenterPoint"
        ],
        "dynFile": [
            "CenterPoint"
        ],
        "folderPath": "Geometry/EllipseArc/Query",
        "inDepth": "Center Point finds the center point of an ellipse arc, which is the same as the center point of the completed ellipse. In the example, we first create an Ellipse Arc by using the XY plane and a series of number sliders. We then use CenterPoint to extract the center of the ellipse."
    },
    {
        "Name": "MajorAxis",
        "imageFile": [
            "MajorAxis"
        ],
        "dynFile": [
            "MajorAxis"
        ],
        "folderPath": "Geometry/EllipseArc/Query",
        "inDepth": "Major Axis will return the longer of the two axes of the ellipse. The axis is output as a vector, which has a magnitude equal to the larger of the two radii. Note that Major and Minor axes are determined by length, not by direction. That is, the major axis might correspond to the xAxisRadius of one ellipse, but the yAxisRadius of a different ellipse. In the example, we first create an Ellipse Arc by using the XY plane and a series of number sliders. We then use Major Axis to extract the major axis of the ellipse."
    },
    {
        "Name": "MinorAxis",
        "imageFile": [
            "MinorAxis"
        ],
        "dynFile": [
            "MinorAxis"
        ],
        "folderPath": "Geometry/EllipseArc/Query",
        "inDepth": "Minor Axis will return the shorter of the two axes of the ellipse. The axis is output as a vector, which has a magnitude equal to the shorter of the two radii. Note that Major and Minor axes are determined by length, not by direction. That is, the minor axis might correspond to the xAxisRadius of one ellipse, but the yAxisRadius of a different ellipse.  In the example, we first create an Ellipse Arc by using the XY plane and a series of number sliders. We then use Minor Axis to extract the minor axis of the ellipse."
    },
    {
        "Name": "Plane",
        "imageFile": [
            "Plane"
        ],
        "dynFile": [
            "Plane"
        ],
        "folderPath": "Geometry/EllipseArc/Query",
        "inDepth": "Plane finds the center point of an ellipse arc, which is the same as the plane of the completed ellipse. In the example, we first create an Ellipse Arc by using the XY plane and a series of number sliders. We then use Plane to extract the plane of the ellipse."
    },
    {
        "Name": "StartAngle",
        "imageFile": [
            "StartAngle"
        ],
        "dynFile": [
            "StartAngle"
        ],
        "folderPath": "Geometry/EllipseArc/Query",
        "inDepth": "Start Angle finds the starting angle of the ellipse arc. This is measured in degrees counter-clockwise starting from the plane X-axis. In the example, we first create an Ellipse Arc by using the XY plane and a series of number sliders. We then use Start Angle to extract the angle of the beginning pont of the ellipse."
    },
    {
        "Name": "SweepAngle",
        "imageFile": [
            "SweepAngle"
        ],
        "dynFile": [
            "SweepAngle"
        ],
        "folderPath": "Geometry/EllipseArc/Query",
        "inDepth": "Sweep Angle finds the starting angle of the ellipse arc. This is measured in degrees counter-clockwise on the ellipse plane, starting from the start angle. The end angle of the ellipse would be equal to the start angle plus the sweep angle. In the example, we first create an Ellipse Arc by using the XY plane and a series of number sliders. We then use Sweep Angle to extract arc length of the ellipse arc."
    },
    {
        "Name": "SurfaceGeometry",
        "imageFile": [
            "SurfaceGeometry"
        ],
        "dynFile": [
            "SurfaceGeometry"
        ],
        "folderPath": "Geometry/Face/Action",
        "inDepth": "SurfaceGeometry will return a Face as a Surface. In the example below, a Face is identified on the Solid and returned as a Surface."
    },
    {
        "Name": "Edges",
        "imageFile": [
            "Edges"
        ],
        "dynFile": [
            "Edges"
        ],
        "folderPath": "Geometry/Face/Query",
        "inDepth": "Edges will return the Edges around a Face in clockwise order. In the example below, the Edges of a Face are identified and represented as Lines"
    },
    {
        "Name": "Vertices",
        "imageFile": [
            "Vertices"
        ],
        "dynFile": [
            "Vertices"
        ],
        "folderPath": "Geometry/Face/Query",
        "inDepth": "Vertices will return the Vertices around a Face in counterclockwise order. In the example below, the Vertices of a Face are indentified and represented as Points."
    },
    {
        "Name": "ClosestPointTo",
        "imageFile": [
            "ClosestPointTo"
        ],
        "dynFile": [
            "ClosestPointTo"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "Geometry ClosestPointTo finds the closest point from one geometry to another, adding a 3D Point to the document. This example finds the closest point on one Sphere to another."
    },
    {
        "Name": "DeserializeFromSAB",
        "imageFile": [
            "DeserializeFromSAB"
        ],
        "dynFile": [
            "DeserializeFromSAB"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "DeserializeFromSAB will return geometry from SAB format data. In the example below, SAB data is read from a file and deserialized into a skewed cylinder."
    },
    {
        "Name": "DistanceTo",
        "imageFile": [
            "DistanceTo"
        ],
        "dynFile": [
            "DistanceTo"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "Geometry DistanceTo returns the distance between two geometries. This example finds the distance between two Spheres."
    },
    {
        "Name": "DoesIntersect",
        "imageFile": [
            "DoesIntersect"
        ],
        "dynFile": [
            "DoesIntersect"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "Geometry DoesIntersect tests two geometries for an intersection. If the objects intersect, the Node will return True. This example tests for an intersection of two Sphere geometries."
    },
    {
        "Name": "Explode",
        "imageFile": [
            "Explode"
        ],
        "dynFile": [
            "Explode"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "The Geometry Explode Node breaks a geometry down into smaller components. For example, a Polysurface can be Exploded into several Surfaces and a Polycurve into curves. In this example, we are extracting a single Surface from a complex Intersection of three Spheres."
    },
    {
        "Name": "ExportToSAT (geometry, filePath)",
        "imageFile": [
            "ExportToSAT_gf"
        ],
        "dynFile": [
            "ExportToSAT_gf"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "Geometry ExportToSAT exports Geometry from Dynamo to a SAT file type. In this example, we are exporting a Polysurface from the Intersection of three Spheres."
    },
    {
        "Name": "ExportToSAT (geometry, filePath, unitsMM)",
        "imageFile": [
            "ExportToSAT (geometry, filePath, unitsMM)"
        ],
        "dynFile": [
            "ExportToSAT (geometry, filePath, unitsMM)"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "ExportToSAT (geometry, filePath, unitsMM) will return an .SAT file export at the input file path with input units. In the example below, a Cylinder is exported to a file path of C://_REFERENCE/exportsample.sat with millimeters as its units. "
    },
    {
        "Name": "ExportToSAT (geometry, filePath)",
        "imageFile": [
            "ExportToSAT_gf"
        ],
        "dynFile": [
            "ExportToSAT_gf"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "Geometry ExportToSAT exports Geometry from Dynamo to a SAT file type. In this example, we are exporting a Polysurface from the Intersection of three Spheres."
    },
    {
        "Name": "ExportToSAT (geometry, filePath, unitsMM)",
        "imageFile": [
            "ExportToSAT (geometry, filePath, unitsMM)"
        ],
        "dynFile": [
            "ExportToSAT (geometry, filePath, unitsMM)"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "ExportToSAT (geometry, filePath, unitsMM) will return an .SAT file export at the input file path with input units. In the example below, a Cylinder is exported to a file path of C://_REFERENCE/exportsample.sat with millimeters as its units. "
    },
    {
        "Name": "ExportToSAT (geometry, filePath)",
        "imageFile": [
            "ExportToSAT_gf"
        ],
        "dynFile": [
            "ExportToSAT_gf"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "Geometry ExportToSAT exports Geometry from Dynamo to a SAT file type. In this example, we are exporting a Polysurface from the Intersection of three Spheres."
    },
    {
        "Name": "ImportFromSAT (filePath)",
        "imageFile": [
            "ImportFromSAT"
        ],
        "dynFile": [
            "ImportFromSAT"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "Geometry ImportFromSAT imports Geometry to Dynamo from a SAT file type. This node takes a filePath as input, and also accepts a string with a valid file path. For the example below, we previously exported geometry to a SAT file (see ExportToSAT). The file name we chose was example.sat and it was exported to a folder on the users desktop. In the example, we show two different nodes used to import geometry from a SAT file. One has a filePath as the input type, and the other has a 'file' as the input type. The filePath is created using a FilePath node, which can select a file by clicking the Browse button. In the second example, we specify the file path manually by using a string element."
    },
    {
        "Name": "ImportFromSAT (file)",
        "imageFile": [
            "ImportFromSAT"
        ],
        "dynFile": [
            "ImportFromSAT"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "Geometry ImportFromSAT imports Geometry to Dynamo from a SAT file type. This node takes a file as input, and also accepts a string with a valid file path. For the example below, we previously exported geometry to a SAT file (see ExportToSAT). The file name we chose was example.sat and it was exported to a folder on the users desktop. In the example, we show two different nodes used to import geometry from a SAT file. One has a filePath as the input type, and the other has a 'file' as the input type. The filePath is created using a FilePath node, which can select a file by clicking the Browse button. In the second example, we specify the file path manually by using a string element."
    },
    {
        "Name": "Intersect",
        "imageFile": [
            "Intersect"
        ],
        "dynFile": [
            "Intersect"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "Geometry Intersect finds the Intersection Geometry that two Geometry objects share. In this example, the Intersection of two Spheres returns a Polysurface, otherwise known as a Solid Intersection."
    },
    {
        "Name": "IntersectAll",
        "imageFile": [
            "IntersectAll"
        ],
        "dynFile": [
            "IntersectAll"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "Geometry IntersectAll finds the Intersection Geometry that any number of Geometry objects share. In this example, the Intersection of three Spheres returns a Polysurface, otherwise known as a Solid Intersection."
    },
    {
        "Name": "IsAlmostEqualTo",
        "imageFile": [
            "IsAlmostEqualTo"
        ],
        "dynFile": [
            "IsAlmostEqualTo"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "IsAlmostEqualTo will return a boolean value based on whether two pieces of geometry share the same representational or numerical values. In the examples below, three Cylinders overlap each other. Two return true if they are in the same position, but will return false with the Solid. The sliders can be adjusted to change one Cylinder's position or height, affecting whether it is equal to the other Cylinder."
    },
    {
        "Name": "Mirror",
        "imageFile": [
            "Mirror"
        ],
        "dynFile": [
            "Mirror"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "Geometry Mirror reflects a Geometry across a defined Plane. In this example, we are Mirroring a Cone across the Y-Axis."
    },
    {
        "Name": "Rotate (geometry, basePlane, degrees)",
        "imageFile": [
            "Rotate_gbd"
        ],
        "dynFile": [
            "Rotate_gbd"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "This Geometry Rotate Node Rotates an input Geometry around an Origin Point and Axis Vector by a certain Degree amount. In the example file, a Cone is Rotated about the Y-Axis Vector by its End Point."
    },
    {
        "Name": "Rotate (geometry, origin, axis, degrees)",
        "imageFile": [
            "Rotate_goad"
        ],
        "dynFile": [
            "Rotate_goad"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "This Geometry Rotate Node Rotates an input Geometry around a Base Plane by a defined Degree. In the example file, a Cone is Rotated around the XY-Plane with a Number Slider."
    },
    {
        "Name": "Scale (geometry, basePoint, from, to)",
        "imageFile": [
            "Scale_gbft"
        ],
        "dynFile": [
            "Scale_gbft"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "This Geometry Scale Node Scales an input Geometry from three reference Points. In this example, we are scaling a Cone relative to its End Point from its Start Point to its Centroid. The Cone Circle and side Edge are drawn as a visual reference of the Scale."
    },
    {
        "Name": "Scale (geometry, amount)",
        "imageFile": [
            "Scale_ga"
        ],
        "dynFile": [
            "Scale_ga"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "This Geometry Scale Node Scales an input Geometry from the object Centroid by an input factor. In the example file, a Cone is scaled down with a Number Slider. The original Cone Edges are drawn for a visual reference."
    },
    {
        "Name": "Scale (geometry, xamount, yamount, zamount)",
        "imageFile": [
            "Scale_gxyz"
        ],
        "dynFile": [
            "Scale_gxyz"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "This Geometry Scale Node Scales an input Geometry from the object Centroid by an input factor. In the example, a Cone’s Scale can be finely tuned with three Number Sliders. The original Cone Edges are drawn as a visual reference."
    },
    {
        "Name": "Scale (geometry, plane, xamount, yamount, zamount)",
        "imageFile": [
            "Scale_gpxyz"
        ],
        "dynFile": [
            "Scale_gpxyz"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "This Geometry Scale Node Scales an input Geometry about a Plane by specified X, Y and Z factors. This example shows a Cone before and after it is scaled in relationship to the YZ-Plane."
    },
    {
        "Name": "Scale1D",
        "imageFile": [
            "Scale1D"
        ],
        "dynFile": [
            "Scale1D"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "Geometry Scale1D Scales a Geometry in one direction from a Base Point and two reference Points. In the example file, a Cone is scaled from its End Point to its Centroid in relation to the Cone Start Point. The original Cone Edges are drawn as a visual reference."
    },
    {
        "Name": "Scale2D",
        "imageFile": [
            "Scale2D"
        ],
        "dynFile": [
            "Scale2D"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "Geometry Scale2D Scales a Geometry in two directions from a Base Plane and two reference Points. In the example file, a Cone is scaled from its End Point to its Centroid in relation to the YZ-Plane."
    },
    {
        "Name": "SerializeAsSAB (geometry)",
        "imageFile": [
            "SerializeAsSAB (geometry)"
        ],
        "dynFile": [
            "SerializeAsSAB (geometry)"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "SerializeAsSAB (geometry) will return a list of SAB format data. In the example below, a Solid is converted to SAB data and returns integers shown in a Watch node."
    },
    {
        "Name": "SerializeAsSAB (geometry)",
        "imageFile": [
            "SerializeAsSAB (geometry)"
        ],
        "dynFile": [
            "SerializeAsSAB (geometry)"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "SerializeAsSAB (geometry) will return a list of SAB format data. In the example below, a Solid is converted to SAB data and returns integers shown in a Watch node."
    },
    {
        "Name": "Split",
        "imageFile": [
            "Split"
        ],
        "dynFile": [
            "Split"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "The Geometry Split Node functions similarly to the Geometry Trim Node. It inputs a Tool – any type of Geometry that you will be trimming another Geometry with – and a Geometry, and returns all of the fragments of Geometry. In this example, a Cone is Split with a similar Cone. Although all fragments are returned by the Geometry Split Node, one is previewed in the example file."
    },
    {
        "Name": "Transform (geometry, fromCoordinateSystem, contextCoordinateSystem)",
        "imageFile": [
            "Transform_gfc"
        ],
        "dynFile": [
            "Transform_gfc"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "This Geometry Transform Node moves and orients a geometry from one Coordinate System plane to another specified Coordinate System. In this example a Cone is Transformed from the ground plane to the YZ-Plane."
    },
    {
        "Name": "Transform (geometry, cs)",
        "imageFile": [
            "Transform_gc"
        ],
        "dynFile": [
            "Transform_gc"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "This Geometry Transform Node moves and orients a geometry from the XY-Plane to any specified Plane. In this example a Cone is Transformed from the XY-Plane to the YZ-Plane."
    },
    {
        "Name": "Translate (geometry, direction)",
        "imageFile": [
            "Translate_gd"
        ],
        "dynFile": [
            "Translate_gd"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "This Geometry Translate Node moves a geometry by any given Vector. In the example file, we are Translating a Cone by the Vector created between the Start and End Points of the Cone."
    },
    {
        "Name": "Translate (geometry, xTranslation, yTranslation, zTranslation)",
        "imageFile": [
            "Translate_gxyz"
        ],
        "dynFile": [
            "Translate_gxyz"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "This Geometry Translate Node moves a geometry by any given Vector direction and a Distance. In the example file, we are Translating a Cone in the X-Axis direction by a distance inherited by a Number Slider."
    },
    {
        "Name": "Translate (geometry, direction, distance)",
        "imageFile": [
            "Translate_gdd"
        ],
        "dynFile": [
            "Translate_gdd"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "This Geometry Translate Node moves a geometry by a Vector defined in the Node by inputting all three Translation Values for X, Y and Z. In the example file, a Cone is Translated by three Number Slider values."
    },
    {
        "Name": "Trim",
        "imageFile": [
            "Trim"
        ],
        "dynFile": [
            "Trim"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "Geometry Trim functions similarly to the Geometry Split Node in that it inputs a Tool – any type of Geometry that you will be trimming another Geometry with – and a Geometry, but returns only a single fragment of the Geometry. The Geometry that is Picked is selected by a reference Point closest to the fragment. In this example, one Cone is Trimmed by another, with its lower portion Picked."
    },
    {
        "Name": "BoundingBox",
        "imageFile": [
            "BoundingBox"
        ],
        "dynFile": [
            "BoundingBox"
        ],
        "folderPath": "Geometry/Geometry/Query",
        "inDepth": "BoundingBox will return a box defined by the geometry it contains. A BoundingBox is not displayed, but can be returned as a PolySurface using the BoundingBox.ToPolySurface node. In the example below, a BoundingBox is created for a unioned Solid and represented as a PolySurface."
    },
    {
        "Name": "ContextCoordinateSystem",
        "imageFile": [
            "ContextCoordinateSystem"
        ],
        "dynFile": [
            "ContextCoordinateSystem"
        ],
        "folderPath": "Geometry/Geometry/Query",
        "inDepth": "ContextCoordinateSystem will return the CoordinateSystem that was used in creating a piece of geometry. In the example below, a Solid created at centerPoint (3,0,0) returns a CoordinateSystem located at the origin."
    },
    {
        "Name": "ByAxis",
        "imageFile": [
            "ByAxis"
        ],
        "dynFile": [
            "ByAxis"
        ],
        "folderPath": "Geometry/Helix/Create",
        "inDepth": "Helix By Axis creates a helix. The axis of the helix is defined by the input axis point and the axis direction. The helix will be created counter-clockwise around the axis, starting from the start point and continuing for an angular length of the Angle Turns input, in degrees. The Pitch input determines the distance of the helix per each 360 degrees in the direction of the axis. In the example below, we start the helix at the point (3,5) and use the Y-axis to define the helix axis. The start point of the helix is controlled by three number sliders. The pitch and angleTurns use two more number sliders. Note that the angleTurns is in degrees."
    },
    {
        "Name": "Angle",
        "imageFile": [
            "Angle"
        ],
        "dynFile": [
            "Angle"
        ],
        "folderPath": "Geometry/Helix/Query",
        "inDepth": "Angle will find the total angular length of a helix in degrees, where one complete turn is equal to 360. In the example below, we create a helix using Helix By Axis, then use Angle to find the total angle of the helix."
    },
    {
        "Name": "AxisDirection",
        "imageFile": [
            "AxisDirection"
        ],
        "dynFile": [
            "AxisDirection"
        ],
        "folderPath": "Geometry/Helix/Query",
        "inDepth": "Axis Direction will return the direction of the central axis of a helix as a vector. Together with the Axis Point, this defines the central axis. In the example below, we create a helix using Helix By Axis, then use Axis Direction to find the direction of the helix axis."
    },
    {
        "Name": "AxisPoint",
        "imageFile": [
            "AxisPoint"
        ],
        "dynFile": [
            "AxisPoint"
        ],
        "folderPath": "Geometry/Helix/Query",
        "inDepth": "Axis Point will return the base point of the helix axis. Together with the Axis Direction, this defines the central axis of a helix. In the example below, we create a helix using Helix By Axis, then use Axis Point to find the initial point of the helix axis."
    },
    {
        "Name": "Pitch",
        "imageFile": [
            "Pitch"
        ],
        "dynFile": [
            "Pitch"
        ],
        "folderPath": "Geometry/Helix/Query",
        "inDepth": "Pitch will return the linear distance along the axis direction that a helix spans in one complete turn (360 degrees). In the example below, we create a helix using Helix by Axis, then use Pitch to find the pitch of the helix."
    },
    {
        "Name": "Radius",
        "imageFile": [
            "Radius"
        ],
        "dynFile": [
            "Radius"
        ],
        "folderPath": "Geometry/Helix/Query",
        "inDepth": "Radius will return the distance from the central axis to the point on the helix on a plane perpendicular to the axis. In the example below, we create a helix using Helix by Axis, then use Radius to find the radius of the helix."
    },
    {
        "Name": "ByIndices (a, b, c, d)",
        "imageFile": [
            "ByIndices (a, b, c, d) (a, b, c, d) (a, b, c, d)"
        ],
        "dynFile": [
            "ByIndices (a, b, c, d) (a, b, c, d) (a, b, c, d)"
        ],
        "folderPath": "Geometry/IndexGroup/Create",
        "inDepth": "ByIndices (a, b, c, d) (a, b, c, d) (a, b, c, d) will return an IndexGroup of four Indices. In the example below, four indices are defined for a four-sided Mesh created with Mesh.ByPointsFacesIndices."
    },
    {
        "Name": "ByIndices (a, b, c)",
        "imageFile": [
            "ByIndices (a, b, c) (a, b, c)"
        ],
        "dynFile": [
            "ByIndices (a, b, c) (a, b, c)"
        ],
        "folderPath": "Geometry/IndexGroup/Create",
        "inDepth": "ByIndices (a, b, c) (a, b, c) will return an IndexGroup of three Indices. In the example below, three indices are defined for a three-sided Mesh created with Mesh.ByPointsFacesIndices."
    },
    {
        "Name": "A",
        "imageFile": [
            "A"
        ],
        "dynFile": [
            "A"
        ],
        "folderPath": "Geometry/IndexGroup/Query",
        "inDepth": "A will return the value of Index A. In the example below, the Index value of A is returned as 0 in a three-sided Mesh."
    },
    {
        "Name": "B",
        "imageFile": [
            "B"
        ],
        "dynFile": [
            "B"
        ],
        "folderPath": "Geometry/IndexGroup/Query",
        "inDepth": "B will return the value of Index B. In the example below, the Index value of B is returned as 1 in a three-sided Mesh."
    },
    {
        "Name": "C",
        "imageFile": [
            "C"
        ],
        "dynFile": [
            "C"
        ],
        "folderPath": "Geometry/IndexGroup/Query",
        "inDepth": "C will return the value of Index C. In the example below, the Index value of C is returned as 2 in a three-sided Mesh."
    },
    {
        "Name": "Count",
        "imageFile": [
            "Count"
        ],
        "dynFile": [
            "Count"
        ],
        "folderPath": "Geometry/IndexGroup/Query",
        "inDepth": "Count will return an integer that represents the number of Indices in an IndexGroup. In the example below, Index counts are returned for Mesh faces with three and four edges."
    },
    {
        "Name": "D",
        "imageFile": [
            "D"
        ],
        "dynFile": [
            "D"
        ],
        "folderPath": "Geometry/IndexGroup/Query",
        "inDepth": "D will return the value of Index D. In the example below, the Index value of D is returned as 3 in a four-sided Mesh."
    },
    {
        "Name": "ByBestFitThroughPoints",
        "imageFile": [
            "ByBestFitThroughPoints"
        ],
        "dynFile": [
            "ByBestFitThroughPoints"
        ],
        "folderPath": "Geometry/Line/Create",
        "inDepth": "Line by Best Fit Through Points will create a line by approximating a scatter plot of points. The input is a list of points. In this example, we use a number slider to control the number of random points generated, and then find the best fit line through the set of points. "
    },
    {
        "Name": "ByStartPointDirectionLength",
        "imageFile": [
            "ByStartPointDirectionLength"
        ],
        "dynFile": [
            "ByStartPointDirectionLength"
        ],
        "folderPath": "Geometry/Line/Create",
        "inDepth": "Line by Start Point Direction Length creates a line beginning at the startPoint input, and with a length and direction according to the input direction vector and length. In the example below, we use a code block specify the x,y, and z coordinates of a point. We then use a number slider to control the length of the line."
    },
    {
        "Name": "ByStartPointEndPoint",
        "imageFile": [
            "ByStartPointEndPoint"
        ],
        "dynFile": [
            "ByStartPointEndPoint"
        ],
        "folderPath": "Geometry/Line/Create",
        "inDepth": "Line By Start Point End Point will create a line between two input points. In this example, we use two code blocks to specify the x,y, and z coordinates of two points, and then create a line between the two points."
    },
    {
        "Name": "ByTangency",
        "imageFile": [
            "ByTangency"
        ],
        "dynFile": [
            "ByTangency"
        ],
        "folderPath": "Geometry/Line/Create",
        "inDepth": "Line By Tangency creates a line tangent to an input curve, and with a length of 1 unit. The parameter input specifies the position along the curve to evaluate, with a parameter of zero being the beginning of the curve, and a value of 1 being the end of the curve. In the example, we use a Code Block to generate two lists corresponding to X and Y locations of a series of points. The points are used to draw a Nurbs Curve. We then use a number slider between 0 and 1 as an input parameter to create a line tangent to the curve."
    },
    {
        "Name": "Direction",
        "imageFile": [
            "Direction"
        ],
        "dynFile": [
            "Direction"
        ],
        "folderPath": "Geometry/Line/Query",
        "inDepth": "Direction will return a vector that points in the same direction as a line. The magnitude of the vector is equal to the length of the original line. In the example below, we generate a set of random points, and then us ByBestFitThroughPoints to create a line. We use Direction to find the vector direction of the created line."
    },
    {
        "Name": "ByPointsFaceIndices",
        "imageFile": [
            "ByPointsFaceIndices"
        ],
        "dynFile": [
            "ByPointsFaceIndices"
        ],
        "folderPath": "Geometry/Mesh/Create",
        "inDepth": "ByPointsFaceIndices will return a Mesh based on input vertices as Points and input indices. In the example below, a four-sided Mesh is created with four Points and an IndexGroup of four indices."
    },
    {
        "Name": "FaceIndices",
        "imageFile": [
            "FaceIndices"
        ],
        "dynFile": [
            "FaceIndices"
        ],
        "folderPath": "Geometry/Mesh/Query",
        "inDepth": "FaceIndices will return the IndexGroup of a mesh face in counterclockwise order. In the example below, the an Indexgroup is returned for a four-sided mesh face."
    },
    {
        "Name": "VertexNormals",
        "imageFile": [
            "VertexNormals"
        ],
        "dynFile": [
            "VertexNormals"
        ],
        "folderPath": "Geometry/Mesh/Query",
        "inDepth": "VertexNormals will return Vectors that represent the normal of each Vertex. In the example below, the normal of each Vertex is returned as a line to represent its direction."
    },
    {
        "Name": "VertexPositions",
        "imageFile": [
            "VertexPositions"
        ],
        "dynFile": [
            "VertexPositions"
        ],
        "folderPath": "Geometry/Mesh/Query",
        "inDepth": "VertexPositions will return a Mesh face's Vertex positions as Points. In the example below, the Vertex positions of a four-sided Mesh face are returned as Points."
    },
    {
        "Name": "ByControlPoints (points, degree, closeCurve)",
        "imageFile": [
            "ByControlPoints_pdc"
        ],
        "dynFile": [
            "ByControlPoints_pdc"
        ],
        "folderPath": "Geometry/NurbsCurve/Create",
        "inDepth": "Nurbs Curve By Control Points inputs a list of control points to draw the Nurbs Curve and also allows us to control the degree of the curve. We also have the option to close the curve back to the first point in the list. This example generates four random points on the World XY plane and connects them in order in the X and Y directions."
    },
    {
        "Name": "ByControlPoints (points, degree)",
        "imageFile": [
            "ByControlPoints_p"
        ],
        "dynFile": [
            "ByControlPoints_p"
        ],
        "folderPath": "Geometry/NurbsCurve/Create",
        "inDepth": "Nurbs Curve By Control Points inputs a list of control points to draw the Nurbs Curve and also allows us to control the degree of the curve. This example generates four random points on the World XY plane and connects them in order in the X and Y directions."
    },
    {
        "Name": "ByControlPoints (points)",
        "imageFile": [
            "ByControlPoints_p"
        ],
        "dynFile": [
            "ByControlPoints_p"
        ],
        "folderPath": "Geometry/NurbsCurve/Create",
        "inDepth": "Nurbs Curve By Control Points inputs a list of points to use as control points and outputs a Nurbs Curve. This example uses a Code Block to generate two lists corresponding to X and Y locations of a series of points. The points are used to draw the Nurbs Curve."
    },
    {
        "Name": "ByControlPointsWeightsKnots",
        "imageFile": [
            "ByControlPointsWeightsKnots"
        ],
        "dynFile": [
            "ByControlPointsWeightsKnots"
        ],
        "folderPath": "Geometry/NurbsCurve/Create",
        "inDepth": "Nurbs Curve by Control Points Weights Knots allows us to manually control the weights and knots of a Nurbs Curve. The list of weights should be the same length as the list of control points. The size of the the list of knots must be equal to the number of control points plus the degree plus one. In the example, we first create a Nurbs Curve by interpolating between a series of random points. We use Knots, Weigts, and Control Points to find the corresponding parts of that curve. We can use ReplaceItemAtIndex to modify the list of weights. Finally we use ByControlPointsWeightsKnots to recreate the Nurbs Curve with the modified weights. "
    },
    {
        "Name": "ByPoints (points)",
        "imageFile": [
            "ByPoints_p"
        ],
        "dynFile": [
            "ByPoints_p"
        ],
        "folderPath": "Geometry/NurbsCurve/Create",
        "inDepth": "Nurbs Curve By Points inputs a list of points to draw a Nurbs Curve through. This example generates six random points on the World XY plane and connects them in order in the X and Y directions. "
    },
    {
        "Name": "ByPoints (points, degree)",
        "imageFile": [
            "ByPoints_pd"
        ],
        "dynFile": [
            "ByPoints_pd"
        ],
        "folderPath": "Geometry/NurbsCurve/Create",
        "inDepth": "Nurbs Curve By Points inputs a list of points to draw a Nurbs Curve through, and also allows us to change the degree of the curve. This example generates six random points on the World XY plane and connects them in order in the X and Y directions. "
    },
    {
        "Name": "ByPoints (points, closeCurve)",
        "imageFile": [
            "ByPoints_pc"
        ],
        "dynFile": [
            "ByPoints_pc"
        ],
        "folderPath": "Geometry/NurbsCurve/Create",
        "inDepth": "Nurbs Curve By Points inputs a list of points to draw a Nurbs Curve through and also allows us to close the curve. This example generates four random points on the World XY plane and connects them in order in the X and Y directions, closing the curve back to the first point in the list."
    },
    {
        "Name": "ByPointsTangents",
        "imageFile": [
            "ByPointsTangents"
        ],
        "dynFile": [
            "ByPointsTangents"
        ],
        "folderPath": "Geometry/NurbsCurve/Create",
        "inDepth": "Nurbs Curve By Points Tangents inputs a list of control points and the start and end tangent that the Nurbs Curve will maintain. This example uses a reference circle for the control points of the curve, and a single vector to control both the start and end tangents. "
    },
    {
        "Name": "ControlPoints",
        "imageFile": [
            "ControlPoints"
        ],
        "dynFile": [
            "ControlPoints"
        ],
        "folderPath": "Geometry/NurbsCurve/Action",
        "inDepth": "Control Points will return a list of the control points of a NURBS curve. In the example, we first generate a number of random points, and then use NurbsCurve ByPoints to create a curve interpolated through the points. We can use Control Points to then get a list of the control points (instead of the original interpolated points) of the curve."
    },
    {
        "Name": "Knots",
        "imageFile": [
            "Knots"
        ],
        "dynFile": [
            "Knots"
        ],
        "folderPath": "Geometry/NurbsCurve/Action",
        "inDepth": "Knots will return the knots of a NURBS curve as a list of numbers. In the example, we first generate a number of random points, and then use NurbsCurve ByPoints to create a curve interpolated through the points. We can use Knots to then get a list of the knots for this curve."
    },
    {
        "Name": "Weights",
        "imageFile": [
            "Weights"
        ],
        "dynFile": [
            "Weights"
        ],
        "folderPath": "Geometry/NurbsCurve/Action",
        "inDepth": "Weights will return the weights of a NURBS curve as a list of numbers. Each weight corresponds to one control point of the curve. In the example, we first generate a number of random points, and then use NurbsCurve ByPoints to create a curve interpolated through the points. We can use Weights to then get a list of the weights for this curve."
    },
    {
        "Name": "Degree",
        "imageFile": [
            "Degree"
        ],
        "dynFile": [
            "Degree"
        ],
        "folderPath": "Geometry/NurbsCurve/Query",
        "inDepth": "Degree will return the degree of a NURBS curve. In the example, we first generate a number of random points, and then use NurbsCurve ByPoints to create a curve interpolated through the points. We can use Degree to then get the degree of the curve. Since we created the curve without specifying the degree, it used a default degree of three. (A polygonal curve of straight lines has a degree of one, while the most common degree for non-straight-segmented curves is 3)"
    },
    {
        "Name": "IsPeriodic",
        "imageFile": [
            "IsPeriodic"
        ],
        "dynFile": [
            "IsPeriodic"
        ],
        "folderPath": "Geometry/NurbsCurve/Query",
        "inDepth": "IsPeriodic returns a boolean value of true if the curve is periodic, and false if the curve is not periodic. In the example, we first generate a number of random points, and then use NurbsCurve ByPoints to create a curve interpolated through the points. We can use IsPeriodic to determine whether or not the curve is periodic."
    },
    {
        "Name": "IsRational",
        "imageFile": [
            "IsRational"
        ],
        "dynFile": [
            "IsRational"
        ],
        "folderPath": "Geometry/NurbsCurve/Query",
        "inDepth": "IsRational returns a boolean value of true if the curve is rational, and false if the curve is not rational. In the example, we first generate a number of random points, and then use NurbsCurve ByPoints to create a curve interpolated through the points. We can use IsRational to determine whether or not the curve is rational."
    },
    {
        "Name": "ByControlPoints",
        "imageFile": [
            "ByControlPoints"
        ],
        "dynFile": [
            "ByControlPoints"
        ],
        "folderPath": "Geometry/NurbsSurface/Create",
        "inDepth": "Nurbs Surface By Control Points takes in a two dimensional array of control vertices and outputs a Nurbs Surface. This node also gives us the ability to calibrate the degree in the U and V directions. In this example, a 10 by 10 grid of points is created with a Code Block Range. The grid is then scaled in the Z-direction at random, modulating the output surface from the By Control Points node. "
    },
    {
        "Name": "ByControlPointsWeightsKnots",
        "imageFile": ["ByControlPointsWeightsKnots"],
        "dynFile": ["ByControlPointsWeightsKnots"],
        "folderPath": "Geometry/NurbsSurface/Create",
        "inDepth": "Add in-depth information about ByControlPointsWeightsKnots..."
    },
    {
        "Name": "ByPoints",
        "imageFile": [
            "ByPoints"
        ],
        "dynFile": [
            "ByPoints"
        ],
        "folderPath": "Geometry/NurbsSurface/Create",
        "inDepth": "Nurbs Surface By Points takes in a two dimensional array of control vertices and outputs a Nurbs Surface. This node also gives us the ability to calibrate the degree in the U and V directions. In this example, a 50 by 50 grid of points is created with a Code Block Range. The grid is then scaled in the Z-direction at random, modulating the output surface from the By Control Points node. "
    },
    {
        "Name": "ByPointsTangents",
        "imageFile": ["ByPointsTangents"],
        "dynFile": ["ByPointsTangents"],
        "folderPath": "Geometry/NurbsSurface/Create",
        "inDepth": "Add in-depth information about ByPointsTangents..."
    },
    {
        "Name": "ByPointsTangentsKnotsDerivatives",
        "imageFile": [],
        "dynFile": [],
        "folderPath": "Geometry/NurbsSurface/Create",
        "inDepth": "Add in-depth information about ByPointsTangentsKnotsDerivatives..."
    },
    {
        "Name": "ControlPoints",
        "imageFile": [
            "ControlPoints"
        ],
        "dynFile": [
            "ControlPoints"
        ],
        "folderPath": "Geometry/NurbsSurface/Action",
        "inDepth": "ControlPoints will return the ControlPoints of a NurbsSurface as Points in a List of Lists. In the example below, the ControlPoints are returned from a NurbsSurface created from a Patch."
    },
    {
        "Name": "UKnots",
        "imageFile": [
            "UKnots"
        ],
        "dynFile": [
            "UKnots"
        ],
        "folderPath": "Geometry/NurbsSurface/Action",
        "inDepth": "UKnots will return the Surface Knots in the U direction of a NurbsSurface. In the example below, the UKnots of the NurbsSurface are returned as a list of doubles."
    },
    {
        "Name": "VKnots",
        "imageFile": [
            "VKnots"
        ],
        "dynFile": [
            "VKnots"
        ],
        "folderPath": "Geometry/NurbsSurface/Action",
        "inDepth": "VKnots will return the Surface Knots in the V direction of a NurbsSurface. In the example below, the VKnots of the NurbsSurface are returned as a list of doubles."
    },
    {
        "Name": "Weights",
        "imageFile": [
            "Weights"
        ],
        "dynFile": [
            "Weights"
        ],
        "folderPath": "Geometry/NurbsSurface/Action",
        "inDepth": "Weights will return the Weights of a NurbsSurface as doubles in a List of Lists. In the example below, a NurbsSurface returns a list of Weights with a value of 1."
    },
    {
        "Name": "DegreeU",
        "imageFile": [
            "DegreeU"
        ],
        "dynFile": [
            "DegreeU"
        ],
        "folderPath": "Geometry/NurbsSurface/Query",
        "inDepth": "DegreeU will return the degree of a NurbsSurface in the U direction. In the example below, a NurbsSurface created with Points and specified U/V degrees has a degree of 2 in the U direction. Adjusting the number sliders will change the U and V degree values."
    },
    {
        "Name": "DegreeV",
        "imageFile": [
            "DegreeV"
        ],
        "dynFile": [
            "DegreeV"
        ],
        "folderPath": "Geometry/NurbsSurface/Query",
        "inDepth": "DegreeV will return the degree of a NurbsSurface in the V direction. In the example below, a NurbsSurface created with Points and specified U/V degrees has a degree of 2 in the V direction. Adjusting the number sliders will change the U and V degree values."
    },
    {
        "Name": "IsPeriodicInU",
        "imageFile": ["IsPeriodicInU"],
        "dynFile": ["IsPeriodicInU"],
        "folderPath": "Geometry/NurbsSurface/Query",
        "inDepth": "Add in-depth information about IsPeriodicInU..."
    },
    {
        "Name": "IsPeriodicInV",
        "imageFile": ["IsPeriodicInV"],
        "dynFile": ["IsPeriodicInV"],
        "folderPath": "Geometry/NurbsSurface/Query",
        "inDepth": "Add in-depth information about IsPeriodicInV..."
    },
    {
        "Name": "IsRational",
        "imageFile": [
            "IsRational"
        ],
        "dynFile": [
            "IsRational"
        ],
        "folderPath": "Geometry/NurbsSurface/Query",
        "inDepth": "IsRational will return a boolean value based on whether a NurbsSurface is rational. In the example below, a NurbsSurface created by approximating a Surface returns a false value."
    },
    {
        "Name": "NumControlPointsU",
        "imageFile": [
            "NumControlPointsU"
        ],
        "dynFile": [
            "NumControlPointsU"
        ],
        "folderPath": "Geometry/NurbsSurface/Query",
        "inDepth": "NumControlPointsU will count the control points in the U direction of a NurbsSurface and return an integer. In the example below, the NurbsSurface returns an integer of 22 for its U control points. The control points are returned as Points using NurbsSurface.ControlPoints."
    },
    {
        "Name": "NumControlPointsV",
        "imageFile": [
            "NumControlPointsV"
        ],
        "dynFile": [
            "NumControlPointsV"
        ],
        "folderPath": "Geometry/NurbsSurface/Query",
        "inDepth": "NumControlPointsV will count the control points in the V direction of a NurbsSurface and return an integer. In the example below, the NurbsSurface returns an integer of 12 for its V control points. The control points are returned as Points using NurbsSurface.ControlPoints."
    },
    {
        "Name": "ByBestFitThroughPoints",
        "imageFile": [
            "ByBestFitThroughPoints"
        ],
        "dynFile": [
            "ByBestFitThroughPoints"
        ],
        "folderPath": "Geometry/Plane/Create",
        "inDepth": "Plane By Best Fit Through Points uses a set of points and finds the plane that best approximates the set. In the example, we use a series of RandomList components to generate random x,y and z coordinates. The points are created By Coordinates, and the list of points is then used as an input for ByBestFitThroughPoints."
    },
    {
        "Name": "ByLineAndPoint",
        "imageFile": [
            "ByLineAndPoint"
        ],
        "dynFile": [
            "ByLineAndPoint"
        ],
        "folderPath": "Geometry/Plane/Create",
        "inDepth": "Plane by Line and Point creates a plane using the input Point as the origin, and passing through the input line. The point must not lie on the axis of the line. In the example, we create a line by first using a set of random points and then creating a line with ByBestFitThroughPoints. An origin point is created with a code block providing the x,y, and z coordinates for a Point.ByCoordinates component. We then use the line and point as inputs to create a Plane by Line and Point."
    },
    {
        "Name": "ByOriginNormal",
        "imageFile": [
            "ByOriginNormal"
        ],
        "dynFile": [
            "ByOriginNormal"
        ],
        "folderPath": "Geometry/Plane/Create",
        "inDepth": "Plane by Origin Normal creates a plane using the input point as the origin, and perpendicular to the input Normal vector. In the example below, we use a code block to specify the x,y, and z coordinates of a Point By Coordinates. We then use that point as the Origin, and use a world Y-Axis as the normal vector for a Plane by Origin Normal."
    },
    {
        "Name": "ByOriginNormalXAxis",
        "imageFile": [
            "ByOriginNormalXAxis"
        ],
        "dynFile": [
            "ByOriginNormalXAxis"
        ],
        "folderPath": "Geometry/Plane/Create",
        "inDepth": "Plane by Origin Normal XAxis is similar to Plane By Origin Normal, but this allows us to also input a direction for the XAxis to control the orientation of the plane. If the input xAxis vector is not in the plane defined by the origin and normal inputs, it is first projected onto the plane to determine the Plane XAxis. In the example below, we use world YAxis as the normal vector, and use two code blocks to define the origin point and input xAxis."
    },
    {
        "Name": "ByOriginXAxisYAxis",
        "imageFile": [
            "ByOriginXAxisYAxis"
        ],
        "dynFile": [
            "ByOriginXAxisYAxis"
        ],
        "folderPath": "Geometry/Plane/Create",
        "inDepth": "Plane by Origin XAxis YAxis uses an origin point and two vectors to define a plane. The Normal vector of the plane is created by taking the cross product of the X and Y axis vectors. In the example below, we use world YAxis as the xAxis, and use two code blocks to define the origin point and input xAxis. "
    },
    {
        "Name": "ByThreePoints",
        "imageFile": [
            "ByThreePoints"
        ],
        "dynFile": [
            "ByThreePoints"
        ],
        "folderPath": "Geometry/Plane/Create",
        "inDepth": "Plane by Three Points will create a plane that passes through the three input points. The points must not be co-linear. In the example below, we use three code blocks to define the three initial points, then use ByThreePoints to create a plane."
    },
    {
        "Name": "XY",
        "imageFile": [
            "XY"
        ],
        "dynFile": [
            "XY"
        ],
        "folderPath": "Geometry/Plane/Create",
        "inDepth": "Plane XY creates a plane in the world XY directions. The normal of this plane is the world Z-Axis. In the example file, we show Plane XY, Plane YZ, and Plane XZ. In the image, the XY plane is highlighted."
    },
    {
        "Name": "XZ",
        "imageFile": [
            "XZ"
        ],
        "dynFile": [
            "XZ"
        ],
        "folderPath": "Geometry/Plane/Create",
        "inDepth": "Plane XZ creates a plane in the world XZ directions. The normal of this plane is the world Y-Axis. In the example file, we show Plane XY, Plane YZ, and Plane XZ. In the image, the XZ plane is highlighted."
    },
    {
        "Name": "YZ",
        "imageFile": [
            "YZ"
        ],
        "dynFile": [
            "YZ"
        ],
        "folderPath": "Geometry/Plane/Create",
        "inDepth": "Plane YZ creates a plane in the world YZ directions. The normal of this plane is the world X-Axis. In the example file, we show Plane XY, Plane YZ, and Plane XZ. In the image, the YZ plane is highlighted."
    },
    {
        "Name": "Offset",
        "imageFile": [
            "Offset"
        ],
        "dynFile": [
            "Offset"
        ],
        "folderPath": "Geometry/Plane/Action",
        "inDepth": "Plane Offset will create a new plane that is offset from the input plane. The amount of offset is controlled by the dist input (short for Distance). The offset is performed along the Normal direction of the plane. In the example below we first use a set of random points to create a Plane by Best Fit Through Points. We then use a Number Slider to control the offset distance."
    },
    {
        "Name": "ToCoordinateSystem",
        "imageFile": [
            "ToCoordinateSystem"
        ],
        "dynFile": [
            "ToCoordinateSystem"
        ],
        "folderPath": "Geometry/Plane/Action",
        "inDepth": "Plane To Coordinate System will return a Coordinate System based on the input plane, using the plane's origin, XAxis and YAxis. In the example below we first use a set of random points to create a Plane by Best Fit Through Points. We can then use ToCoordinateSystem to convert the Plane to a Coordinate System "
    },
    {
        "Name": "Normal",
        "imageFile": [
            "Normal"
        ],
        "dynFile": [
            "Normal"
        ],
        "folderPath": "Geometry/Plane/Query",
        "inDepth": "Plane Normal will find the normal vector of an input plane. This is also equal to taking the cross product of the plane XAxis and YAxis. In the example below we first use a set of random points to create a Plane by Best Fit Through Points. We can then find the normal vector of this plane."
    },
    {
        "Name": "Origin",
        "imageFile": [
            "Origin"
        ],
        "dynFile": [
            "Origin"
        ],
        "folderPath": "Geometry/Plane/Query",
        "inDepth": "Plane Origin will return the origin of an input plane as a point. This is specific to the plane, and is not necessarily the same as the world origin. In the example below, we first use a set of random points to create a Plane by Best Fit Through Points. We can then find the origin of this plane."
    },
    {
        "Name": "XAxis",
        "imageFile": [
            "XAxis"
        ],
        "dynFile": [
            "XAxis"
        ],
        "folderPath": "Geometry/Plane/Query",
        "inDepth": "Plane XAxis will return the y-axis of an input plane as a vector. This is specific to the plane, and is not necessarily the same as the world X-direction. In the example below, we first use a set of random points to create a Plane by Best Fit Through Points. We can then find the X-axis of this plane."
    },
    {
        "Name": "YAxis",
        "imageFile": [
            "YAxis"
        ],
        "dynFile": [
            "YAxis"
        ],
        "folderPath": "Geometry/Plane/Query",
        "inDepth": "Plane YAxis will return the y-axis of an input plane as a vector. This is specific to the plane, and is not necessarily the same as the world Y-direction. In the example below, we first use a set of random points to create a Plane by Best Fit Through Points. We can then find the Y-axis of this plane."
    },
    {
        "Name": "ByCartesianCoordinates",
        "imageFile": [
            "ByCartesianCoordinates"
        ],
        "dynFile": [
            "ByCartesianCoordinates"
        ],
        "folderPath": "Geometry/Point/Create",
        "inDepth": "Point By Cartesian Coordinates gives us the ability to set the X, Y and Z values of a point’s location. In this example, we are setting multiple Code Block Ranges controlled by sliders to drive the three-dimensional array of points."
    },
    {
        "Name": "ByCoordinates (x, y)",
        "imageFile": [
            "ByCoordinates",
            "ByCoordinates_crossReference"
        ],
        "dynFile": [
            "ByCoordinates",
            "ByCoordinates_crossReference"
        ],
        "folderPath": "Geometry/Point/Create",
        "inDepth": "The Point By Coordinates (XY) calls for two number inputs and generates a point on the Dynamo base plane.  In the first example,  we are using two sliders to dynamically control the point’s X and Y location on the Z-plane. In the second, we are using two Number Sliders and a Code Block Range to determine the maximum extents of the grid and the spacing between points. By changing the Points By Coordinates lacing to Cross-Reference, we can create multi-dimensional set of points along the X and Y axis."
    },
    {
        "Name": "ByCoordinates (x, y, z)",
        "imageFile": [
            "ByCoordinates (x, y, z)"
        ],
        "dynFile": [
            "ByCoordinates (x, y, z)"
        ],
        "folderPath": "Geometry/Point/Create",
        "inDepth": "ByCoordinates (x, y, z) will return a Point from X, Y, and Z values. In the example below, a Point is created with coordinate values of 2 for X, 3 for Y, and 4 for Z."
    },
    {
        "Name": "ByCylindricalCoordinates",
        "imageFile": [
            "ByCylindricalCoordinates"
        ],
        "dynFile": [
            "ByCylindricalCoordinates"
        ],
        "folderPath": "Geometry/Point/Create",
        "inDepth": "The Point By Cylindrical Coordinates node creates a point located within a cylindrical space. Here, we set the lacing to Cross-Reference and use a range of angles and elevations to generate a grid of points along a cylinder with a dynamic radius."
    },
    {
        "Name": "BySphericalCoordinates",
        "imageFile": [
            "BySphericalCoordinates"
        ],
        "dynFile": [
            "BySphericalCoordinates"
        ],
        "folderPath": "Geometry/Point/Create",
        "inDepth": "The Point By Spherical Coordinates node creates a point located within a spherical space. Here, we set the lacing to Cross-Reference and use a range of phi and theta angles to generate a grid of points along a cylinder with a dynamic radius. The location of the sphere is set to a Coordinate System with the origin (1, 5, 1)."
    },
    {
        "Name": "Origin",
        "imageFile": [
            "Origin"
        ],
        "dynFile": [
            "Origin"
        ],
        "folderPath": "Geometry/Point/Create",
        "inDepth": "Origin will return a Point at the Origin of the WorldCoordinateSystem. In the example below, a Circle by centerpoint and radius is created using a Point at the WCS Origin."
    },
    {
        "Name": "Add",
        "imageFile": [
            "Add"
        ],
        "dynFile": [
            "Add"
        ],
        "folderPath": "Geometry/Point/Action",
        "inDepth": "Point Add will add the x,y, and z components of a input vector to the corresponding coordinates of the input point. This is the same as translating the point by the given vector, and is equivalent to using Geometry.Translate (Vector). In the example, we create a point using a code block to specify the x,y, and z coordinates, then add a world XAxis vector as the vectorToAdd. The result is the point translated by a distance of one in the positive x-direction."
    },
    {
        "Name": "AsVector",
        "imageFile": [
            "AsVector"
        ],
        "dynFile": [
            "AsVector"
        ],
        "folderPath": "Geometry/Point/Action",
        "inDepth": "Point as Vector takes an input point and returns a vector with x,y, and z components equal to the cartesian coordinates of the point. This can also be thought of as creating a vector by two points, where the first point is the world origin and the second point is the input point. In the example below, we use PointBySphericalCoordinates to generate a point, then use AsVector to get a vector which we can control using spherical coordinates."
    },
    {
        "Name": "Project",
        "imageFile": [
            "Project"
        ],
        "dynFile": [
            "Project"
        ],
        "folderPath": "Geometry/Point/Action",
        "inDepth": "Project will project a point along a given vector direction onto a specified geometry. The projection is only attempted in the positve direction of the vector. If the vector does not intersect the given geometry, it will return null. In the example below, we create a point using a code block to specify the x,y, and z coordinates. We use a sphere as the geometry to project onto, and the world XAxis as the projection Direction. The output is a point on the surface of the sphere that is projected from the original point."
    },
    {
        "Name": "PruneDuplicates",
        "imageFile": [
            "PruneDuplicates"
        ],
        "dynFile": [
            "PruneDuplicates"
        ],
        "folderPath": "Geometry/Point/Action",
        "inDepth": "Prune Duplicates takes a list of points as an input, and will return a list with duplicate points removed. The tolerance input is used to determine how close two points need to be to be considered duplicates. If two points are closer than the tolerance, the first one in the list will be kept, and the other point removed. In the example, we generate a set of random points. We then use Prune Duplicates with a tolerance of one to remove any points that are closer than one unit to another point."
    },
    {
        "Name": "Subtract",
        "imageFile": [
            "Subtract"
        ],
        "dynFile": [
            "Subtract"
        ],
        "folderPath": "Geometry/Point/Action",
        "inDepth": "Point Subtract will subtract the x,y, and z components of a input vector from the corresponding coordinates of the input point. This is the same as translating the point by the reverse of a given vector. In the example, we create a point using a code block to specify the x,y, and z coordinates, then add a world XAxis vector as the vectorToSubtract. The result is the point translated by a distance of one in the negative-x direction."
    },
    {
        "Name": "X",
        "imageFile": [
            "X"
        ],
        "dynFile": [
            "X"
        ],
        "folderPath": "Geometry/Point/Query",
        "inDepth": "Point X returns the world space X value of an input point. In the example below, we use Point By Spherical Coordinates to create a point who's cartesian coordinate values are not necesarily known in advance, and then use Point X to get the x coordinate."
    },
    {
        "Name": "Y",
        "imageFile": [
            "Y"
        ],
        "dynFile": [
            "Y"
        ],
        "folderPath": "Geometry/Point/Query",
        "inDepth": "Point Y returns the world space Y value of an input point. In the example below, we use Point By Spherical Coordinates to create a point who's cartesian coordinate values are not necesarily known in advance, and then use Point Y to get the y coordinate."
    },
    {
        "Name": "Z",
        "imageFile": [
            "Z"
        ],
        "dynFile": [
            "Z"
        ],
        "folderPath": "Geometry/Point/Query",
        "inDepth": "Point Z returns the world space Z value of an input point. In the example below, we use Point By Spherical Coordinates to create a point who's cartesian coordinate values are not necesarily known in advance, and then use Point Z to get the z coordinate."
    },
    {
        "Name": "ByJoinedCurves",
        "imageFile": ["ByJoinedCurves"],
        "dynFile": ["ByJoinedCurves"],
        "folderPath": "Geometry/PolyCurve/Create",
        "inDepth": "Polycurve By Joined Curves creates joined curves from a set of curves with matching vertices. In this example, a RegularPolygon is exploded into a curve list and is then rejoined into a Polycurve."
    },
    {
        "Name": "ByPoints",
        "imageFile": ["ByPoints"],
        "dynFile": ["ByPoints"],
        "folderPath": "Geometry/PolyCurve/Create",
        "inDepth": "Polycurve By Points creates joined curves from a set of vertices. This node also allows us to toggle between a closed and an open shape. In this example, points are created along a circle and are redrawn with a PolyCurve By Points component, creating a closed polygon shape."
    },
    {
        "Name": "ByThickeningCurve",
        "imageFile": ["ByThickeningCurve"],
        "dynFile": ["ByThickeningCurve"],
        "folderPath": "Geometry/PolyCurve/Create",
        "inDepth": "Polycurve By Thickening Curve is a node that constructs a closed, offset polygon from a single curve. In this node, we can specify the curve being thickened, the overall thickness, and the normal direction of the offset. This example shows how a randomly generated Nurbs Curve is offset perpendicular to its start and end point vector. "
    },
    {
        "Name": "BasePlane",
        "imageFile": [
            "BasePlane"
        ],
        "dynFile": [
            "BasePlane"
        ],
        "folderPath": "Geometry/PolyCurve/Action",
        "inDepth": "Base Plane will return the plane of a planar polycurve. If the curve is not planar, it will give an error. In the example below, we generate a set of random points and use PolyCurve By Points to create a PolyCurve. Because we only used x and y coordinates, the generated polycurve is planar in the world XY plane. "
    },
    {
        "Name": "CloseWithLine",
        "imageFile": [
            "CloseWithLine"
        ],
        "dynFile": [
            "CloseWithLine"
        ],
        "folderPath": "Geometry/PolyCurve/Action",
        "inDepth": "Close With Line adds a straght line between the start and end point of an open PolyCurve. It returns a new polycurve that includes the added line. In the example below, we generate a set of random points and use PolyCuve By Points with the connectLastToFirst input set to false to create an open PolyCurve. Inputting this PolyCurve into Close With Line creates a new closed polycurve (and in this case would be equivalent to using a 'true' input for the connectLastToFirst option in PolyCurve By Points)"
    },
    {
        "Name": "CloseWithLineAndTangentArcs",
        "imageFile": [
            "CloseWithLineAndTangentArcs"
        ],
        "dynFile": [
            "CloseWithLineAndTangentArcs"
        ],
        "folderPath": "Geometry/PolyCurve/Action",
        "inDepth": "CloseWithLineAndTangentArcs will return a line and tangent arcs to close an open PolyCurve. In the example below, a PolyCurve with two segments is closed with a line and arcs. The arcs are defined by whether they are at the start or end of the new line, and their radii can be controlled independently."
    },
    {
        "Name": "CurveAtIndex",
        "imageFile": [
            "CurveAtIndex"
        ],
        "dynFile": [
            "CurveAtIndex"
        ],
        "folderPath": "Geometry/PolyCurve/Action",
        "inDepth": "Curve At Index will return the curve segment at the input index of a given polycurve. If the number of curves in the polycurve is less than the give index, CurveAtIndex will return null. The endOrStart input accepts a boolean value of true or false. If true, CurveAtIndex will begin counting at the first segment of the PolyCurve. If false, it will count backwards from the last segment. In the example below, we generate a set of random points, and then use PolyCurve By Points to create an open PolyCurve. We can then use CurveAtIndex to extract specfic segments from the PolyCurve."
    },
    {
        "Name": "Curves",
        "imageFile": [
            "Curves"
        ],
        "dynFile": [
            "Curves"
        ],
        "folderPath": "Geometry/PolyCurve/Action",
        "inDepth": "Curves will return the indvidual curves that make up a PolyCurve as a list of curves. In the example below, we generate a set of random points, and then use PolyCurve By Points to create an open PolyCurve. We can then use Curves to generate a list of the individual curves."
    },
    {
        "Name": "ExtendWithArc",
        "imageFile": [
            "ExtendWithArc"
        ],
        "dynFile": [
            "ExtendWithArc"
        ],
        "folderPath": "Geometry/PolyCurve/Action",
        "inDepth": "Extend With Arc will add a circular arc to the beginning or end of an input PolyCurve, and returns a single combined PolyCurve. The radius input will determin the radius of the circle, while the length input determines the distance along the circle for the arc. The total length must be less than or equal to length of a complete circle with the given radius. The generated arc will be tangent to the end of the input PolyCurve. A boolean input for endOrStart controls which end of the PolyCurve the arc will be created. A value of 'true' will result in the arc created at the end of the PolyCurve, while 'false' will create the arc at the beginning of the PolyCurve. In the example below, we first use a set of random points and PolyCurve By Points to generate a PolyCurve. We then use two number sliders and a boolean toggle to set the parametrs for ExtendWithArc."
    },
    {
        "Name": "ExtendWithEllipse",
        "imageFile": [
            "ExtendWithEllipse"
        ],
        "dynFile": [
            "ExtendWithEllipse"
        ],
        "folderPath": "Geometry/PolyCurve/Action",
        "inDepth": "ExtendWithEllipse will return an extension of a PolyCurve as a portion of an ellipse. In the example below, a PolyCurve with a single segment is extended into an ellipse. The extension is controlled by two radii, it's length, its end parameter, and whether the start or end of the PolyCurve is being extended."
    },
    {
        "Name": "Fillet",
        "imageFile": [
            "Fillet"
        ],
        "dynFile": [
            "Fillet"
        ],
        "folderPath": "Geometry/PolyCurve/Action",
        "inDepth": "Fillet will return a new PolyCurve with corners filleted to an input radius. In the example below, a closed PolyCurve is returned with its corners filleted to the default radius of 1."
    },
    {
        "Name": "Offset",
        "imageFile": [
            "Offset"
        ],
        "dynFile": [
            "Offset"
        ],
        "folderPath": "Geometry/PolyCurve/Action",
        "inDepth": "Offset will output a Curve that is offset from a given PolyCurve by the given distance. The input PolyCurve must be planar and not self-intersecting in order to be offset. The extendCircular input determines whether cornes in the resulting curve should be sharp or circular. Note that this component returns an output of type Curve, not a PolyCurve. In the example below, we generate a set of random points and use PolyCurve By Points to create a PolyCurve. We then use a Number Slider and a Boolean toggle to control the inputs of Offset. Note that increasing the number of initial points greater than 3 or 4 will often result in a self-intersecting curve, which cannot be offset."
    },
    {
        "Name": "NumberOfCurves",
        "imageFile": [
            "NumberOfCurves"
        ],
        "dynFile": [
            "NumberOfCurves"
        ],
        "folderPath": "Geometry/PolyCurve/Query",
        "inDepth": "Number Of Curves returns the number of curve segments that make up a given PolyCurve. In the example below, we generate a set of random points and use PolyCurve By Points to create a PolyCurve. If connectLastToFirst is left as 'false', then the number of curves will be one less than the number of points. Otherwise, if we create a closed PolyCurve, the number of curves will be equal to the number of initial points."
    },
    {
        "Name": "ByJoinedSurfaces",
        "imageFile": [
            "ByJoinedSurfaces"
        ],
        "dynFile": [
            "ByJoinedSurfaces"
        ],
        "folderPath": "Geometry/PolySurface/Create",
        "inDepth": "ByJoinedSurfaces will return a new PolySurface joined from a list of Surfaces. In the example below, two Surface patches and an extrusion are joined into a PolySurface resembling a cylinder."
    },
    {
        "Name": "ByLoft (crossSections)",
        "imageFile": [
            "ByLoft (crossSections)"
        ],
        "dynFile": [
            "ByLoft (crossSections)"
        ],
        "folderPath": "Geometry/PolySurface/Create",
        "inDepth": "ByLoft (crossSections) will return a new PolySurface by lofting between curves in a list. In the example below, a PolySurface is returned from lofting between two circles."
    },
    {
        "Name": "ByLoft (crossSections, guideCurve)",
        "imageFile": [
            "ByLoft (crossSections, guideCurve)"
        ],
        "dynFile": [
            "ByLoft (crossSections, guideCurve)"
        ],
        "folderPath": "Geometry/PolySurface/Create",
        "inDepth": "ByLoft (crossSections, guideCurve) will return a new PolySurface by lofting between curves in a list and guide Curve. In the example below, a new PolySurface is returned by lofting between two Circles. The returned PolySurface is distorted by adjusting the arc of the guideCurve input."
    },
    {
        "Name": "ByLoftGuides",
        "imageFile": [
            "ByLoftGuides"
        ],
        "dynFile": [
            "ByLoftGuides"
        ],
        "folderPath": "Geometry/PolySurface/Create",
        "inDepth": "ByLoftGuides will return a PolySurface by lofting through a list of PolyCurves (crossSections). In the example below, a PolySurface is created by lofting through three arcs and an arc guideCurve. The arcs give the loft its cross section, and the guideCurve gives the loft a rail to follow."
    },
    {
        "Name": "BySolid",
        "imageFile": [
            "BySolid"
        ],
        "dynFile": [
            "BySolid"
        ],
        "folderPath": "Geometry/PolySurface/Create",
        "inDepth": "BySolid will return a PolySurface from a Solid. In the example below, a Solid is returned as a PolySurface for it to be an acceptable input to Display.BySurfaceColors."
    },
    {
        "Name": "BySweep (rail, crossSection)",
        "imageFile": [
            "BySweep (rail, crossSection)"
        ],
        "dynFile": [
            "BySweep (rail, crossSection)"
        ],
        "folderPath": "Geometry/PolySurface/Create",
        "inDepth": "BySweep (rail, crossSection) will return a PolySurface by sweeping a list of connected, non-intersecting lines along a rail. In the example below, a Line and an Arc form a cross section to sweep along an Arc. The crossSection input can receive a list of connected Curves that must meet at a start or end point, or the node will not return a PolySurface. This node is similar to BySweep (rail, profile) with the only difference being that crossSection takes a list of Curves while profile only takes one."
    },
    {
        "Name": "BySweep (rail, profile)",
        "imageFile": [
            "BySweep (rail, profile)"
        ],
        "dynFile": [
            "BySweep (rail, profile)"
        ],
        "folderPath": "Geometry/PolySurface/Create",
        "inDepth": "BySweep (rail, profile) will return a PolySurface by sweeping a profile along a rail. In the example below, an Arc is swept along another Arc as its rail."
    },
    {
        "Name": "Chamfer",
        "imageFile": [
            "Chamfer"
        ],
        "dynFile": [
            "Chamfer"
        ],
        "folderPath": "Geometry/PolySurface/Action",
        "inDepth": "Chamfer will return a new PolySurface with chamfered edges defined by an offset input. In the example below, a new PolySurface is returned by chamfering the top and bottom edges of a Cylinder by a 0.5 offset. The offset input must be small enough to fit on the PolySurface. This node is similar to PolySurface.Fillet, but returns a PolySurface with new edges."
    },
    {
        "Name": "EdgeCount",
        "imageFile": [
            "EdgeCount"
        ],
        "dynFile": [
            "EdgeCount"
        ],
        "folderPath": "Geometry/PolySurface/Action",
        "inDepth": "EdgeCount will return the number of Edges on a PolySurface. In the example below, an extruded hexagon has an Edge count of 18. The edges are represented as Lines."
    },
    {
        "Name": "ExtractSolids",
        "imageFile": [
            "ExtractSolids"
        ],
        "dynFile": [
            "ExtractSolids"
        ],
        "folderPath": "Geometry/PolySurface/Action",
        "inDepth": "ExtractSolids will return a Solid from a collection of PolySurfaces. In the example below, a Solid is returned from a collection of three surfaces that form a cylinder. Since the node takes a single PolySurface as an input, the three surfaces must be joined together before returning a Solid."
    },
    {
        "Name": "Fillet",
        "imageFile": [
            "Fillet"
        ],
        "dynFile": [
            "Fillet"
        ],
        "folderPath": "Geometry/PolySurface/Action",
        "inDepth": "Fillet will return a new PolySurface with filleted (round) edges defined by a radius input. In the example below, a new Cylinder is returned with its edges rounded to a radius of 0.5. The radius input must be small enough to fit on the PolySurface. This node is similar to PolySurface.Chamfer."
    },
    {
        "Name": "LocateSurfacesByLine",
        "imageFile": [
            "LocateSurfacesByLine"
        ],
        "dynFile": [
            "LocateSurfacesByLine"
        ],
        "folderPath": "Geometry/PolySurface/Action",
        "inDepth": "LocateSurfacesByLine will return all Surface(s) that a Line intersects. In the example below, a line is found to pass through an extruded hexagon at two places and returns two Surfaces. "
    },
    {
        "Name": "LocateSurfacesByPoint",
        "imageFile": [
            "LocateSurfacesByPoint"
        ],
        "dynFile": [
            "LocateSurfacesByPoint"
        ],
        "folderPath": "Geometry/PolySurface/Action",
        "inDepth": "LocateSurfacesByPoint will return the first Surface intersected in the forward direction as defined by a Vector. In the example below, the Surface returned is intersected by a Vector originating at the Point. The Vector is represented as a Line."
    },
    {
        "Name": "SurfaceCount",
        "imageFile": [
            "SurfaceCount"
        ],
        "dynFile": [
            "SurfaceCount"
        ],
        "folderPath": "Geometry/PolySurface/Action",
        "inDepth": "SurfaceCount will return the number of Surfaces in a PolySurface as an integer. In the example below, an extruded hexagon returns a count of 8. The node takes a single PolySurface as an input, so a collection of Surfaces will need to be joined before counting."
    },
    {
        "Name": "Surfaces",
        "imageFile": [
            "Surfaces"
        ],
        "dynFile": [
            "Surfaces"
        ],
        "folderPath": "Geometry/PolySurface/Action",
        "inDepth": "Surfaces will return the Surfaces that make up a PolySurface. In the example below, a extruded hexagon will return eight individual Surfaces."
    },
    {
        "Name": "UnconnectedBoundaries",
        "imageFile": [
            "UnconnectedBoundaries"
        ],
        "dynFile": [
            "UnconnectedBoundaries"
        ],
        "folderPath": "Geometry/PolySurface/Action",
        "inDepth": "UnconnectedBoundaries will return PolyCurves that represent open boundaries. In the example below, an extruded hexagon returns it's top and bottom boundaries as PolyCurves since they are unconnected."
    },
    {
        "Name": "VertexCount",
        "imageFile": [
            "VertexCount"
        ],
        "dynFile": [
            "VertexCount"
        ],
        "folderPath": "Geometry/PolySurface/Action",
        "inDepth": "VertexCount will return the number of Vertices of a PolySurface as an integer. In the example below, an extruded hexagon returns a Vertice count of 12. The Vertices are represented as Points."
    },
    {
        "Name": "ByPoints",
        "imageFile": [
            "ByPoints"
        ],
        "dynFile": [
            "ByPoints"
        ],
        "folderPath": "Geometry/Polygon/Create",
        "inDepth": "Polygon By Points creates a polygon from a list of input points. The points will be connected in the order of the list they originate from. In this example, we create a list of random points driven by a Number slider. The points are then connected with lines in the Polygon By Points Component."
    },
    {
        "Name": "RegularPolygon",
        "imageFile": [
            "RegularPolygon"
        ],
        "dynFile": [
            "RegularPolygon"
        ],
        "folderPath": "Geometry/Polygon/Create",
        "inDepth": "Polygon Regular Polygon is a simple component that will inscribe a regular polygon of any number of sides into a circle. In this example, we create the reference circle from a random Best Fit Through Points and draw a six-sided polygon inside the circle."
    },
    {
        "Name": "Center",
        "imageFile": [
            "Center"
        ],
        "dynFile": [
            "Center"
        ],
        "folderPath": "Geometry/Polygon/Action",
        "inDepth": "Polygon Center finds the center of a given polygon by taking the average value of the corners. For concave polygons, it's possible that the center may actually lie outside the polygon. In the example below, we first generate a list of random angles and radii to use as inputs to Point By Cylindrical Coordinates. By sorting the angles first, we ensure that the resulting polygon will be connected in order of increasing angle, and therefore will not be self-intersecting. We can then use Center to take the average of the points and find the polygon center."
    },
    {
        "Name": "ContainmentTest",
        "imageFile": [
            "ContainmentTest"
        ],
        "dynFile": [
            "ContainmentTest"
        ],
        "folderPath": "Geometry/Polygon/Action",
        "inDepth": "Containment Test returns a boolean value depending on whether a given point is contained inside a given polygon. The polygon must be planar and non-self-intersecting in order for this to work. In the example below, we create a polygon using a series of points created By Cylindrical Coordinates. Leaving the elevation constant, and sorting the angles ensures a planar and non-self-intersecting polygon. We then create a point to test, and use ContainmentTest to see if the point is inside or outside the polygon."
    },
    {
        "Name": "Corners",
        "imageFile": [
            "Corners"
        ],
        "dynFile": [
            "Corners"
        ],
        "folderPath": "Geometry/Polygon/Action",
        "inDepth": "Corners will return a list of points that are the corners of the given polygon. In the example below, we first generate a set of random points sorted by angle to use with Polygon By Points. We can get the points back out as a list by using Corners."
    },
    {
        "Name": "SelfIntersections",
        "imageFile": [
            "SelfIntersections"
        ],
        "dynFile": [
            "SelfIntersections"
        ],
        "folderPath": "Geometry/Polygon/Action",
        "inDepth": "Self Intersections will return a list of all points where a polygon intersects itself. In the example below, we first generate a list of random unsorted angles and radii to use with Points By Cylindrical Coordinates. Because we kept the elevation constant, and did not sort the angles of these points, a polygon created with Polygon By Points will be planar and is likely to be self-intersecting. We can then find the intersection points using Self Intersections"
    },
    {
        "Name": "PlaneDeviation",
        "imageFile": [
            "PlaneDeviation"
        ],
        "dynFile": [
            "PlaneDeviation"
        ],
        "folderPath": "Geometry/Polygon/Query",
        "inDepth": "Plane Deviation will first calculate the best fit plane through the points of a given polygon. It then averages the distance of each point to that plane to find the average deviation of the points of a polygon from the best fit plane. In the example below, we generate a list of random angles, elevations, and radii, and then use Points By Cylindrical Coordinates to create a set of non-planar points to use for Polygon By Points. Inputting this polygon into PlaneDeviation, we can find the average deviation of the points from a best-fit-plane."
    },
    {
        "Name": "Points",
        "imageFile": [
            "Points"
        ],
        "dynFile": [
            "Points"
        ],
        "folderPath": "Geometry/Polygon/Query",
        "inDepth": "Points will return a list of points that are the end points of the segments of the given polygon. In the example below, we first generate a set of random points sorted by angle to use with Polygon By Points. We can get the points back out as a list by using Points."
    },
    {
        "Name": "ByCornerPoints (points)",
        "imageFile": [
            "ByCornerPoints"
        ],
        "dynFile": [
            "ByCornerPoints"
        ],
        "folderPath": "Geometry/Rectangle/Create",
        "inDepth": "The Rectangle By Corner Points node takes a list of four input points and creates a rectangle from them. The input points must reflect a rectangle form. In this example, two Number Sliders are used to create the Points By Coordinates at the rectangle’s vertices. A similar but distinct Rectangle ByCornerPoints node uses four separate inputs for eacher point rather than as a single list. Both nodes are shown in this example."
    },
    {
        "Name": "ByCornerPoints (p1, p2, p3, p4)",
        "imageFile": [
            "ByCornerPoints"
        ],
        "dynFile": [
            "ByCornerPoints"
        ],
        "folderPath": "Geometry/Rectangle/Create",
        "inDepth": "The Rectangle By Corner Points node takes four input points and creates a rectangle from them. The input points must reflect a rectangle form. In this example, two Number Sliders are used to create the Points By Coordinates at the rectangle’s vertices. A similar but distinct Rectangle ByCornerPoints node uses a list of points as the input rather than each input separately. Both nodes are shown in this example."
    },
    {
        "Name": "ByWidthLength (cs, width, length)",
        "imageFile": [
            "ByWidthLength_cwl"
        ],
        "dynFile": [
            "ByWidthLength_cwl"
        ],
        "folderPath": "Geometry/Rectangle/Create",
        "inDepth": "Create a Rectangle centered at the input origin in the CoordinateSystem XY Plane, with specified width (X Axis length), and length (Y Axis length)."
    },
    {
        "Name": "ByWidthLength (plane, width, length)",
        "imageFile": [
            "ByWidthLength_pwl"
        ],
        "dynFile": [
            "ByWidthLength_pwl"
        ],
        "folderPath": "Geometry/Rectangle/Create",
        "inDepth": "Create a Rectangle centered at the origin of the input plane, with specified width (X Axis length), and length (Y Axis length). In the example, we use the world YZ plane as the input plane. The width specifies the plane X Axis length, which in this case corresponds to the world Y axis, and the length specifies the plane Y Axis length which is this case corresponds to the world Z Axis."
    },
    {
        "Name": "ByWidthLength (width, length)",
        "imageFile": [
            "ByWidthLength"
        ],
        "dynFile": [
            "ByWidthLength"
        ],
        "folderPath": "Geometry/Rectangle/Create",
        "inDepth": "The Rectangle By Width Length node creates a rectangle on the Z-base plane with a specified length and width dimension. The center of the rectangle will be located at the grid origin. In this example, we use two Number Sliders to drive the shape of the rectangle. "
    },
    {
        "Name": "Height",
        "imageFile": [
            "Height"
        ],
        "dynFile": [
            "Height"
        ],
        "folderPath": "Geometry/Rectangle/Query",
        "inDepth": "Height will output the height of an input rectangle. The height output is the same as the length input for Rectangle.Create nodes. The height is the dimension in the Y-axis of the plane or coordinate system of the rectangle. The example below uses four points to create a rectangle, then shows both Width and height nodes to find the dimensions of the rectangle."
    },
    {
        "Name": "Width",
        "imageFile": [
            "Width"
        ],
        "dynFile": [
            "Width"
        ],
        "folderPath": "Geometry/Rectangle/Query",
        "inDepth": "Width will output the width of an input rectangle. The width is the dimension in the X-axis of the plane or coordinate system of the rectangle. The example below uses four points to create a rectangle, then shows both Width and Length nodes to find the dimensions of the rectangle."
    },
    {
        "Name": "ByJoinedSurfaces",
        "imageFile": [
            "ByJoinedSurfaces"
        ],
        "dynFile": [
            "ByJoinedSurfaces"
        ],
        "folderPath": "Geometry/Solid/Create",
        "inDepth": "Solid by Joined Surfaces takes a list of surfaces as an input and will return a single solid defined by the surfaces. The surfaces must define a closed surface. In the example below, we start with a circle as a base geometry. The circle is patched to create a surface, and that surface is translated in the z-direction. We then extrude the circle to produce the sides. List.Create is used to make a list consisting of the base, side, and top surfaces, and then we use ByJoinedSurfaces to turn the list into a single closed solid."
    },
    {
        "Name": "ByLoft (crossSections, guideCurves)",
        "imageFile": [
            "ByLoft_guideCurves"
        ],
        "dynFile": [
            "ByLoft_guideCurves"
        ],
        "folderPath": "Geometry/Solid/Create",
        "inDepth": "ByLoft with crossSections and guideCurves allows us to input a list of guide curves to produce different profiles along the perimeter of a lofted solid. In the example below, we use two offset rectangles as the crossSections. Two different guide curves are generate around the perimeter, one based on a Cosine function, and the other a simple line."
    },
    {
        "Name": "ByLoft (crossSections, guideCurve)",
        "imageFile": [
            "ByLoft_guideCurve"
        ],
        "dynFile": [
            "ByLoft_guideCurve"
        ],
        "folderPath": "Geometry/Solid/Create",
        "inDepth": "ByLoft with crossSections and guideCurve will create a solid by lofting between the input list of closed Cross Section curves. A guide Curve is provided to control the profile of the loft, rather than just lofting as a straight line. In the example below, we start with a rectangle as the base. The rectangle is translated, and then combined with the original into a list to provide the list of cross sections for ByLoft. A set of points is created using a cosine function to control the coordinates, and used to create a NurbsCurve ByPoints. ByLoft is used with the list of rectangles as the crossSections, and the NurbsCurve as the guide, producing a solid with rectangular cross sections, and a wave profile."
    },
    {
        "Name": "ByLoft (crossSections)",
        "imageFile": [
            "ByLoft"
        ],
        "dynFile": [
            "ByLoft"
        ],
        "folderPath": "Geometry/Solid/Create",
        "inDepth": "ByLoft with crossSections takes a list of closed curves as an input. It will produce a solid by lofting between the list of curves in order. In the example below, we start with a circle. We then produce a series of translated circles based on a sine curve. This list of curves is used as the input for ByLoft."
    },
    {
        "Name": "ByRevolve",
        "imageFile": [
            "ByRevolve"
        ],
        "dynFile": [
            "ByRevolve"
        ],
        "folderPath": "Geometry/Solid/Create",
        "inDepth": "Solid by Revolve creates a surface by rotating a given profile curve around an axis. The axis is defined by an axisOrigin point, and an axisDirection vector. The start angle determines where to begin the surface, measured in degrees, and the sweepAngle determines how far around the axis to continue the surface. In the example below, we use a curve generated with a cosine function as the profile curve, and two number sliders to control the startAngle and sweepAngle. The axisOrigin and axisDirection are left at the default values of the world origin and world z-axis for this example."
    },
    {
        "Name": "BySweep",
        "imageFile": [
            "BySweep"
        ],
        "dynFile": [
            "BySweep"
        ],
        "folderPath": "Geometry/Solid/Create",
        "inDepth": "Solid By Sweep will create a solid by sweeping an input closed profile curve along a specified path. In the example below, we use a rectangle as the base profile curve. The path is created by using a cosine function with a sequence of angles to vary the x-coordinates of a set of points. The points are used as the input to a NurbsCurve by Points node. We then create a solid by sweeping the rectangle along the created cosine curve."
    },
    {
        "Name": "BySweep2Rails",
        "imageFile": [
            "BySweep2Rails"
        ],
        "dynFile": [
            "BySweep2Rails"
        ],
        "folderPath": "Geometry/Solid/Create",
        "inDepth": "BySweep2Rails will return a new Solid from a curve profile swept along two curve rails. In the example below, a new Solid is returned from sweeping a circle along two arcs as rails. Switching the arc inputs in rail1 and rail2 will change which arc the sweep is perpendicular to."
    },
    {
        "Name": "ByUnion",
        "imageFile": [
            "ByUnion"
        ],
        "dynFile": [
            "ByUnion"
        ],
        "folderPath": "Geometry/Solid/Create",
        "inDepth": "Solid by Union will create a single new solid out of the union of a list of closed solids. The union is the combination of both solids, and the new solid will include all of the volume of the original solids. In the example below, we use a set of number sliders to control the position and radius of a sphere. We also use a default cuboid. We use a List.Create node to put both the cube and the sphere into a single list, which we use as the input for Solid ByUnion node."
    },
    {
        "Name": "Centroid",
        "imageFile": [
            "Centroid"
        ],
        "dynFile": [
            "Centroid"
        ],
        "folderPath": "Geometry/Solid/Action",
        "inDepth": "Centroid will return a point that is at the centroid of a solid. The centroid can be thought of as the center of mass of an solid object. Note that it is possible for the center of mass to exist outside the actual solid. In the example below, we use a set of circles to create a Solid ByLoft, and input the resulting solid into a Centroid node."
    },
    {
        "Name": "Chamfer",
        "imageFile": [
            "Chamfer"
        ],
        "dynFile": [
            "Chamfer"
        ],
        "folderPath": "Geometry/Solid/Action",
        "inDepth": "Chamfer will return a new solid with chamfered edges. The edges input specifies which edges to chamfer, while the offset input determines the extent of the chamfer. In the example below, we start with a cube using the default inputs. To get the appropriate edges of the cube, we first explode the cube to get the faces as a list of surfaces. We then use a Face.Edges node to extract the edges of the cube. We extract the first edge of each face with GetItemAtIndex. A number slider controls the offset distance for the chamfer."
    },
    {
        "Name": "Difference",
        "imageFile": [
            "Difference"
        ],
        "dynFile": [
            "Difference"
        ],
        "folderPath": "Geometry/Solid/Action",
        "inDepth": "Difference will create a new solid by subtracting one solid from another. The 'solid' input indicates the solid to subtract from, while the 'tool' input is the solid that will be subtracted. In the example below, we start with a default cube as the solid we are going to subtract from. We use a series of number sliders to control the position and radius of a sphere, which we use as the tool. If the sphere is intersecting the cube, then the result is a cube with the intersecting part of the sphere subtracted from it."
    },
    {
        "Name": "DifferenceAll",
        "imageFile": [
            "DifferenceAll"
        ],
        "dynFile": [
            "DifferenceAll"
        ],
        "folderPath": "Geometry/Solid/Action",
        "inDepth": "Difference All will create a new solid by subtracting a list of solids from one single solid. The 'solid' input indicates the solid to subtract from, while the 'tools' input is the list of solids that will be subtracted. The solids in this list will be unioned together to create a single solid, which is then subtracted from the 'solid' input. In the example below, we start with a default cube as the solid we are going to subtract from. We use a series of number sliders to control the position and radius of a sphere. By using a sequence of numbers as the z-coordinate, we create a list of several spheres. If the spheres are intersecting the cube, then the result is a cube with the intersecting parts of the spheres subtracted from it."
    },
    {
        "Name": "Fillet",
        "imageFile": [
            "Fillet"
        ],
        "dynFile": [
            "Fillet"
        ],
        "folderPath": "Geometry/Solid/Action",
        "inDepth": "Fillet will return a new solid with rounded edges. The edges input specifies which edges to fillet, while the offset input determines the radius of the fillet. In the example below, we start with a cube using the default inputs. To get the appropriate edges of the cube, we first explode the cube to get the faces as a list of surfaces. We then use a Face.Edges node to extract the edges of the cube. We extract the first edge of each face with GetItemAtIndex. A number slider controls the radius for each fillet."
    },
    {
        "Name": "ProjectInputOnto",
        "imageFile": [
            "ProjectInputOnto"
        ],
        "dynFile": [
            "ProjectInputOnto"
        ],
        "folderPath": "Geometry/Solid/Action",
        "inDepth": "Project Input Onto will proect an input geometry onto a given solid, using the projectDirection vector as the axis for projection. In the example below, we first create a solid to project onto by lofting a sequence of circles together with ByLoft. The geometry we are projecting is a vertical circle created next to the solid. We use the world YAxis as the projectDirection. The result is a curve that has been projected onto the irregular solid."
    },
    {
        "Name": "ThinShell",
        "imageFile": [
            "ThinShell"
        ],
        "dynFile": [
            "ThinShell"
        ],
        "folderPath": "Geometry/Solid/Action",
        "inDepth": "Thin Shell will create a new solid by offsetting the surfaces that make up the input solid. This can also be thought of as thickening the surfaces of the input solid. In the example below, we use a chamfered cube as our input solid. We have two number sliders to control the inner and outer thicknesses of the shell faces."
    },
    {
        "Name": "Union",
        "imageFile": [
            "Union"
        ],
        "dynFile": [
            "Union"
        ],
        "folderPath": "Geometry/Solid/Action",
        "inDepth": "Union will create a new solid by adding one solid to another. The 'solid' input indicates the solid to add to, while the 'tool' input is the solid that will be added. In the example below, we start with a default cube as the solid we are going to add to. We use a series of number sliders to control the position and radius of a sphere, which we use as the tool. If the sphere is intersecting the cube, then the result is a cube with the intersecting part of the sphere added to it."
    },
    {
        "Name": "UnionAll",
        "imageFile": [
            "UnionAll"
        ],
        "dynFile": [
            "UnionAll"
        ],
        "folderPath": "Geometry/Solid/Action",
        "inDepth": "Union All will create a new solid by adding a list of solids to one single solid. The 'solid' input indicates the solid to add to, while the 'tools' input is the list of solids that will be added. The solids in this list will be unioned together to create a single solid, which is then added to the 'solid' input. In the example below, we start with a default cube as the solid we are going to add to. We use a series of number sliders to control the position and radius of a sphere. By using a sequence of numbers as the z-coordinate, we create a list of several spheres. If the spheres are intersecting the cube, then the result is a cube with the intersecting parts of the spheres added to it."
    },
    {
        "Name": "Area",
        "imageFile": [
            "Area"
        ],
        "dynFile": [
            "Area"
        ],
        "folderPath": "Geometry/Solid/Query",
        "inDepth": "Volume will return the surface area of a given solid. In the example below, we start with a cube, and then chamfer the edges to produce a new solid. We can use Area to find the total area of all the surfaces of this solid."
    },
    {
        "Name": "Volume",
        "imageFile": [
            "Volume"
        ],
        "dynFile": [
            "Volume"
        ],
        "folderPath": "Geometry/Solid/Query",
        "inDepth": "Volume will return the volume of a given solid. In the example below, we start with a cube, and then chamfer the edges to produce a new solid. We can use Volume to find the new volume of this solid."
    },
    {
        "Name": "ByBestFit",
        "imageFile": [
            "ByBestFit"
        ],
        "dynFile": [
            "ByBestFit"
        ],
        "folderPath": "Geometry/Sphere/Create",
        "inDepth": "Sphere by Best Fit will create a sphere based on a list of points as input. The sphere will be created to minimize the average distance from the list of points to the surface of the sphere. In the example below, we generate a set of random numbers to use as x,y, and z coordinates for a list of points. The number of points is controlled by an integer slider. The list of points is used as the input for a Sphere ByBestFit node."
    },
    {
        "Name": "ByCenterPointRadius",
        "imageFile": [
            "ByCenterPointRadius"
        ],
        "dynFile": [
            "ByCenterPointRadius"
        ],
        "folderPath": "Geometry/Sphere/Create",
        "inDepth": "Sphere by Center Point Radius will create a sphere centered at the input point, and with an input radius. In the example below, we use a code block to specify the coordinates of a Point created by coordinates, and we use a number slider to determine the radius of the sphere."
    },
    {
        "Name": "ByFourPoints",
        "imageFile": [
            "ByFourPoints"
        ],
        "dynFile": [
            "ByFourPoints"
        ],
        "folderPath": "Geometry/Sphere/Create",
        "inDepth": "ByFourPoints will return a Sphere from four input Points on the Surface. In the example below, two Spheres are created from a collection of six Points. Adjusting the X Position and Y Position sliders will change the size of each Sphere relative to the other. It is important to note that not any collection of four points will make a Sphere. It has to be possible for all Points to be on the Sphere's surface."
    },
    {
        "Name": "CenterPoint",
        "imageFile": [
            "CenterPoint"
        ],
        "dynFile": [
            "CenterPoint"
        ],
        "folderPath": "Geometry/Sphere/Query",
        "inDepth": "Center Point will return the center of an input sphere. In the example below, we use a ByBestFit node to create a sphere based on a set of random points. We then use a CenterPoint node to determine the center of the best fit sphere."
    },
    {
        "Name": "Radius",
        "imageFile": [
            "Radius"
        ],
        "dynFile": [
            "Radius"
        ],
        "folderPath": "Geometry/Sphere/Query",
        "inDepth": "Radius will return the center of an input sphere. In the example below, we use a ByBestFit node to create a sphere based on a set of random points. We then use a Radius node to determine the size of the best fit sphere."
    },
    {
        "Name": "ByLoft (crossSections, guideCurves)",
        "imageFile": [
            "ByLoft_gcs"
        ],
        "dynFile": [
            "ByLoft_gcs"
        ],
        "folderPath": "Geometry/Surface/Create",
        "inDepth": "Surface by Loft with cross sections and guide curves takes a list of cross sections to loft between, and a separate list of guide curves to determine the profile of the loft. In the example below, we use two straight lines as the input cross sections. For the guide curves, we create one sine curve and one straight line. A number slider controls the distance between the sine curve and the straight line. The resulting loft interpolates between the sine curve and the straight line."
    },
    {
        "Name": "ByLoft (crossSections, guideCurve)",
        "imageFile": [
            "ByLoft_gc"
        ],
        "dynFile": [
            "ByLoft_gc"
        ],
        "folderPath": "Geometry/Surface/Create",
        "inDepth": "Surface by Loft with cross sections and guide curves uses an extra input in addition to a list of cross sections to loft. This extra curve is a guide curve that directs the lofted surface. In the example below, we use two straight lines as the input cross sections. We create a sine curve to use as a guide curve. By using the guide curve, we create a surface with a sine curve profile, instead of just a flat surface lofted directly between the two cross section lines. "
    },
    {
        "Name": "ByLoft (crossSections)",
        "imageFile": [
            "ByLoft"
        ],
        "dynFile": [
            "ByLoft"
        ],
        "folderPath": "Geometry/Surface/Create",
        "inDepth": "Surface ByLoft with cross sections takes a list of curves as an input. It will produce a surface by lofting between the list of curves in order. In the example below we create two curves, a line and a sine curve. We use List.Create to combine these two curves into a list, which we use as an input for Surface ByLoft. The result is a surface that is lofted between a sine curve on one side, and a line on the other."
    },
    {
        "Name": "ByPatch",
        "imageFile": [
            "ByPatch"
        ],
        "dynFile": [
            "ByPatch"
        ],
        "folderPath": "Geometry/Surface/Create",
        "inDepth": "Surface by Patch will create a surface by filling in the interior of a closed curve. In the example below, we first create a closed Nurbs Curve by using a series of points created with cylindrical coordines. A number slider controls the number of points to create, while a boolean toggle node controls whether the Nurbs Curve is closed on not. We use the Nurbs Curve as the input to a Surface ByPatch node, creating a surface on the inside of the closed curve."
    },
    {
        "Name": "ByPerimeterPoints",
        "imageFile": [
            "ByPerimeterPoints"
        ],
        "dynFile": [
            "ByPerimeterPoints"
        ],
        "folderPath": "Geometry/Surface/Create",
        "inDepth": "Surface by Perimeter Points takes a list of points that defines the perimeter of a closed polygon, and creates a surface inside the resulting polygon. In the example below we create a series of points using cylindrical coordinates. The points are created at regular intervals around a cylinder with randomized inputs for the radius and elevation. The resulting list of points is used as the input for a Surface ByPerimeterPoints node."
    },
    {
        "Name": "ByRevolve",
        "imageFile": [
            "ByRevolve"
        ],
        "dynFile": [
            "ByRevolve"
        ],
        "folderPath": "Geometry/Surface/Create",
        "inDepth": "Surface by Revolve creates a surface by rotating a given profile curve around an axis. The axis is defined by an axisOrigin point, and an axisDirection vector. The start angle determines where to begin the surface, measured in degrees, and the sweepAngle determines how far around the axis to continue the surface. In the example below, we use a curve generated with a cosine function as the profile curve, and two number sliders to control the startAngle and sweepAngle. The axisOrigin and axisDirection are left at the default values of the world origin and world z-axis for this example"
    },
    {
        "Name": "ByRuledLoft",
        "imageFile": [
            "ByRuledLoft"
        ],
        "dynFile": [
            "ByRuledLoft"
        ],
        "folderPath": "Geometry/Surface/Create",
        "inDepth": "Surface by Ruled Loft takes an ordered list of curves as an input and lofts a straigth-line ruled surface between the curves. Compared to ByLoft, ByRuledLoft can be slightly faster, but the resulting surface is less smooth. In the example below, we start with a line along the X-axis. We translate this line into a series of lines that follow a sine curve in the y-direction. Using this resulting list of lines as the input for a Surface ByRuledLoft results in a surface with straight-line segments between the input curves."
    },
    {
        "Name": "BySweep",
        "imageFile": [
            "BySweep"
        ],
        "dynFile": [
            "BySweep"
        ],
        "folderPath": "Geometry/Surface/Create",
        "inDepth": "Surface by Sweep will create a surface by sweeping an input curve along a specfied path. In the example below, we use a sine curve in the y-direction as the profile curve. We rotate this curve by -90 degrees around the world z-axis to use as a path curve. Surface BySweep moves the profile curve along the path curve creating a surface."
    },
    {
        "Name": "BySweep2Rails",
        "imageFile": [
            "BySweep2Rails"
        ],
        "dynFile": [
            "BySweep2Rails"
        ],
        "folderPath": "Geometry/Surface/Create",
        "inDepth": "Surface by Sweep 2 Rails takes an input curve and uses two guide curves to sweep the profile curve along. In the example below, we use a half-circle as the input profile. We create two diverging lines to use as the rail curves for a BySweep2Rails node. The result is a surface with a half-circle profile that grows as the arc moves along the diverging lines."
    },
    {
        "Name": "ApproximateWithTolerance",
        "imageFile": [
            "ApproximateWithTolerance"
        ],
        "dynFile": [
            "ApproximateWithTolerance"
        ],
        "folderPath": "Geometry/Surface/Action",
        "inDepth": "Approximate with Tolerance will create a Nurbs Surface that approximates an input surface. The tolerance input determines how accurately the result will match the original surface. In the example below, we create a surface using a ByPatch node with a close Nurbs Curve as an input. Note that when we use this surface as the input for a ApproximateWithTolerance node, the result is an untrimmed Nurbs Surface with four sides."
    },
    {
        "Name": "CoordinateSystemAtParameter",
        "imageFile": [
            "CoordinateSystemAtParameter"
        ],
        "dynFile": [
            "CoordinateSystemAtParameter"
        ],
        "folderPath": "Geometry/Surface/Action",
        "inDepth": "Coordinate System at Parameter uses U and V input parameters and returns a coordinate system. The x-axis, y-axis, and z-axis of the Coordinate System are determined by the Normal direction, U direction, and V direction, respectively. In the example below, we first create a surface by using a BySweep2Rails. We then use two number sliders to determine the U and V parameters to create a Coordinate System with a CoordnateSystemAtParameter node."
    },
    {
        "Name": "CurvatureAtParameter",
        "imageFile": [
            "CurvatureAtParameter"
        ],
        "dynFile": [
            "CurvatureAtParameter"
        ],
        "folderPath": "Geometry/Surface/Action",
        "inDepth": "Curvature At Parameter uses U and V input parameters and returns a coordinate system based on the normal, U direction, and V direction at the UV position on the surface. The Normal vector determines the z-axis, while the U and V directions determine the direction of the X and Y axes. The length of the axes are determined by the U and V curvature. In the example below, we first create a surface by using a BySweep2Rails. We then use two number sliders to determine the U and V parameters to create a Coordinate System with a CurvatureAtParameter node."
    },
    {
        "Name": "DerivativesAtParameter",
        "imageFile": [
            "DerivativesAtParameter"
        ],
        "dynFile": [
            "DerivativesAtParameter"
        ],
        "folderPath": "Geometry/Surface/Action",
        "inDepth": "Derivatives At Parameter uses U and V input parameters and returns the U and V derivaties of the surface at the input UV position on the surface. The derivatives are returned as a list of two vectors, with the first vector being the U derivative and the second vector being the V derivative. In the example below, we first create a surface by using a BySweep2Rails. We then use two number sliders to determine the U and V parameters to determine the derivatives with a DerivativesAtParameter node. "
    },
    {
        "Name": "FlipNormalDirection",
        "imageFile": [
            "FlipNormalDirection"
        ],
        "dynFile": [
            "FlipNormalDirection"
        ],
        "folderPath": "Geometry/Surface/Action",
        "inDepth": "Flip Normal Direction will flip the direction of the normal vectors of a surface. In the example below, we first create a surface by using a BySweep2Rails. The Normal direction of this surface points up in the positive z-direction. By usinging a FlipNormalDirection node, we create a new surface with the same geometry, but with the normals pointing down in the negative z-direction."
    },
    {
        "Name": "GaussianCurvatureAtParameter",
        "imageFile": [
            "GaussianCurvatureAtParameter"
        ],
        "dynFile": [
            "GaussianCurvatureAtParameter"
        ],
        "folderPath": "Geometry/Surface/Action",
        "inDepth": "Gaussian Curvature At Parameter uses U and V input parameters and returns the curvature of the surface at the input UV position of the surface. The Gaussian Curvature is calculated as the product of the two principal curvatures (in the U and V directions). In the example below, we first create a surface by using a BySweep2Rails. We then use two number sliders to determine the U and V parameters to find the gaussian curvature with a GaussianCurvatureAtParameter node."
    },
    {
        "Name": "GetIsoline",
        "imageFile": [
            "GetIsoline"
        ],
        "dynFile": [
            "GetIsoline"
        ],
        "folderPath": "Geometry/Surface/Action",
        "inDepth": "Get Isoline will return the isoline of a surface at an input U or V parameter. The input isoDirection is used to determine whether the U direction or V direction is used. An isoDirection of 0 corresponds to the U direction, while an isoDirection of 1 corresponds to the V direction. In the example below, we first create a surface by using a BySweep2Rails. We then use two number sliders. The first slider controls the U or V direction of the isolines, while the second determines the parameter to find the isoline of."
    },
    {
        "Name": "Join (surface, otherSurfaces)",
        "imageFile": [
            "Join (surface, otherSurfaces)"
        ],
        "dynFile": [
            "Join (surface, otherSurfaces)"
        ],
        "folderPath": "Geometry/Surface/Action",
        "inDepth": "Join (surface, otherSurfaces) will return a single PolySurface by joining one Surface will a collection of others. In the example below, an extruded Surface is joined with a Surface that matches it's profile returning a PolySurface."
    },
    {
        "Name": "Join (surface, otherSurface)",
        "imageFile": [],
        "dynFile": [],
        "folderPath": "Geometry/Surface/Action",
        "inDepth": "Add in-depth information about Join (surface, otherSurface)..."
    },
    {
        "Name": "NormalAtParameter",
        "imageFile": [
            "NormalAtParameter"
        ],
        "dynFile": [
            "NormalAtParameter"
        ],
        "folderPath": "Geometry/Surface/Action",
        "inDepth": "Normal At Parameter uses U and V input parameters and returns the Normal vector of the surface at the input UV position on the surface. In the example below, we first create a surface by using a Sweep2Rails. We then use two number sliders to determine the U and V parameters to determine the Normal with a NormalAtParameter node."
    },
    {
        "Name": "NormalAtPoint",
        "imageFile": [
            "NormalAtPoint"
        ],
        "dynFile": [
            "NormalAtPoint"
        ],
        "folderPath": "Geometry/Surface/Action",
        "inDepth": "Normal At Point finds the Normal vector of the surface at the input point on a surface. If the input point is not on the surface, this node will find the point on the surface that is nearest to the input point. In the example below, we first create a surface by using a BySweep2Rails. We then use a Code Block to specify a point to find the normal at. The point is not on the surface, so the node uses the closest point on the surface as the position to find the normal at."
    },
    {
        "Name": "Offset",
        "imageFile": [
            "Offset"
        ],
        "dynFile": [
            "Offset"
        ],
        "folderPath": "Geometry/Surface/Action",
        "inDepth": "Offset will create a new surface that is offset from the input surface at distance specified by the distance input. A positive distance will create the offset surface according to the Normal direction of the surface, while a negative distance will result in the offset on the opposite side of the surface. In the example below, we first create a surface by using a BySweep2Rails node. We then use a number slider to control the distance of the offset in an Offset node."
    },
    {
        "Name": "PerimeterCurves",
        "imageFile": [
            "PerimeterCurves"
        ],
        "dynFile": [
            "PerimeterCurves"
        ],
        "folderPath": "Geometry/Surface/Action",
        "inDepth": "Perimeter Curves will return the edge curves of an open surface as a list of curves. In the example below, we first create a surface by using a BySweep2Rails node. We then extract the perimeter edges by using a PerimeterCurves node. "
    },
    {
        "Name": "PointAtParameter",
        "imageFile": [
            "PointAtParameter"
        ],
        "dynFile": [
            "PointAtParameter"
        ],
        "folderPath": "Geometry/Surface/Action",
        "inDepth": "Point At Parameter will return the point on a surface specified by U and V parameters. In the example below, we first create a surface by using a BySweep2Rails node. We then use two number sliders to control the U and V values of the parameter for a PointAtParameter node."
    },
    {
        "Name": "PrincipalCurvaturesAtParameter",
        "imageFile": [
            "PrincipalCurvaturesAtParameter"
        ],
        "dynFile": [
            "PrincipalCurvaturesAtParameter"
        ],
        "folderPath": "Geometry/Surface/Action",
        "inDepth": "Principal Curvatures at Parameter uses U and V input parameters and returns the curvatures in the U and V directions. This node returns a list of two numbers, with the first being the curvature in the U direction and the second being the curvature in the V direction. In the example below, we first create a surface by using a BySweep2Rails. We then use two number sliders to determine the U and V parameters to find the curvatures using a PrincipalCurvaturesAtParameter node."
    },
    {
        "Name": "PrincipalDirectionsAtParameter",
        "imageFile": [
            "PrincipalDirectionsAtParameter"
        ],
        "dynFile": [
            "PrincipalDirectionsAtParameter"
        ],
        "folderPath": "Geometry/Surface/Action",
        "inDepth": "Principal Directions at Parameter uses U and V input parameters and returns the curvatures in the U and V directions. This node returns a list of two vectors, with the first being the direction vector in the U direction and the second being the direction vector in the V direction. In the example below, we first create a surface by using a BySweep2Rails. We then use two number sliders to determine the U and V parameters to find the directions using a PrincipalDirectionsAtParameter node."
    },
    {
        "Name": "ProjectInputOnto",
        "imageFile": [
            "ProjectInputOnto"
        ],
        "dynFile": [
            "ProjectInputOnto"
        ],
        "folderPath": "Geometry/Surface/Action",
        "inDepth": "Project Input Onto will project an input geometry onto a given surface along a given direction. In the example below, we first create a surface by using a BySweep2Rails. This is the surface we will project onto. We make a circle at the origin to use as the geometry to project, and simply use the world Z-direction as the direction vector for projection. The result is a circle projected onto the surface."
    },
    {
        "Name": "SubtractFrom",
        "imageFile": [
            "SubtractFrom"
        ],
        "dynFile": [
            "SubtractFrom"
        ],
        "folderPath": "Geometry/Surface/Action",
        "inDepth": "Subtract From will create a new surface by subtracting the input trimming geometry from they input surface. In the example below, we first create a surface by using a BySweep2Rails. We then use a series of number slider to contrel the length, width, and height of a cuboid. By using a SubtractFrom node, we can trim the surface by subracting out the area that intersects with the cuboid."
    },
    {
        "Name": "TangentAtUParameter",
        "imageFile": [
            "TangentAtUParameter"
        ],
        "dynFile": [
            "TangentAtUParameter"
        ],
        "folderPath": "Geometry/Surface/Action",
        "inDepth": "Tangent at U Parameter will return the tangent vector in the U direction at a specified UV position on a surface.  In the example below, we first create a surface by using a BySweep2Rails. We then use two number sliders to determine the U and V parameters to find the U tangent vector."
    },
    {
        "Name": "TangentAtVParameter",
        "imageFile": [
            "TangentAtVParameter"
        ],
        "dynFile": [
            "TangentAtVParameter"
        ],
        "folderPath": "Geometry/Surface/Action",
        "inDepth": "Tangent at U Parameter will return the tangent vector in the V direction at a specified UV position on a surface.  In the example below, we first create a surface by using a BySweep2Rails. We then use two number sliders to determine the U and V parameters to find the V tangent vector."
    },
    {
        "Name": "Thicken (surface, thickness, both_sides)",
        "imageFile": [
            "Thicken_bothSides"
        ],
        "dynFile": [
            "Thicken_bothSides"
        ],
        "folderPath": "Geometry/Surface/Action",
        "inDepth": "Thicken will create a solid by offsetting a surface according to the thickness input and capping the ends to close the solid. This Thicken node has an extra input to specify whether to thicken on both sides or not. The both_sides input takes a boolean value. In the example below, we first create a surface by using a BySweep2Rails. We then create a solid by using a number slider to dermine the thickness input of a Thicken node. A boolean toggle controls whether to thicken on both sides or just one. Note that the thickness parameter determines the total thickness of the final solid, so if both_sides is set to true, the result will be offset from the original surface by half the input thickness on both sides."
    },
    {
        "Name": "Thicken (surface, thickness)",
        "imageFile": [
            "Thicken"
        ],
        "dynFile": [
            "Thicken"
        ],
        "folderPath": "Geometry/Surface/Action",
        "inDepth": "Thicken will create a solid by offsetting a surface according to the thickness input and capping the ends to close the solid. In  the example below, we first create a surface by using a BySweep2Rails. We then create a solid by using a number slider to dermine the thickness input of a Thicken node."
    },
    {
        "Name": "ToNurbsSurface",
        "imageFile": [
            "ToNurbsSurface"
        ],
        "dynFile": [
            "ToNurbsSurface"
        ],
        "folderPath": "Geometry/Surface/Action",
        "inDepth": "Surface To Nurbs Surface takes a surface as input and returns a Nurbs Surface that approximates the input surface. In the example below, we create a surface using a ByPatch node with a close Nurbs Curve as an input. Note that when we use this surface as the input for a ToNurbsSurface node, the result is an untrimmed Nurbs Surface with four sides."
    },
    {
        "Name": "TrimWithEdgeLoops",
        "imageFile": [
            "TrimWithEdgeLoops"
        ],
        "dynFile": [
            "TrimWithEdgeLoops"
        ],
        "folderPath": "Geometry/Surface/Action",
        "inDepth": "TrimWithEdgeLoops will return a new Surface trimmed from an input Surface. In the example below, two loops are trimmed out of a Surface, returning two new Surfaces highlighted in blue. The number slider will adjust the shape of the new Surfaces. The loops input will take a single PolyCurve or a list of them."
    },
    {
        "Name": "UVParameterAtPoint",
        "imageFile": [
            "UVParameterAtPoint"
        ],
        "dynFile": [
            "UVParameterAtPoint"
        ],
        "folderPath": "Geometry/Surface/Action",
        "inDepth": "UV Parameter At Point finds the UV position of the surface at the input point on a surface. If the input point is not on the surface, this node will find the point on the surface that is nearest to the input point. In the example below, we first create a surface by using a BySweep2Rails. We then use a Code Block to specify a point to find the UN parameter at. The point is not on the surface, so the node uses the closest point on the surface as the position to find the UV parameter of."
    },
    {
        "Name": "Area",
        "imageFile": [
            "Area"
        ],
        "dynFile": [
            "Area"
        ],
        "folderPath": "Geometry/Surface/Query",
        "inDepth": "Area will return the area of a surface as a double. In the example below, a surface extruded from a circle with radius 5 to a height of 3 returns an area of ~94.25."
    },
    {
        "Name": "Closed",
        "imageFile": [
            "Closed"
        ],
        "dynFile": [
            "Closed"
        ],
        "folderPath": "Geometry/Surface/Query",
        "inDepth": "Closed will return a boolean value based on whether a Surface is closed in it's U or V directions. In the example below, two extruded Surfaces are tested, and the extruded circle returns true. By adjusting the number slider, the extruded arc will close into a circle and also return true."
    },
    {
        "Name": "ClosedInU",
        "imageFile": [
            "ClosedInU"
        ],
        "dynFile": [
            "ClosedInU"
        ],
        "folderPath": "Geometry/Surface/Query",
        "inDepth": "ClosedInU will return a boolean value based on whether a Surface is closed in it's U direction. In the example below, an extruded circle that is closed in one direction returns false for being closed in U."
    },
    {
        "Name": "ClosedInV",
        "imageFile": [
            "ClosedInV"
        ],
        "dynFile": [
            "ClosedInV"
        ],
        "folderPath": "Geometry/Surface/Query",
        "inDepth": "ClosedInV will return a boolean value based on whether a Surface is closed in it's V direction. In the example below, an extruded circle that is closed in one direction returns true for being closed in V"
    },
    {
        "Name": "Perimeter",
        "imageFile": [
            "Perimeter"
        ],
        "dynFile": [
            "Perimeter"
        ],
        "folderPath": "Geometry/Surface/Query",
        "inDepth": "Perimeter will return the length of a Surface's perimeter as a double. In the example below, a complex NurbsSurface's perimeter returns a value of 36.432."
    },
    {
        "Name": "ByPoints",
        "imageFile": [
            "ByPoints"
        ],
        "dynFile": [
            "ByPoints"
        ],
        "folderPath": "Geometry/Tessellation/ConvexHull/Action",
        "inDepth": "ByPoints will return a list of curves that represent the convex hull of a set of Points. In the example below, a list of points randomly placed in 3D returns a list of curves representing their convex hull."
    },
    {
        "Name": "ByParametersOnSurface",
        "imageFile": [
            "ByParametersOnSurface"
        ],
        "dynFile": [
            "ByParametersOnSurface"
        ],
        "folderPath": "Geometry/Tessellation/Delaunay/Action",
        "inDepth": "ByParametersOnSurface will return a Delaunay triangulation of an input Surface. In the example below, a Delaunay triangulation of a NurbsSurface is returned with a UV count of 400. Increasing the UV count will create a better approximation of the underlying Surface but with more triangles."
    },
    {
        "Name": "ByPoints",
        "imageFile": [
            "ByPoints"
        ],
        "dynFile": [
            "ByPoints"
        ],
        "folderPath": "Geometry/Tessellation/Delaunay/Action",
        "inDepth": "ByPoints will return a list of curves that represent the Delaunay triangulation of a set of points. In the example below, a list of points randomly placed in 3D returns a list of curves representing their Delaunay triangulation."
    },
    {
        "Name": "ByParametersOnSurface",
        "imageFile": [
            "ByParametersOnSurface"
        ],
        "dynFile": [
            "ByParametersOnSurface"
        ],
        "folderPath": "Geometry/Tessellation/Voronoi/Action",
        "inDepth": "ByParametersOnSurface will return a Voronoi representation of a surface's UV as a list of curves. In the example below, a Voronoi representation is created on a surface using a UV system of 50 random values. In order for the Voronoi to stop at the edges of the surface, the returned curves must be intersected with the surface."
    },
    {
        "Name": "Edges",
        "imageFile": [
            "Edges"
        ],
        "dynFile": [
            "Edges"
        ],
        "folderPath": "Geometry/Topology/Query",
        "inDepth": "Edges will return a List of Edges from an input geometry. In the example below, a Cuboid returns a List of 12 Edges."
    },
    {
        "Name": "Faces",
        "imageFile": [
            "Faces"
        ],
        "dynFile": [
            "Faces"
        ],
        "folderPath": "Geometry/Topology/Query",
        "inDepth": "Faces will return the list of Faces that make up a Topology. In the example below, two chamfered PolySurfaces return a lists of Faces of different lengths."
    },
    {
        "Name": "Vertices",
        "imageFile": [
            "Vertices"
        ],
        "dynFile": [
            "Vertices"
        ],
        "folderPath": "Geometry/Topology/Query",
        "inDepth": "Vertices will return a List of Vertex locations for an input geometry. In the example below, the a Cuboid returns a list of 8 Vertex locations."
    },
    {
        "Name": "ByCoordinates",
        "imageFile": [
            "ByCoordinates"
        ],
        "dynFile": [
            "ByCoordinates"
        ],
        "folderPath": "Geometry/UV/Create",
        "inDepth": "ByCoordinates will return a UV from two lists of doubles. In the example below, a UV is returned from 400 random values to create a Delaunay triangulation of a NurbsSurface."
    },
    {
        "Name": "U",
        "imageFile": [
            "U"
        ],
        "dynFile": [
            "U"
        ],
        "folderPath": "Geometry/UV/Query",
        "inDepth": "U will return the U value of a UV coordinate. In the example below, the U value of a Point location on the NurbsSurface is returned. The UV parameter is returned from the Surface.UVParamterAtPoint node."
    },
    {
        "Name": "V",
        "imageFile": [
            "V"
        ],
        "dynFile": [
            "V"
        ],
        "folderPath": "Geometry/UV/Query",
        "inDepth": "V will return the V value of a UV coordinate. In the example below, the V value of a Point location on the NurbsSurface is returned. The UV parameter is returned from the Surface.UVParamterAtPoint node."
    },
    {
        "Name": "ByCoordinates (x, y, z, normalized)",
        "imageFile": [
            "ByCoordinates (x, y, z, normalized)"
        ],
        "dynFile": [
            "ByCoordinates (x, y, z, normalized)"
        ],
        "folderPath": "Geometry/Vector/Create",
        "inDepth": "ByCoordinates (x, y, z, normalized) will return a Vector from coordinate values and a normalize boolean toggle. In the example below, a Vector is returned with a length of 2.83 that can be normalized to 1. The Vector is represented as a Line to show length change when toggling normalize."
    },
    {
        "Name": "ByCoordinates (x, y, z)",
        "imageFile": [
            "ByCoordinates (x, y, z)"
        ],
        "dynFile": [
            "ByCoordinates (x, y, z)"
        ],
        "folderPath": "Geometry/Vector/Create",
        "inDepth": "ByCoordinates (x, y, z) will return a Vector from X, Y, and Z coordinates. The input coordinate location defines the Vector's position and length. In the example below, a Vector is returned from a coordinate location of (1,0,1) and is represented as a Line."
    },
    {
        "Name": "ByTwoPoints",
        "imageFile": [
            "ByTwoPoints"
        ],
        "dynFile": [
            "ByTwoPoints"
        ],
        "folderPath": "Geometry/Vector/Create",
        "inDepth": "ByTwoPoints will return a Vector defined by two Point locations. In the example below, a Vector created by two Points is represented by a Line. The Vector's length is 3, equal to the distance between Points."
    },
    {
        "Name": "XAxis",
        "imageFile": [
            "XAxis"
        ],
        "dynFile": [
            "XAxis"
        ],
        "folderPath": "Geometry/Vector/Create",
        "inDepth": "XAxis will return a Vector that represents the WorldCoordinateSystem X axis. In the example below, the Vector returned is used to create a Line that follows the WCS X axis."
    },
    {
        "Name": "YAxis",
        "imageFile": [
            "YAxis"
        ],
        "dynFile": [
            "YAxis"
        ],
        "folderPath": "Geometry/Vector/Create",
        "inDepth": "YAxis will return a Vector that represents the WorldCoordinateSystem Y axis. In the example below, the Vector returned is used to create a Line that follows the WCS Y axis."
    },
    {
        "Name": "ZAxis",
        "imageFile": [
            "ZAxis"
        ],
        "dynFile": [
            "ZAxis"
        ],
        "folderPath": "Geometry/Vector/Create",
        "inDepth": "ZAxis will return a Vector that represents the WorldCoordinateSystem Z axis. In the example below, the Vector returned is used to create a Line that follows the WCS Z axis."
    },
    {
        "Name": "Add",
        "imageFile": [
            "Add"
        ],
        "dynFile": [
            "Add"
        ],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "Add will return a Vector that is the sum of two other Vectors. In the example below, the sum of the WCS Z axis and X axis Vectors results in a Vector with coordinates of (1,0,1). The new Vector is represented as a Line."
    },
    {
        "Name": "AngleAboutAxis",
        "imageFile": [
            "AngleAboutAxis"
        ],
        "dynFile": [
            "AngleAboutAxis"
        ],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "AngleAboutAxis will return the angle measurement between two Vectors in degrees from 0 to 360 and about an axis of rotation. In the example below, the angle between two Vectors is measured about the Z axis. Adjust Z Elevation and Rotation Degrees sliders to see how they affect the resulting angle measurement. The Vectors are represented as Lines."
    },
    {
        "Name": "AngleWithVector",
        "imageFile": [
            "AngleWithVector"
        ],
        "dynFile": [
            "AngleWithVector"
        ],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "AngleWithVector will return the angle measurement between two Vectors in degrees from 0 to 180. In the example below, an angle measurement is returned for two Vectors. Adjust Z Elevation and Rotation Degrees sliders to see how they affect the resulting angle measurement. The Vectors are represented as Lines."
    },
    {
        "Name": "AsPoint",
        "imageFile": [
            "AsPoint"
        ],
        "dynFile": [
            "AsPoint"
        ],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "AsPoint will return a Point at the coordinate values of a Vector. In the example below, a Point is returned from the Vector.ByCoordinates node at (10,5,6)."
    },
    {
        "Name": "Cross",
        "imageFile": [
            "Cross"
        ],
        "dynFile": [
            "Cross"
        ],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "Cross will return the cross product of two Vectors. In the example below, the cross product of two Vectors results in a new Vector. The Vectors are represented as Lines."
    },
    {
        "Name": "Dot",
        "imageFile": [
            "Dot"
        ],
        "dynFile": [
            "Dot"
        ],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "Dot will return the dot product of two Vectors as a double. In the example below, Vectors of (10,5,6) and (1,10,1) return a dot product of 66."
    },
    {
        "Name": "IsAlmostEqualTo",
        "imageFile": [
            "IsAlmostEqualTo"
        ],
        "dynFile": [
            "IsAlmostEqualTo"
        ],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "IsAlmostEqualTo will return a boolean value based on whether a Vector has the same values as another. In the example below, a true value is returned when comparing a Vector on the WCS Z axis to a Vector with coordinates of (0,0,1). Adjusting the Vector Direction slider will change the Vector's coordinate values making it unequal. The Vectors are represented as Lines."
    },
    {
        "Name": "IsParallel",
        "imageFile": [
            "IsParallel"
        ],
        "dynFile": [
            "IsParallel"
        ],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "IsParallel will return a boolean value based on whether a Vector is parallel to another Vector. In the example below, two Vectors represented as Lines are compared. Adjust the slider to rotate one Vector in and out of parallel with the other."
    },
    {
        "Name": "Normalized",
        "imageFile": [
            "Normalized"
        ],
        "dynFile": [
            "Normalized"
        ],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "Normalized will return a normalized Vector. The Vector returned will have a length of 1 regardless of its original length. In the example below, a Vector of length ~1.4142 is normalized to a length of 1."
    },
    {
        "Name": "Reverse",
        "imageFile": [
            "Reverse"
        ],
        "dynFile": [
            "Reverse"
        ],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "Reverse will return a new Vector pointing in the opposite direction from its input. In the example below, a Vector of (1,0,1) will return a Vector of (-1,0,-1). Adjusting the Vector Direction slider will change the vector's coordinate values and return a different reversed vector. The Vectors are represented as Lines."
    },
    {
        "Name": "Rotate (vector, origin, degrees)",
        "imageFile": [
            "Rotate (vector, origin, degrees)"
        ],
        "dynFile": [
            "Rotate (vector, origin, degrees)"
        ],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "Rotate (vector, origin, degrees) will return a new Vector rotated about the normal of a Plane. In the example below, a Vector represented as a Line is rotated about the normal of the XZ Plane. Plugging in different Planes will give different rotation axes."
    },
    {
        "Name": "Rotate (vector, axis, degrees)",
        "imageFile": [
            "Rotate (vector, axis, degrees)"
        ],
        "dynFile": [
            "Rotate (vector, axis, degrees)"
        ],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "Rotate (vector, axis, degrees) will return a new Vector rotated about an input axis. In the example below, a Vector represented as a Line is rotated about a Z axis Vector. Try plugging in different Vectors for different rotation axes."
    },
    {
        "Name": "Scale (vector, scale_factor)",
        "imageFile": [
            "Scale (vector, scale_factor)"
        ],
        "dynFile": [
            "Scale (vector, scale_factor)"
        ],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "Scale (vector, scale_factor) will return a new Vector scaled by a factor. In the example below, a Vector of length 1.732 is scaled to 12.471 from a factor of 7.2."
    },
    {
        "Name": "Scale (vector, xScaleFactor, yScaleFactor, zScaleFactor)",
        "imageFile": [
            "Scale (vector, xScaleFactor, yScaleFactor, zScaleFactor)"
        ],
        "dynFile": [
            "Scale (vector, xScaleFactor, yScaleFactor, zScaleFactor)"
        ],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "Scale (vector, xScaleFactor, yScaleFactor, zScaleFactor) will return a new Vector scaled non-uniformly in the X, Y and Z directions. In the example below, two new Vectors are scaled from an X scale factor and Y/Z scale factors. All scale factors are 2, yet different Vector lengths are returned from scaling in different and/or multiple directions."
    },
    {
        "Name": "Subtract",
        "imageFile": [
            "Subtract"
        ],
        "dynFile": [
            "Subtract"
        ],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "Subtract will return a Vector that is the difference of two other Vectors. In the example below, the difference of the a Vector with coordinates (1,0,1) and WCS Z axis results in a Vector with coordinates of (1,0,0). Adjusting the Vector Direction slider will change the vector's coordinate values and return a different subtracted vector. The Vectors are represented as Lines."
    },
    {
        "Name": "Transform",
        "imageFile": [
            "Transform"
        ],
        "dynFile": [
            "Transform"
        ],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "Transform will return a new Vector based on an input CoordinateSystem. In the example below, a Vector is transformed from the WorldCoordinateSystem to a new CoordinateSystem defined by spherical coordinates. Try adjusting the sliders to move the new Vector into a different position. Both Vectors are represented as Lines."
    },
    {
        "Name": "Length",
        "imageFile": [
            "Length"
        ],
        "dynFile": [
            "Length"
        ],
        "folderPath": "Geometry/Vector/Query",
        "inDepth": "Length will return the length of a Vector as a double. In the example below, a Vector with coordinates of (4,0,4) returns a length of 5.67. Adjusting the Length slider will change the Vector's length. The Vector is represented as a Line."
    },
    {
        "Name": "X",
        "imageFile": [
            "X"
        ],
        "dynFile": [
            "X"
        ],
        "folderPath": "Geometry/Vector/Query",
        "inDepth": "X will return the X component of a Vector as a double. This can also be understood as the length of a Vector in the X direction. In the example below, a Vector with coordinates of (4,2,3) returns an X component value of 4. Adjusting the Vector Scale slider will lengthen the Vector and change its X value. The Vector is represented as a Line."
    },
    {
        "Name": "Y",
        "imageFile": [
            "Y"
        ],
        "dynFile": [
            "Y"
        ],
        "folderPath": "Geometry/Vector/Query",
        "inDepth": "Y will return the Y component of a Vector as a double. This can also be understood as the length of a Vector in the Y direction. In the example below, a Vector with coordinates of (4,2,3) returns an Y component value of 2. Adjusting the Vector Scale slider will lengthen the Vector and change its Y value. The Vector is represented as a Line."
    },
    {
        "Name": "Z",
        "imageFile": [
            "Z"
        ],
        "dynFile": [
            "Z"
        ],
        "folderPath": "Geometry/Vector/Query",
        "inDepth": "Z will return the Z component of a Vector as a double. This can also be understood as the length of a Vector in the Z direction. In the example below, a Vector with coordinates of (4,2,3) returns an Z component value of 3. Adjusting the Vector Scale slider will lengthen the Vector and change its Z value. The Vector is represented as a Line."
    },
    {
        "Name": "AdjacentEdges",
        "imageFile": [
            "AdjacentEdges"
        ],
        "dynFile": [
            "AdjacentEdges"
        ],
        "folderPath": "Geometry/Vertex/Query",
        "inDepth": "AdjacentEdges will return the Edges that emanate from a Vertex. In the example below, the Edges emanating from a Vertex on a Cube are represented as Lines. Adjust the Edges slider to return different sets of adjacent Edges."
    },
    {
        "Name": "AdjacentFaces",
        "imageFile": [
            "AdjacentFaces"
        ],
        "dynFile": [
            "AdjacentFaces"
        ],
        "folderPath": "Geometry/Vertex/Query",
        "inDepth": "AdjacentFaces will return the Faces adjacent to an input Vertex. In the example below, a Vertex on a Cuboid will return a List of three Faces. Adjusting the Index Selector slider will change the input Vertex and return different sets of adjacent Faces. The Faces are represented as Surfaces."
    },
    {
        "Name": "PointGeometry",
        "imageFile": [
            "PointGeometry"
        ],
        "dynFile": [
            "PointGeometry"
        ],
        "folderPath": "Geometry/Vertex/Query",
        "inDepth": "PointGeometry will return Vertex locations as Points. In the example below, the Vertices of a Cube are returned and represented as Points."
    },
    {
        "Name": "ReadFromFile",
        "imageFile": ["ReadFromFile"],
        "dynFile": ["ReadFromFile"],
        "folderPath": "Office/Excel/Action",
        "inDepth": "Read From File takes a file as input. The file should be a text file that has data separated by commas. The different lines in the file correspond to the outer list, while the individual values in each line correspond to the inner lists. In the example below, we first use a File Path node and a File.FromPath node to create a file object that points to a text file. Then we use a ReadFromFile node to create a list from the CSV file."
    },
    {
        "Name": "WriteToFile",
        "imageFile": [
            "WriteToFile"
        ],
        "dynFile": [
            "WriteToFile"
        ],
        "folderPath": "Office/Excel/Action",
        "inDepth": "WriteToFile will return a List of Lists that is written to an Excel file. The sheet name, start row, and start column of where to write the data can be defined as inputs as well as whether existing data will be overwritten. In the example below, a List of Lists containing a number sequence is written to sampleexcel.xlsx starting at row 0 (or 1 in Excel) and column 1 (or B in Excel). The Excel file now has nine new columns with data in two existing rows. Screenshots of sampleexcel.xlsx before and after writing are overlaid to show the data in Excel's format."
    },
    {
        "Name": "!=",
        "imageFile": [
            "NotEqualTo"
        ],
        "dynFile": [
            "NotEqualTo"
        ],
        "folderPath": "Operators/Action",
        "inDepth": "!= is the Not Equal To operator. It takes two input values and returns true if the two values are not equal to each other and returns false if the two values are equal. In the example below, we use two number sliders to control the inputs to a != operator."
    },
    {
        "Name": "%",
        "imageFile": [
            "Modulo",
            "Modulo - Ex 2"
        ],
        "dynFile": [
            "Modulo",
            "Modulo - Ex 2"
        ],
        "folderPath": "Operators/Action",
        "inDepth": "% is the Modulo operator. It returns the remainder of the x input after being divided by the y input. In the example below, we use two number sliders to control the inputs to a % operator."
    },
    {
        "Name": "&&",
        "imageFile": [
            "And"
        ],
        "dynFile": [
            "And"
        ],
        "folderPath": "Operators/Action",
        "inDepth": "&& is the And operator. It takes two boolean values as input and returns true if both values are true. If one or both values are false, it will return false. In the example below, we use two boolean toggle nodes to control the inputs to the && operator."
    },
    {
        "Name": "*",
        "imageFile": [
            "Multiply"
        ],
        "dynFile": [
            "Multiply"
        ],
        "folderPath": "Operators/Action",
        "inDepth": "* is the multiplication operator. It will return the product of the two input numbers. In the example below, we use two number sliders to control the inputs to the * operator."
    },
    {
        "Name": "+",
        "imageFile": [
            "Add"
        ],
        "dynFile": [
            "Add"
        ],
        "folderPath": "Operators/Action",
        "inDepth": "+ is the addition operator. It will return the sum ofy the two input numbers. In the example below, we use two number sliders to control the inputs to the + operator."
    },
    {
        "Name": "-",
        "imageFile": [
            "Subtract"
        ],
        "dynFile": [
            "Subtract"
        ],
        "folderPath": "Operators/Action",
        "inDepth": "- is the subtraction operator. It will return the result of the y input subtracted from the x input. In the example below, we use two number sliders to control the inputs to the - operator."
    },
    {
        "Name": "/",
        "imageFile": [
            "Divide"
        ],
        "dynFile": [
            "Divide"
        ],
        "folderPath": "Operators/Action",
        "inDepth": "/ is the division operator. It will return the result of the x input divided by the y input. In the example below, we use two number sliders to control the inputs to the / operator."
    },
    {
        "Name": "<",
        "imageFile": [
            "LessThan"
        ],
        "dynFile": [
            "LessThan"
        ],
        "folderPath": "Operators/Action",
        "inDepth": "< is the Less Than operator. If the x input is less than the y input, it will return true. If x is greater than y, or if the two value are equal, this operator will return false. In the example below, we use two number sliders to control the inputs to the < operator."
    },
    {
        "Name": "<=",
        "imageFile": [
            "LessThanOrEqualTo"
        ],
        "dynFile": [
            "LessThanOrEqualTo"
        ],
        "folderPath": "Operators/Action",
        "inDepth": "<= is the Less Than Or Equal To operator. If the x input is less than the y input, or if the two values are equal, it will return true. If x is greater than y, this operator will return false. In the example below, we use two number sliders to control the inputs to the <= operator."
    },
    {
        "Name": "==",
        "imageFile": [
            "EqualTo"
        ],
        "dynFile": [
            "EqualTo"
        ],
        "folderPath": "Operators/Action",
        "inDepth": "== is the Equal To operator. If the x input is equal to the y input, it will return true. If the two values are not equal, this operator will return false. In the example below, we use two number sliders to control the inputs to the == operator."
    },
    {
        "Name": ">",
        "imageFile": [
            "GreaterThan"
        ],
        "dynFile": [
            "GreaterThan"
        ],
        "folderPath": "Operators/Action",
        "inDepth": "> is the Greater Than operator. If the x input is greater than the y input, it will return true. If x is less than y, or if the two value are equal, this operator will return false. In the example below, we use two number sliders to control the inputs to the > operator."
    },
    {
        "Name": ">=",
        "imageFile": [
            "GreaterThanOrEqualTo"
        ],
        "dynFile": [
            "GreaterThanOrEqualTo"
        ],
        "folderPath": "Operators/Action",
        "inDepth": ">= is the Greater Than Or Equal To operator. If the x input is greater than the y input, or if the two values are equal, it will return true. If x is less than y, this operator will return false. In the example below, we use two number sliders to control the inputs to the >= operator."
    },
    {
        "Name": "Not",
        "imageFile": [
            "Not"
        ],
        "dynFile": [
            "Not"
        ],
        "folderPath": "Operators/Action",
        "inDepth": "Not (also written as exclamation point) will return the opposite of an input boolean value. In the example below, we use a boolean toggle node as the input to a Not operator."
    },
    {
        "Name": "||",
        "imageFile": [
            "Or"
        ],
        "dynFile": [
            "Or"
        ],
        "folderPath": "Operators/Action",
        "inDepth": "|| is the Or operator. It takes two boolean values as input and returns true if one or both values are true. If both values are false, it will return false. In the example below, we use two boolean toggle nodes to control the inputs to the || operator."
    }
]

[
    {
        "Name": "Code Block ()",
        "categories": [
            "Core",
            "Input"
        ],
        "folderPath": "Core/Input/Create",
        "dynFile": [
            "CodeBlock"
        ],
        "imageFile": [
            "CodeBlock"
        ],
        "inDepth": "The Code Block is universal and can be useful in all definitions. With this node, we can fully customize the Dynamo functionality and experience by coding directly into the graph. In this example, we see a range of possible uses including Numbers, Strings, Booleans for item based code, and Ranges and Sequences for creating lists of values."
    },
    {
        "Name": "Number Slider",
        "categories": [
            "Core",
            "Input"
        ],
        "folderPath": "Core/Input/Create",
        "dynFile": [
            "NumberSlider"
        ],
        "imageFile": [
            "NumberSlider"
        ],
        "inDepth": "The Number Slider is a customizable, tactile node that allows us to interface with the data driving our Dynamo definitions. Here, the number slider is paired with a code block to create a dynamic list sequence with a variable step size."
    },
    {
        "Name": "Integer Slider",
        "categories": [
            "Core",
            "Input"
        ],
        "folderPath": "Core/Input/Create",
        "dynFile": [
            "IntegerSlider"
        ],
        "imageFile": [
            "IntegerSlider"
        ],
        "inDepth": "An Integer Slider works in the same way as a Number Slider but only outputs integers. The Integer Slider in the example definition allows us to control the list length, ensuring that we always have whole-number of list outputs. "
    },
    {
        "Name": "ByCoordinates (x, y)",
        "categories": [
            "Geometry",
            "Point"
        ],
        "folderPath": "Geometry/Point/Create",
        "dynFile": [
            "ByCoordinates",
            "ByCoordinates_crossReference"
        ],
        "imageFile": [
            "ByCoordinates",
            "ByCoordinates_crossReference"
        ],
        "inDepth": "The Point By Coordinates (XY) calls for two number inputs and generates a point on the Dynamo base plane.  In the first example,  we are using two sliders to dynamically control the point’s X and Y location on the Z-plane. In the second, we are using two Number Sliders and a Code Block Range to determine the maximum extents of the grid and the spacing between points. By changing the Points By Coordinates lacing to Cross-Reference, we can create multi-dimensional set of points along the X and Y axis."
    },
    {
        "Name": "ByCylindricalCoordinates",
        "categories": [
            "Geometry",
            "Point"
        ],
        "folderPath": "Geometry/Point/Create",
        "dynFile": [
            "ByCylindricalCoordinates"
        ],
        "imageFile": [
            "ByCylindricalCoordinates"
        ],
        "inDepth": "The Point By Cylindrical Coordinates node creates a point located within a cylindrical space. Here, we set the lacing to Cross-Reference and use a range of angles and elevations to generate a grid of points along a cylinder with a dynamic radius."
    },
    {
        "Name": "BySphericalCoordinates",
        "categories": [
            "Geometry",
            "Point"
        ],
        "folderPath": "Geometry/Point/Create",
        "dynFile": [
            "BySphericalCoordinates"
        ],
        "imageFile": [
            "BySphericalCoordinates"
        ],
        "inDepth": "The Point By Spherical Coordinates node creates a point located within a spherical space. Here, we set the lacing to Cross-Reference and use a range of phi and theta angles to generate a grid of points along a cylinder with a dynamic radius. The location of the sphere is set to a Coordinate System with the origin (1, 5, 1)."
    },
    {
        "Name": "ByCartesianCoordinates",
        "categories": [
            "Geometry",
            "Point"
        ],
        "folderPath": "Geometry/Point/Create",
        "dynFile": [
            "ByCartesianCoordinates"
        ],
        "imageFile": [
            "ByCartesianCoordinates"
        ],
        "inDepth": "Point By Cartesian Coordinates gives us the ability to set the X, Y and Z values of a point’s location. In this example, we are setting multiple Code Block Ranges controlled by sliders to drive the three-dimensional array of points."
    },
    {
        "Name": "ByCenterPointRadiusNormal",
        "categories": [
            "Geometry",
            "Circle"
        ],
        "folderPath": "Geometry/Circle/Create",
        "dynFile": [
            "ByCenterPointRadiusNormal"
        ],
        "imageFile": [
            "ByCenterPointRadiusNormal"
        ],
        "inDepth": "Circle By Center Point Radius Normal creates a circle at a point with a controllable radius and normal. In this example, we create a vector from the Origin Point to the Point By Coordinates to control the direction of the circle."
    },
    {
        "Name": "ByPlaneRadius",
        "categories": [
            "Geometry",
            "Circle"
        ],
        "folderPath": "Geometry/Circle/Create",
        "dynFile": [
            "ByPlaneRadius"
        ],
        "imageFile": [
            "ByPlaneRadius"
        ],
        "inDepth": "Circle By Plane Radius is a condensed node to create any type of circle. In this example, we use the YZ plane to determine the circle direction, and a Number slider to dynamically control the circle’s radius."
    },
    {
        "Name": "ByCenterPointRadius",
        "categories": [
            "Geometry",
            "Circle"
        ],
        "folderPath": "Geometry/Circle/Create",
        "dynFile": [
            "ByCenterPointRadius"
        ],
        "imageFile": [
            "ByCenterPointRadius"
        ],
        "inDepth": "Circle By Center Point Radius is a simplified node to create a circle with a the Z-Plane normal. This definition uses a code block to create a point in three-dimensional space, and locates the circle around the point. The radius is controlled dynamically with a Number Slider."
    },
    {
        "Name": "ByThreePoints",
        "categories": [
            "Geometry",
            "Circle"
        ],
        "folderPath": "Geometry/Circle/Create",
        "dynFile": [
            "ByThreePoints"
        ],
        "imageFile": [
            "ByThreePoints"
        ],
        "inDepth": "Circle By Three Points receives point inputs and creates a circle. This example shows how thee randomly generated points on the Z-plane will always result in a circle."
    },
    {
        "Name": "ByBestFitThroughPoints",
        "categories": [
            "Geometry",
            "Circle"
        ],
        "folderPath": "Geometry/Circle/Create",
        "dynFile": [
            "ByBestFitThroughPoints"
        ],
        "imageFile": [
            "ByBestFitThroughPoints"
        ],
        "inDepth": "Circle By Best Fit Through Points receives point inputs and creates a best fit circle through them. In this example, we can dynamically increase the number of randomly generated points with a Number Slider, altering the shape of the best-fit circle. "
    },
    {
        "Name": "ByPoints",
        "categories": [
            "Geometry",
            "Polygon"
        ],
        "folderPath": "Geometry/Polygon/Create",
        "dynFile": [
            "ByPoints"
        ],
        "imageFile": [
            "ByPoints"
        ],
        "inDepth": "Polygon By Points creates a polygon from a list of input points. The points will be connected in the order of the list they originate from. In this example, we create a list of random points driven by a Number slider. The points are then connected with lines in the Polygon By Points Component."
    },
    {
        "Name": "RegularPolygon",
        "categories": [
            "Geometry",
            "Polygon"
        ],
        "folderPath": "Geometry/Polygon/Create",
        "dynFile": [
            "RegularPolygon"
        ],
        "imageFile": [
            "RegularPolygon"
        ],
        "inDepth": "Polygon Regular Polygon is a simple component that will inscribe a regular polygon of any number of sides into a circle. In this example, we create the reference circle from a random Best Fit Through Points and draw a six-sided polygon inside the circle."
    },
    {
        "Name": "ByWidthLength (width, length)",
        "categories": [
            "Geometry",
            "Rectangle"
        ],
        "folderPath": "Geometry/Rectangle/Create",
        "dynFile": [
            "ByWidthLength"
        ],
        "imageFile": [
            "ByWidthLength"
        ],
        "inDepth": "The Rectangle By Width Length node creates a rectangle on the Z-base plane with a specified length and width dimension. The center of the rectangle will be located at the grid origin. In this example, we use two Number Sliders to drive the shape of the rectangle. "
    },
    {
        "Name": "ByCornerPoints (p1, p2, p3, p4)",
        "categories": [
            "Geometry",
            "Rectangle"
        ],
        "folderPath": "Geometry/Rectangle/Create",
        "dynFile": [
            "ByCornerPoints"
        ],
        "imageFile": [
            "ByCornerPoints"
        ],
        "inDepth": "The Rectangle By Corner Points node takes four input points and creates a rectangle from them. The input points must reflect a rectangle form. In this example, two Number Sliders are used to create the Points By Coordinates at the rectangle’s vertices. A similar but distinct Rectangle ByCornerPoints node uses a list of points as the input rather than each input separately. Both nodes are shown in this example."
    },
    {
        "Name": "ByCornerPoints (points)",
        "categories": [
            "Geometry",
            "Rectangle"
        ],
        "folderPath": "Geometry/Rectangle/Create",
        "dynFile": [
            "ByCornerPoints"
        ],
        "imageFile": [
            "ByCornerPoints"
        ],
        "inDepth": "The Rectangle By Corner Points node takes a list of four input points and creates a rectangle from them. The input points must reflect a rectangle form. In this example, two Number Sliders are used to create the Points By Coordinates at the rectangle’s vertices. A similar but distinct Rectangle ByCornerPoints node uses four separate inputs for eacher point rather than as a single list. Both nodes are shown in this example."
    },
    {
        "Name": "ByWidthLength (cs, width, length)",
        "categories": [
            "Geometry",
            "Rectangle"
        ],
        "folderPath": "Geometry/Rectangle/Create",
        "dynFile": [
            "ByWidthLength_cwl"
        ],
        "imageFile": [
            "ByWidthLength_cwl"
        ],
        "inDepth": "Create a Rectangle centered at the input origin in the CoordinateSystem XY Plane, with specified width (X Axis length), and length (Y Axis length)."
    },
    {
        "Name": "ByWidthLength (plane, width, length)",
        "categories": [
            "Geometry",
            "Rectangle"
        ],
        "folderPath": "Geometry/Rectangle/Create",
        "dynFile": [
            "ByWidthLength_pwl"
        ],
        "imageFile": [
            "ByWidthLength_pwl"
        ],
        "inDepth": "Create a Rectangle centered at the origin of the input plane, with specified width (X Axis length), and length (Y Axis length). In the example, we use the world YZ plane as the input plane. The width specifies the plane X Axis length, which in this case corresponds to the world Y axis, and the length specifies the plane Y Axis length which is this case corresponds to the world Z Axis."
    },
    {
        "Name": "Width",
        "categories": [
            "Geometry",
            "Rectangle"
        ],
        "folderPath": "Geometry/Rectangle/Query",
        "dynFile": [
            "WidthHeight"
        ],
        "imageFile": [
            "WidthHeight"
        ],
        "inDepth": "Width will output the width of an input rectangle. The width is the dimension in the X-axis of the plane or coordinate system of the rectangle. The example below uses four points to create a rectangle, then shows both Width and Length nodes to find the dimensions of the rectangle."
    },
    {
        "Name": "Height",
        "categories": [
            "Geometry",
            "Rectangle"
        ],
        "folderPath": "Geometry/Rectangle/Query",
        "dynFile": [
            "WidthHeight"
        ],
        "imageFile": [
            "WidthHeight"
        ],
        "inDepth": "Height will output the height of an input rectangle. The height output is the same as the length input for Rectangle.Create nodes. The height is the dimension in the Y-axis of the plane or coordinate system of the rectangle. The example below uses four points to create a rectangle, then shows both Width and height nodes to find the dimensions of the rectangle."
    },
    {
        "Name": "ByThickeningCurve",
        "categories": [
            "Geometry",
            "PolyCurve"
        ],
        "folderPath": "Geometry/Polycurve/Create",
        "dynFile": [
            "ByThickeningCurve"
        ],
        "imageFile": [
            "ByThickeningCurve"
        ],
        "inDepth": "Polycurve By Thickening Curve is a node that constructs a closed, offset polygon from a single curve. In this node, we can specify the curve being thickened, the overall thickness, and the normal direction of the offset. This example shows how a randomly generated Nurbs Curve is offset perpendicular to its start and end point vector. "
    },
    {
        "Name": "ByPoints",
        "categories": [
            "Geometry",
            "PolyCurve"
        ],
        "folderPath": "Geometry/Polycurve/Create",
        "dynFile": [
            "ByPoints"
        ],
        "imageFile": [
            "ByPoints"
        ],
        "inDepth": "Polycurve By Points creates joined curves from a set of vertices. This node also allows us to toggle between a closed and an open shape. In this example, points are created along a circle and are redrawn with a PolyCurve By Points component, creating a closed polygon shape."
    },
    {
        "Name": "ByJoinedCurves",
        "categories": [
            "Geometry",
            "PolyCurve"
        ],
        "folderPath": "Geometry/Polycurve/Create",
        "dynFile": [
            "ByJoinedCurves"
        ],
        "imageFile": [
            "ByJoinedCurves"
        ],
        "inDepth": "Polycurve By Joined Curves creates joined curves from a set of curves with matching vertices. In this example, a RegularPolygon is exploded into a curve list and is then rejoined into a Polycurve."
    },
    {
        "Name": "ByControlPoints (points)",
        "categories": [
            "Geometry",
            "NurbsCurve"
        ],
        "folderPath": "Geometry/NurbsCurve/Create",
        "dynFile": [
            "ByControlPoints_p"
        ],
        "imageFile": [
            "ByControlPoints_p"
        ],
        "inDepth": "Nurbs Curve By Control Points inputs a list of points to use as control points and outputs a Nurbs Curve. This example uses a Code Block to generate two lists corresponding to X and Y locations of a series of points. The points are used to draw the Nurbs Curve."
    },
    {
        "Name": "ByPointsTangents",
        "categories": [
            "Geometry",
            "NurbsCurve"
        ],
        "folderPath": "Geometry/NurbsCurve/Create",
        "dynFile": [
            "ByPointsTangents"
        ],
        "imageFile": [
            "ByPointsTangents"
        ],
        "inDepth": "Nurbs Curve By Points Tangents inputs a list of control points and the start and end tangent that the Nurbs Curve will maintain. This example uses a reference circle for the control points of the curve, and a single vector to control both the start and end tangents. "
    },
    {
        "Name": "ByPoints (points, degree)",
        "categories": [
            "Geometry",
            "NurbsCurve"
        ],
        "folderPath": "Geometry/NurbsCurve/Create",
        "dynFile": [
            "ByPoints_pd"
        ],
        "imageFile": [
            "ByPoints_pd"
        ],
        "inDepth": "Nurbs Curve By Points inputs a list of points to draw a Nurbs Curve through, and also allows us to change the degree of the curve. This example generates six random points on the World XY plane and connects them in order in the X and Y directions. "
    },
    {
        "Name": "ByPoints (points, closeCurve)",
        "categories": [
            "Geometry",
            "NurbsCurve"
        ],
        "folderPath": "Geometry/NurbsCurve/Create",
        "dynFile": [
            "ByPoints_pc"
        ],
        "imageFile": [
            "ByPoints_pc"
        ],
        "inDepth": "Nurbs Curve By Points inputs a list of points to draw a Nurbs Curve through and also allows us to close the curve. This example generates four random points on the World XY plane and connects them in order in the X and Y directions, closing the curve back to the first point in the list."
    },
    {
        "Name": "ByPoints (points)",
        "categories": [
            "Geometry",
            "NurbsCurve"
        ],
        "folderPath": "Geometry/NurbsCurve/Create",
        "dynFile": [
            "ByPoints_p"
        ],
        "imageFile": [
            "ByPoints_p"
        ],
        "inDepth": "Nurbs Curve By Points inputs a list of points to draw a Nurbs Curve through. This example generates six random points on the World XY plane and connects them in order in the X and Y directions. "
    },
    {
        "Name": "ByControlPoints (points, degree)",
        "categories": [
            "Geometry",
            "NurbsCurve"
        ],
        "folderPath": "Geometry/NurbsCurve/Create",
        "dynFile": [
            "ByControlPoints_p"
        ],
        "imageFile": [
            "ByControlPoints_p"
        ],
        "inDepth": "Nurbs Curve By Control Points inputs a list of control points to draw the Nurbs Curve and also allows us to control the degree of the curve. This example generates four random points on the World XY plane and connects them in order in the X and Y directions."
    },
    {
        "Name": "ByControlPoints (points, degree, closeCurve)",
        "categories": [
            "Geometry",
            "NurbsCurve"
        ],
        "folderPath": "Geometry/NurbsCurve/Create",
        "dynFile": [
            "ByControlPoints_pdc"
        ],
        "imageFile": [
            "ByControlPoints_pdc"
        ],
        "inDepth": "Nurbs Curve By Control Points inputs a list of control points to draw the Nurbs Curve and also allows us to control the degree of the curve. We also have the option to close the curve back to the first point in the list. This example generates four random points on the World XY plane and connects them in order in the X and Y directions."
    },
    {
        "Name": "ByControlPointsWeightsKnots",
        "categories": [
            "Geometry",
            "NurbsCurve"
        ],
        "folderPath": "Geometry/NurbsCurve/Create",
        "dynFile": [
            "ByControlPointsWeightsKnots"
        ],
        "imageFile": [
            "ByControlPointsWeightsKnots"
        ],
        "inDepth": "Nurbs Curve by Control Points Weights Knots allows us to manually control the weights and knots of a Nurbs Curve. The list of weights should be the same length as the list of control points. The size of the the list of knots must be equal to the number of control points plus the degree plus one. In the example, we first create a Nurbs Curve by interpolating between a series of random points. We use Knots, Weigts, and Control Points to find the corresponding parts of that curve. We can use ReplaceItemAtIndex to modify the list of weights. Finally we use ByControlPointsWeightsKnots to recreate the Nurbs Curve with the modified weights. "
    },
    {
        "Name": "ByControlPoints",
        "categories": [
            "Geometry",
            "NurbsSurface"
        ],
        "folderPath": "Geometry/NurbsSurface/Create",
        "dynFile": [
            "ByControlPoints"
        ],
        "imageFile": [
            "ByControlPoints"
        ],
        "inDepth": "Nurbs Surface By Control Points takes in a two dimensional array of control vertices and outputs a Nurbs Surface. This node also gives us the ability to calibrate the degree in the U and V directions. In this example, a 10 by 10 grid of points is created with a Code Block Range. The grid is then scaled in the Z-direction at random, modulating the output surface from the By Control Points node. "
    },
    {
        "Name": "ByPoints",
        "categories": [
            "Geometry",
            "NurbsSurface"
        ],
        "folderPath": "Geometry/NurbsSurface/Create",
        "dynFile": [
            "ByPoints"
        ],
        "imageFile": [
            "ByPoints"
        ],
        "inDepth": "Nurbs Surface By Points takes in a two dimensional array of control vertices and outputs a Nurbs Surface. This node also gives us the ability to calibrate the degree in the U and V directions. In this example, a 50 by 50 grid of points is created with a Code Block Range. The grid is then scaled in the Z-direction at random, modulating the output surface from the By Control Points node. "
    },
    {
        "Name": "ByBestFitThroughPoints",
        "categories": [
            "Geometry",
            "Arc"
        ],
        "folderPath": "Geometry/Arc/Create",
        "dynFile": [
            "ByBestFitThroughPoints"
        ],
        "imageFile": [
            "ByBestFitThroughPoints"
        ],
        "inDepth": "Arc ByBestFitThroughPoints draws an arc that best represents three or more points. This example creates an arc from a list of random points ranging from 0 to 4 in the X and Y directions."
    },
    {
        "Name": "ByCenterPointRadiusAngle",
        "categories": [
            "Geometry",
            "Arc"
        ],
        "folderPath": "Geometry/Arc/Create",
        "dynFile": [
            "ByCenterPointRadiusAngle"
        ],
        "imageFile": [
            "ByCenterPointRadiusAngle"
        ],
        "inDepth": "Arc ByCenterPointRadiusAngle draws an arc relative to its center and normal direction. By entering the start and end angle, you are essentially drawing a portion of a circle. In this example, a random point is generated on the XY plane and an arc is constructed around it.  "
    },
    {
        "Name": "ByCenterPointStartPointEndPoint",
        "categories": [
            "Geometry",
            "Arc"
        ],
        "folderPath": "Geometry/Arc/Create",
        "dynFile": [
            "ByCenterPointStartPointEndPoint"
        ],
        "imageFile": [
            "ByCenterPointStartPointEndPoint"
        ],
        "inDepth": "Arc ByCenterPointStartPointEndPoint draws a best-fit arc around a specified Center. The arc will always begin at the Start Point and end at the closest point possible to the given End Point. This example demonstrates this property by randomly feeding the node three random points for the center, start and end point."
    },
    {
        "Name": "ByCenterPointStartPointSweepAngle",
        "categories": [
            "Geometry",
            "Arc"
        ],
        "folderPath": "Geometry/Arc/Create",
        "dynFile": [
            "ByCenterPointStartPointSweepAngle"
        ],
        "imageFile": [
            "ByCenterPointStartPointSweepAngle"
        ],
        "inDepth": "The Arc ByCenterPointStartPointSweepAngle creates an arc around a Center Point with a given Sweep Angle. The Start Point tells Dynamo where to begin drawing the arc. This example draws an arc around a randomly generated point."
    },
    {
        "Name": "ByFillet",
        "categories": [
            "Geometry",
            "Arc"
        ],
        "folderPath": "Geometry/Arc/Create",
        "dynFile": [
            "ByFillet"
        ],
        "imageFile": [
            "ByFillet"
        ],
        "inDepth": "Arc ByFillet draws a portion of a tangential circle along two input curves. In this example, two intersecting lines are drawn and then filleted at a controlled radius."
    },
    {
        "Name": "ByFilletTangentToCurve",
        "categories": [
            "Geometry",
            "Arc"
        ],
        "folderPath": "Geometry/Arc/Create",
        "dynFile": [
            "ByFilletTangentToCurve"
        ],
        "imageFile": [
            "ByFilletTangentToCurve"
        ],
        "inDepth": "Arc ByFilletTangentToCurve draws the best fit arc that is tangent to three input curves. In this example, we are using two input lines as reference curves and a circle for the arc to be tangent to."
    },
    {
        "Name": "ByStartPointEndPointStartTangent",
        "categories": [
            "Geometry",
            "Arc"
        ],
        "folderPath": "Geometry/Arc/Create",
        "dynFile": [
            "ByStartPointEndPointStartTangent"
        ],
        "imageFile": [
            "ByStartPointEndPointStartTangent"
        ],
        "inDepth": "Arc ByStartPointEndPointStartTangent draws an arc from two specified points and any given start vector. This example draws an arc from two random points that is always tangent to the X-Axis."
    },
    {
        "Name": "ByThreePoints",
        "categories": [
            "Geometry",
            "Arc"
        ],
        "folderPath": "Geometry/Arc/Create",
        "dynFile": [
            "ByThreePoints"
        ],
        "imageFile": [
            "ByThreePoints"
        ],
        "inDepth": "Arc ByThreePoints draws an arc from three points, given the Start Point, End Point and a point in-between along the arc. This example draws an arc from three randomly created points."
    },
    {
        "Name": "ByStartEndAndTangencies",
        "categories": [
            "Geometry",
            "Arc"
        ],
        "folderPath": "Geometry/Arc/Action",
        "dynFile": [
            "ByStartEndAndTangencies"
        ],
        "imageFile": [
            "ByStartEndAndTangencies"
        ],
        "inDepth": "The Arc ByStartEndAndTangencies Action creates a compound arc using two Input Points and their corresponding Vectors. In this example, two points are connected by a compound arc that is always tangent to the Y-Axis at its Start and End Points."
    },
    {
        "Name": "CenterPoint",
        "categories": [
            "Geometry",
            "Arc"
        ],
        "folderPath": "Geometry/Arc/Query",
        "dynFile": [
            "CenterPoint"
        ],
        "imageFile": [
            "CenterPoint"
        ],
        "inDepth": "Arc CenterPoint returns a Point at the Center of an Arc – the same point as the corresponding circle center. This example uses a randomly generated ArcByThreePoints to create the center point."
    },
    {
        "Name": "Radius",
        "categories": [
            "Geometry",
            "Arc"
        ],
        "folderPath": "Geometry/Arc/Query",
        "dynFile": [
            "Radius"
        ],
        "imageFile": [
            "Radius"
        ],
        "inDepth": "Arc Radius returns the Radius value of Arc geometry. In this example, we can visualize the change in Radius as the input points change in the Y-direction."
    },
    {
        "Name": "StartAngle",
        "categories": [
            "Geometry",
            "Arc"
        ],
        "folderPath": "Geometry/Arc/Query",
        "dynFile": [
            "StartAngle"
        ],
        "imageFile": [
            "StartAngle"
        ],
        "inDepth": "Arc StartAngle returns the Angle of the Arc relative to its corresponding Circle. Since this example uses a Start Point to generate the Arc, our Start Angle should always be equal to zero."
    },
    {
        "Name": "SweepAngle",
        "categories": [
            "Geometry",
            "Arc"
        ],
        "folderPath": "Geometry/Arc/Query",
        "dynFile": [
            "SweepAngle"
        ],
        "imageFile": [
            "SweepAngle"
        ],
        "inDepth": "Arc SweepAngle returns the total angle of the reference circle that the Arc traverses. This example shows how this property is accessed from an Arc ByThreePoints."
    },
    {
        "Name": "ByGeometry (geom) (geom)",
        "categories": [
            "Geometry",
            "BoundingBox"
        ],
        "folderPath": "Geometry/BoundingBox/Create",
        "dynFile": [
            "ByGeometry_g"
        ],
        "imageFile": [
            "ByGeometry_g"
        ],
        "inDepth": "Bounding Box ByGeometry solves for the Bounding Box of an input Geometry. This example shows a Bounding Box drawn around an input Sphere. In order to visualize the Box, we are converting the box to a Cuboid and extracting its edge curves."
    },
    {
        "Name": "ByGeometry (geom) (geom)",
        "categories": [
            "Geometry",
            "BoundingBox"
        ],
        "folderPath": "Geometry/BoundingBox/Create",
        "dynFile": [
            "ByGeometry_gg"
        ],
        "imageFile": [
            "ByGeometry_gg"
        ],
        "inDepth": "Bounding Box ByGeometry solves a Bounding Box of multiple input Geometry. This example shows a Bounding Box drawn around multiple Cones. In order to visualize the Box, we are converting the box to a Polysurface and extracting its edge curves."
    },
    {
        "Name": "ByCorners",
        "categories": [
            "Geometry",
            "BoundingBox"
        ],
        "folderPath": "Geometry/BoundingBox/Create",
        "dynFile": [
            "ByCorners"
        ],
        "imageFile": [
            "ByCorners"
        ],
        "inDepth": "Bounding Box ByCorners creates a Bounding Box from two input points. In this example we are using the diagonal vector to Translate the Start Point of the box to create its End Point. In order to visualize the Box, we are converting the box to a Polysurface and extracting its edge curves."
    },
    {
        "Name": "ToPolysurface",
        "categories": [
            "Geometry",
            "BoundingBox"
        ],
        "folderPath": "Geometry/BoundingBox/Action",
        "dynFile": [
            "ToPolysurface"
        ],
        "imageFile": [
            "ToPolysurface"
        ],
        "inDepth": "Bounding Box ToPolysurface creates a Polysurface from a Bounding Box. In this example we are using the Bounding Box of multiple Cones to create a Polysurface. In order to visualize the relationship of the input Cones to the Polysurface we are extracting the Polysurface edge curves."
    },
    {
        "Name": "Intersects",
        "categories": [
            "Geometry",
            "BoundingBox"
        ],
        "folderPath": "Geometry/BoundingBox/Action",
        "dynFile": [
            "Intersects"
        ],
        "imageFile": [
            "Intersects"
        ],
        "inDepth": "Bounding Box Intersects tests two bounding boxes for overlap. If the boxes intersect, the node will return True, otherwise it will return False. This example tests for an intersection between the Bounding Boxes of two input Cones."
    },
    {
        "Name": "Intersection",
        "categories": [
            "Geometry",
            "BoundingBox"
        ],
        "folderPath": "Geometry/BoundingBox/Action",
        "dynFile": [
            "Intersection"
        ],
        "imageFile": [
            "Intersection"
        ],
        "inDepth": "Bounding Box Intersection solves for the Intersection for two Bounding Boxes and returns the overlapping Bounding Box. This example uses two cones to demonstrate the use of this node. In order to visualize the Box we are converting it to a Cuboid."
    },
    {
        "Name": "Contains",
        "categories": [
            "Geometry",
            "BoundingBox"
        ],
        "folderPath": "Geometry/BoundingBox/Action",
        "dynFile": [
            "Contains"
        ],
        "imageFile": [
            "Contains"
        ],
        "inDepth": "Bounding Box Contains tests if a specified Point is inside of a Bounding Box. Because the Point in this example is at (5,5,5), and our Origin Sphere’s Radius is larger than 5, the Contains node will return True."
    },
    {
        "Name": "ToCuboid",
        "categories": [
            "Geometry",
            "BoundingBox"
        ],
        "folderPath": "Geometry/BoundingBox/Action",
        "dynFile": [
            "ToCuboid"
        ],
        "imageFile": [
            "ToCuboid"
        ],
        "inDepth": "Bounding Box ToCuboid creates a Cuboid geometry from a Bounding Box. In order to visualize the relationship of the input Sphere to the Cuboid in the example, we are extracting its edge curves."
    },
    {
        "Name": "MaxPoint",
        "categories": [
            "Geometry",
            "BoundingBox"
        ],
        "folderPath": "Geometry/BoundingBox/Query",
        "dynFile": [
            "MaxPoint"
        ],
        "imageFile": [
            "MaxPoint"
        ],
        "inDepth": "Bounding Box MaxPoint returns the point that has the largest X, Y and Z values. This example shows a Bounding Box MaxPoint of a Sphere."
    },
    {
        "Name": "MinPoint",
        "categories": [
            "Geometry",
            "BoundingBox"
        ],
        "folderPath": "Geometry/BoundingBox/Query",
        "dynFile": [
            "MinPoint"
        ],
        "imageFile": [
            "MinPoint"
        ],
        "inDepth": "Bounding Box MinPoint returns the point that has the smallest X, Y and Z values. This example shows a Bounding Box MinPoint of a Sphere."
    },
    {
        "Name": "ByCoordinateSystemHeightRadii",
        "categories": [
            "Geometry",
            "Cone"
        ],
        "folderPath": "Geometry/Cone/Create",
        "dynFile": [
            "ByCoordinateSystemHeightRadii"
        ],
        "imageFile": [
            "ByCoordinateSystemHeightRadii"
        ],
        "inDepth": "Cone ByCoordinateSystemHeightRadii creates a truncated Cone geometry from two Radii, the starting Origin, and a Height value. This example shows a dynamic Cone around the World Origin, constructed with three Number Sliders."
    },
    {
        "Name": "ByCoordinateSystemHeightRadius",
        "categories": [
            "Geometry",
            "Cone"
        ],
        "folderPath": "Geometry/Cone/Create",
        "dynFile": [
            "ByCoordinateSystemHeightRadius"
        ],
        "imageFile": [
            "ByCoordinateSystemHeightRadius"
        ],
        "inDepth": "Cone ByCoordinateSystemHeightRadius creates a Cone geometry from a Radius, the Cone Origin, and a Height value. This example shows a dynamic Cone around the World Origin, constructed with two Number Sliders."
    },
    {
        "Name": "ByPointsRadii",
        "categories": [
            "Geometry",
            "Cone"
        ],
        "folderPath": "Geometry/Cone/Create",
        "dynFile": [
            "ByPointsRadii"
        ],
        "imageFile": [
            "ByPointsRadii"
        ],
        "inDepth": "Cone ByPointsRadii creates a truncated Cone geometry from a Start Point, End Point, and two Radius values. This example shows a dynamic Cone around the World Origin, constructed with three Number Sliders controlling its Height and Radius sizes."
    },
    {
        "Name": "ByPointsRadius",
        "categories": [
            "Geometry",
            "Cone"
        ],
        "folderPath": "Geometry/Cone/Create",
        "dynFile": [
            "ByPointsRadius"
        ],
        "imageFile": [
            "ByPointsRadius"
        ],
        "inDepth": "Cone ByPointsRadius creates a Cone geometry from a Start Point, End Point, and a Radius value. This example shows a dynamic Cone around the World Origin, constructed with two Number Sliders controlling its Height and Radius size."
    },
    {
        "Name": "ClosestPointTo",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "dynFile": [
            "ClosestPointTo"
        ],
        "imageFile": [
            "ClosestPointTo"
        ],
        "inDepth": "Geometry ClosestPointTo finds the closest point from one geometry to another, adding a 3D Point to the document. This example finds the closest point on one Sphere to another."
    },
    {
        "Name": "DistanceTo",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "dynFile": [
            "DistanceTo"
        ],
        "imageFile": [
            "DistanceTo"
        ],
        "inDepth": "Geometry DistanceTo returns the distance between two geometries. This example finds the distance between two Spheres."
    },
    {
        "Name": "DoesIntersect",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "dynFile": [
            "DoesIntersect"
        ],
        "imageFile": [
            "DoesIntersect"
        ],
        "inDepth": "Geometry DoesIntersect tests two geometries for an intersection. If the objects intersect, the Node will return True. This example tests for an intersection of two Sphere geometries."
    },
    {
        "Name": "Explode",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "dynFile": [
            "Explode"
        ],
        "imageFile": [
            "Explode"
        ],
        "inDepth": "The Geometry Explode Node breaks a geometry down into smaller components. For example, a Polysurface can be Exploded into several Surfaces and a Polycurve into curves. In this example, we are extracting a single Surface from a complex Intersection of three Spheres."
    },
    {
        "Name": "ExportToSAT (geometry, filePath)",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "dynFile": [
            "ExportToSAT_gf"
        ],
        "imageFile": [
            "ExportToSAT_gf"
        ],
        "inDepth": "Geometry ExportToSAT exports Geometry from Dynamo to a SAT file type. In this example, we are exporting a Polysurface from the Intersection of three Spheres."
    },
    {
        "Name": "ImportFromSAT (filePath)",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "dynFile": [
            "ImportFromSAT"
        ],
        "imageFile": [
            "ImportFromSAT"
        ],
        "inDepth": "Geometry ImportFromSAT imports Geometry to Dynamo from a SAT file type. This node takes a filePath as input, and also accepts a string with a valid file path. For the example below, we previously exported geometry to a SAT file (see ExportToSAT). The file name we chose was example.sat and it was exported to a folder on the users desktop. In the example, we show two different nodes used to import geometry from a SAT file. One has a filePath as the input type, and the other has a 'file' as the input type. The filePath is created using a FilePath node, which can select a file by clicking the Browse button. In the second example, we specify the file path manually by using a string element."
    },
    {
        "Name": "ImportFromSAT (file)",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "dynFile": [
            "ImportFromSAT"
        ],
        "imageFile": [
            "ImportFromSAT"
        ],
        "inDepth": "Geometry ImportFromSAT imports Geometry to Dynamo from a SAT file type. This node takes a file as input, and also accepts a string with a valid file path. For the example below, we previously exported geometry to a SAT file (see ExportToSAT). The file name we chose was example.sat and it was exported to a folder on the users desktop. In the example, we show two different nodes used to import geometry from a SAT file. One has a filePath as the input type, and the other has a 'file' as the input type. The filePath is created using a FilePath node, which can select a file by clicking the Browse button. In the second example, we specify the file path manually by using a string element."
    },
    {
        "Name": "Intersect",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "dynFile": [
            "Intersect"
        ],
        "imageFile": [
            "Intersect"
        ],
        "inDepth": "Geometry Intersect finds the Intersection Geometry that two Geometry objects share. In this example, the Intersection of two Spheres returns a Polysurface, otherwise known as a Solid Intersection."
    },
    {
        "Name": "IntersectAll",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "dynFile": [
            "IntersectAll"
        ],
        "imageFile": [
            "IntersectAll"
        ],
        "inDepth": "Geometry IntersectAll finds the Intersection Geometry that any number of Geometry objects share. In this example, the Intersection of three Spheres returns a Polysurface, otherwise known as a Solid Intersection."
    },
    {
        "Name": "Mirror",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "dynFile": [
            "Mirror"
        ],
        "imageFile": [
            "Mirror"
        ],
        "inDepth": "Geometry Mirror reflects a Geometry across a defined Plane. In this example, we are Mirroring a Cone across the Y-Axis."
    },
    {
        "Name": "Rotate (geometry, origin, axis, degrees)",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "dynFile": [
            "Rotate_goad"
        ],
        "imageFile": [
            "Rotate_goad"
        ],
        "inDepth": "This Geometry Rotate Node Rotates an input Geometry around a Base Plane by a defined Degree. In the example file, a Cone is Rotated around the XY-Plane with a Number Slider."
    },
    {
        "Name": "Rotate (geometry, basePlane, degrees)",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "dynFile": [
            "Rotate_gbd"
        ],
        "imageFile": [
            "Rotate_gbd"
        ],
        "inDepth": "This Geometry Rotate Node Rotates an input Geometry around an Origin Point and Axis Vector by a certain Degree amount. In the example file, a Cone is Rotated about the Y-Axis Vector by its End Point."
    },
    {
        "Name": "Scale (geometry, basePoint, from, to)",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "dynFile": [
            "Scale_gbft"
        ],
        "imageFile": [
            "Scale_gbft"
        ],
        "inDepth": "This Geometry Scale Node Scales an input Geometry from three reference Points. In this example, we are scaling a Cone relative to its End Point from its Start Point to its Centroid. The Cone Circle and side Edge are drawn as a visual reference of the Scale."
    },
    {
        "Name": "Scale (geometry, amount)",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "dynFile": [
            "Scale_ga"
        ],
        "imageFile": [
            "Scale_ga"
        ],
        "inDepth": "This Geometry Scale Node Scales an input Geometry from the object Centroid by an input factor. In the example file, a Cone is scaled down with a Number Slider. The original Cone Edges are drawn for a visual reference."
    },
    {
        "Name": "Scale (geometry, xamount, yamount, zamount)",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "dynFile": [
            "Scale_gxyz"
        ],
        "imageFile": [
            "Scale_gxyz"
        ],
        "inDepth": "This Geometry Scale Node Scales an input Geometry from the object Centroid by an input factor. In the example, a Cone’s Scale can be finely tuned with three Number Sliders. The original Cone Edges are drawn as a visual reference."
    },
    {
        "Name": "Scale (geometry, plane, xamount, yamount, zamount)",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "dynFile": [
            "Scale_gpxyz"
        ],
        "imageFile": [
            "Scale_gpxyz"
        ],
        "inDepth": "This Geometry Scale Node Scales an input Geometry about a Plane by specified X, Y and Z factors. This example shows a Cone before and after it is scaled in relationship to the YZ-Plane."
    },
    {
        "Name": "Scale1D",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "dynFile": [
            "Scale1D"
        ],
        "imageFile": [
            "Scale1D"
        ],
        "inDepth": "Geometry Scale1D Scales a Geometry in one direction from a Base Point and two reference Points. In the example file, a Cone is scaled from its End Point to its Centroid in relation to the Cone Start Point. The original Cone Edges are drawn as a visual reference."
    },
    {
        "Name": "Scale2D",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "dynFile": [
            "Scale2D"
        ],
        "imageFile": [
            "Scale2D"
        ],
        "inDepth": "Geometry Scale2D Scales a Geometry in two directions from a Base Plane and two reference Points. In the example file, a Cone is scaled from its End Point to its Centroid in relation to the YZ-Plane."
    },
    {
        "Name": "Split",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "dynFile": [
            "Split"
        ],
        "imageFile": [
            "Split"
        ],
        "inDepth": "The Geometry Split Node functions similarly to the Geometry Trim Node. It inputs a Tool – any type of Geometry that you will be trimming another Geometry with – and a Geometry, and returns all of the fragments of Geometry. In this example, a Cone is Split with a similar Cone. Although all fragments are returned by the Geometry Split Node, one is previewed in the example file."
    },
    {
        "Name": "Transform (geometry, fromCoordinateSystem, contextCoordinateSystem)",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "dynFile": [
            "Transform_gfc"
        ],
        "imageFile": [
            "Transform_gfc"
        ],
        "inDepth": "This Geometry Transform Node moves and orients a geometry from one Coordinate System plane to another specified Coordinate System. In this example a Cone is Transformed from the ground plane to the YZ-Plane."
    },
    {
        "Name": "Transform (geometry, cs)",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "dynFile": [
            "Transform_gc"
        ],
        "imageFile": [
            "Transform_gc"
        ],
        "inDepth": "This Geometry Transform Node moves and orients a geometry from the XY-Plane to any specified Plane. In this example a Cone is Transformed from the XY-Plane to the YZ-Plane."
    },
    {
        "Name": "Translate (geometry, direction)",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "dynFile": [
            "Translate_gd"
        ],
        "imageFile": [
            "Translate_gd"
        ],
        "inDepth": "This Geometry Translate Node moves a geometry by any given Vector. In the example file, we are Translating a Cone by the Vector created between the Start and End Points of the Cone."
    },
    {
        "Name": "Translate (geometry, xTranslation, yTranslation, zTranslation)",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "dynFile": [
            "Translate_gxyz"
        ],
        "imageFile": [
            "Translate_gxyz"
        ],
        "inDepth": "This Geometry Translate Node moves a geometry by any given Vector direction and a Distance. In the example file, we are Translating a Cone in the X-Axis direction by a distance inherited by a Number Slider."
    },
    {
        "Name": "Translate (geometry, direction, distance)",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "dynFile": [
            "Translate_gdd"
        ],
        "imageFile": [
            "Translate_gdd"
        ],
        "inDepth": "This Geometry Translate Node moves a geometry by a Vector defined in the Node by inputting all three Translation Values for X, Y and Z. In the example file, a Cone is Translated by three Number Slider values."
    },
    {
        "Name": "Trim",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "folderPath": "Geometry/Geometry/Action",
        "dynFile": [
            "Trim"
        ],
        "imageFile": [
            "Trim"
        ],
        "inDepth": "Geometry Trim functions similarly to the Geometry Split Node in that it inputs a Tool – any type of Geometry that you will be trimming another Geometry with – and a Geometry, but returns only a single fragment of the Geometry. The Geometry that is Picked is selected by a reference Point closest to the fragment. In this example, one Cone is Trimmed by another, with its lower portion Picked."
    },
    {
        "Name": "ByCorners",
        "categories": [
            "Geometry",
            "Cuboid"
        ],
        "folderPath": "Geometry/Cuboid/Create",
        "dynFile": [
            "ByCorners"
        ],
        "imageFile": [
            "ByCorners"
        ],
        "inDepth": "Cuboid By Corners creates a cuboid where the two input points are used as the opposite corners of the cuboid. In the example file, two points are randomly generated and used to create a cuboid."
    },
    {
        "Name": "ByLengths (width, length, height)",
        "categories": [
            "Geometry",
            "Cuboid"
        ],
        "folderPath": "Geometry/Cuboid/Create",
        "dynFile": [
            "ByLengths"
        ],
        "imageFile": [
            "ByLengths"
        ],
        "inDepth": "Cuboid By Lengths creates a cuboid with the input width, legth, and height, and is centered at the origin. In the example, we use three number sliders to input the length, width and height."
    },
    {
        "Name": "ByLengths (origin, width, length, height)",
        "categories": [
            "Geometry",
            "Cuboid"
        ],
        "folderPath": "Geometry/Cuboid/Create",
        "dynFile": [
            "ByLengths_origin"
        ],
        "imageFile": [
            "ByLengths_origin"
        ],
        "inDepth": "This Cuboid By Lengths allows the user to input an origin point for the center of the cuboid, as well as the length, width and height of the cuboid. In the example file, we use three number sliders to input the length, width, and height, and generate a random point to use as the origin."
    },
    {
        "Name": "ByLengths (cs, width, length, height)",
        "categories": [
            "Geometry",
            "Cuboid"
        ],
        "folderPath": "Geometry/Cuboid/Create",
        "dynFile": [
            "ByLengths_cs"
        ],
        "imageFile": [
            "ByLengths_cs"
        ],
        "inDepth": "This Cuboid By Lengths allows the user to input a Coordinate System. The cuboid will be created at the origin of the input Coordinate System, with the length, width, and heigh oriented according to the Coordinate System. In the example, we use three number sliders to input the length, width, and heigh, and generate random coordinates to use to create a Coordinate System."
    },
    {
        "Name": "Height",
        "categories": [
            "Geometry",
            "Cuboid"
        ],
        "folderPath": "Geometry/Cuboid/Query",
        "dynFile": [
            "Height"
        ],
        "imageFile": [
            "Height"
        ],
        "inDepth": "This returns the height of the input cuboid. In the example, we generate a cuboid by corners, and then use a Height query to find the height. Note that if the cuboid has been transformed to a different coordinate system with a scale factor, this will return the orignal dimension of the cuboid, not the world space dimensions."
    },
    {
        "Name": "Width",
        "categories": [
            "Geometry",
            "Cuboid"
        ],
        "folderPath": "Geometry/Cuboid/Query",
        "dynFile": [
            "Width"
        ],
        "imageFile": [
            "Width"
        ],
        "inDepth": "This returns the width of the input cuboid. In the example, we generate a cuboid by corners, and then use a Width query to find the height. Note that if the cuboid has been transformed to a different coordinate system with a scale factor, this will return the orignal dimension of the cuboid, not the world space dimensions."
    },
    {
        "Name": "Length",
        "categories": [
            "Geometry",
            "Cuboid"
        ],
        "folderPath": "Geometry/Cuboid/Query",
        "dynFile": [
            "Length"
        ],
        "imageFile": [
            "Length"
        ],
        "inDepth": "This returns the Length of the input cuboid. In the example, we generate a cuboid by corners, and then use a Length query to find the height.  Note that if the cuboid has been transformed to a different coordinate system with a scale factor, this will return the orignal dimension of the cuboid, not the world space dimensions."
    },
    {
        "Name": "List.Create",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Create",
        "dynFile": [
            "ListCreate"
        ],
        "imageFile": [
            "ListCreate"
        ],
        "inDepth": "List.Create allows a list to be created manually by connecting each individual element to be included in the list. Use the '+' and '-' buttons to increase or decrease the number of available input nodes. In the example, we have three number sliders combined together into a list."
    },
    {
        "Name": "Range",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Create",
        "dynFile": [
            "Range"
        ],
        "imageFile": [
            "Range"
        ],
        "inDepth": "Range will produce a list of numbers between the specified Start and End inputs. The numbers will increase from the Start input according to the Step. In the example below, we start with 1 and end with 25. By using a step of 2 the result is odd numbers between 1 and 25."
    },
    {
        "Name": "Sequence",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Create",
        "dynFile": [
            "Sequence"
        ],
        "imageFile": [
            "Sequence"
        ],
        "inDepth": "Sequence will produce a list of numbers. The list begins at the Start input, and then increments by the Step input. The Amount input determines the number of items in the list. In the example, we create a list of 25 numbers, starting at 1 and incrementing by 2."
    },
    {
        "Name": "DropEveryNthItem",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "DropEveryNthItem"
        ],
        "imageFile": [
            "DropEveryNthItem"
        ],
        "inDepth": "Drop Every Nth Item will remove items from the input list at intervals of the input 'n' value. The starting point of the interval can be changed with the 'offset' input. For example, putting 3 into 'n' and leaving the 'offset' as the default of zero will removie items with indices 2, 5, 8, etc. Changing the offset to 1 would instead remove items with indices 0, 3, 6, etc. Notice that the offset 'wraps' through the entire list. To keep selected items instead of removing, see 'TakeEveryNthItem'. In the example below, we first generate a list of numbers using Range, and then remove every other number by using 2 as the input for 'n'."
    },
    {
        "Name": "DropItems",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "DropItems"
        ],
        "imageFile": [
            "DropItems"
        ],
        "inDepth": "Drop Items will remove the input 'amount' number of items from the list. If the 'amount' is positive, the numbers will be removed from the beginning of the list. If the 'amount' is negative, the items will be removed from the end of the list.  In the example below, we first create a list using Range, then drop the first item in the list by using Drop Item with an 'amount' of 1."
    },
    {
        "Name": "FilterByBoolMask",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "FilterByBoolMask"
        ],
        "imageFile": [
            "FilterByBoolMask"
        ],
        "inDepth": "Filter By Bool Mask takes two lists as inputs. The first list will be split into two separate lists according to a corresponding list of boolean (True or False) values. Items from the 'list' input that correspond to a True in the 'mask' input will go to the output labelled 'in', while those items that correspond to a 'False' value will go the 'out' output. In the example below, we use a modulus operator (%) and an equality operator (==) to test each item in the list for divisibility by three. The result after FilterByBoolMask is two lists, the first containing the items that are divisible by 3, and the second containing items that are not divisible by 3. "
    },
    {
        "Name": "Reverse",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "Reverse"
        ],
        "imageFile": [
            "Reverse"
        ],
        "inDepth": "Reverse simply takes the items in a list and creates a new list with the order of items reversed. In the example, we first generate a list using Range, which produces numbers in increasing order, then we use Reverse to switch the order of the items in the list."
    },
    {
        "Name": "ShiftIndices",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "ShiftIndices"
        ],
        "imageFile": [
            "ShiftIndices"
        ],
        "inDepth": "Shift Indices will shift the position of the items in a list by the 'amount' input. A positive amount will shift the numbers up, while a negative amount will shift the indices backwards. The items wrap around, causing items at the back of the list to wrap to the beginning. In the example we first generate a list with Range, then shift the indices forward by 3."
    },
    {
        "Name": "Shuffle",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "Shuffle"
        ],
        "imageFile": [
            "Shuffle"
        ],
        "inDepth": "Shuffle will take an input list and randomize the order of the items. In the example, we first generate a list using Range, and then use Shuffle to produce a randomized list."
    },
    {
        "Name": "Sort",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "Sort"
        ],
        "imageFile": [
            "Sort"
        ],
        "inDepth": "Sort will sort a list of items according to the built-in ordering for the data type. For example, a list of numbers will be sorted into numerical order from least to greatest, while a list of strings will be sorted alphabetically. In the example below, we use Random List to first generate a list of random numbers between 0 and 1. We then multiply by 10 and use a Floor operation to get a list of random integers between 0 and 9. Sort then creates a sorted list from least to greatest."
    },
    {
        "Name": "TakeEveryNthItem",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "TakeEveryNthItem"
        ],
        "imageFile": [
            "TakeEveryNthItem"
        ],
        "inDepth": "Drop Every Nth Item will produce a new list keeping items from the input list at intervals of the input 'n' value. The starting point of the interval can be changed with the 'offset' input. For example, putting 3 into 'n' and leaving the 'offset' as the default of zero will keep items with indices 2, 5, 8, etc. Changing the offset to 1 would instead keep items with indices 0, 3, 6, etc. Notice that the offset 'wraps' through the entire list. To remove selected items instead of keeping them, see 'DropEveryNthItem'. In the example below, we first generate a list of numbers using Range, and then keep every other number by using 2 as the input for 'n'."
    },
    {
        "Name": "Transpose",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "Transpose"
        ],
        "imageFile": [
            "Transpose"
        ],
        "inDepth": "Transpose will take a list a lists and swap the rows and columns. For example, a list that contains 5 sub-lists of 10 items each would be transposed to 10 lists of 5 items each. In the example, we generate two Random Lists, and then use List.Create to combine them. The result is two lists with 3 and 4 items. Transpose switches this to 4 lists of 2 items each. Notice that since one of the original lists was longer than the other, Transpose inserted a null value for the unpaired item."
    },
    {
        "Name": "UniqueItems",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "UniqueItems"
        ],
        "imageFile": [
            "UniqueItems"
        ],
        "inDepth": "Unique Item will remove all duplicate items from a input list. In the example below, we use Random List to first generate a list of random numbers between 0 and 1. We then multiply by 10 and use a Floor operation to get a list of random integers between 0 and 9, with many of them repeated multiple times. After using Unique Item, we are left with a list in which each integer only occurs once. The order of the output list will be according to the first found instance of an item. "
    },
    {
        "Name": "CenterPoint",
        "categories": [
            "Geometry",
            "Circle"
        ],
        "folderPath": "Geometry/Circle/Query",
        "dynFile": [
            "CenterPoint"
        ],
        "imageFile": [
            "CenterPoint"
        ],
        "inDepth": "Center Point will find the center point of a given circle. In the example below, we create a circle using Best Fit Through Points, and then extract the center point of the generated circle. "
    },
    {
        "Name": "Radius",
        "categories": [
            "Geometry",
            "Circle"
        ],
        "folderPath": "Geometry/Circle/Query",
        "dynFile": [
            "Radius"
        ],
        "imageFile": [
            "Radius"
        ],
        "inDepth": "Radius will find the center point of a given circle. In the example below, we create a circle using Best Fit Through Points, and then extract the radius of the generated circle.  "
    },
    {
        "Name": "EndPoint",
        "categories": [
            "Geometry",
            "Cone"
        ],
        "folderPath": "Geometry/Cone/Query",
        "dynFile": [
            "EndPoint"
        ],
        "imageFile": [
            "EndPoint"
        ],
        "inDepth": "End Point will find the apex of a cone, or the center of the top circle of a truncated cone. In the example below, we create a cone by specifying a Coordinate System and two radii. We then use End Point to find the center of the top circle of the cone. "
    },
    {
        "Name": "EndRadius",
        "categories": [
            "Geometry",
            "Cone"
        ],
        "folderPath": "Geometry/Cone/Query",
        "dynFile": [
            "EndRadius"
        ],
        "imageFile": [
            "EndRadius"
        ],
        "inDepth": "End Radius will find the radius of the top circle of a truncated cone. In the example below, we create a cone by specifying a start and end point, as well as a start and end radius. We can then extract the End Radius back from the cone."
    },
    {
        "Name": "Height",
        "categories": [
            "Geometry",
            "Cone"
        ],
        "folderPath": "Geometry/Cone/Query",
        "dynFile": [
            "Height"
        ],
        "imageFile": [
            "Height"
        ],
        "inDepth": "Height will find the height of the cone, which is equal to the distance between the start point and end point. In the example below, we create a cone by specifying a start and end point, as well as a start and end radius. We can then extract the height out from the cone."
    },
    {
        "Name": "RadiusRatio",
        "categories": [
            "Geometry",
            "Cone"
        ],
        "folderPath": "Geometry/Cone/Query",
        "dynFile": [
            "RadiusRatio"
        ],
        "imageFile": [
            "RadiusRatio"
        ],
        "inDepth": "Radius Ratio will find the ratio between the top and bottom radii of the cone. This is equivalent to taking the top radius and dividing it by the bottom radius. In the example below, we create a cone by specifying a start and end point, as well as a start and end radius. We can then extract the Radius Ratio from the cone."
    },
    {
        "Name": "StartPoint",
        "categories": [
            "Geometry",
            "Cone"
        ],
        "folderPath": "Geometry/Cone/Query",
        "dynFile": [
            "StartPoint"
        ],
        "imageFile": [
            "StartPoint"
        ],
        "inDepth": "Start Point will find the center of the base of a cone. In the example below, we create a cone by specifying a Coordinate System and two radii. We then use Start Point to find the center of the bottom circle of the cone. "
    },
    {
        "Name": "StartRadius",
        "categories": [
            "Geometry",
            "Cone"
        ],
        "folderPath": "Geometry/Cone/Query",
        "dynFile": [
            "StartRadius"
        ],
        "imageFile": [
            "StartRadius"
        ],
        "inDepth": "Start Radius will find the radius of the base circle of a cone. In the example below, we create a cone by specifying a start and end point, as well as a start and end radius. We can then extract the Start Radius back from the cone."
    },
    {
        "Name": "ByCoordinateSystemRadii",
        "categories": [
            "Geometry",
            "Ellipse"
        ],
        "folderPath": "Geometry/Ellipse/Create",
        "dynFile": [
            "ByCoordinateSystemRadii"
        ],
        "imageFile": [
            "ByCoordinateSystemRadii"
        ],
        "inDepth": "Ellipse by Coordinate System Radii takes a coordinate system as an input, then creates an ellipse using the inputted radii. The input xAxisRadius and yAxisRadius correspond to the X and Y directions of the input Coordinate System (not the World X and Y directions). In the example file, we generate two random values to create a Coordinate System, then use that Coordinate System with two number sliders for the x and y radii."
    },
    {
        "Name": "ByOriginRadii",
        "categories": [
            "Geometry",
            "Ellipse"
        ],
        "folderPath": "Geometry/Ellipse/Create",
        "dynFile": [
            "ByOriginRadii"
        ],
        "imageFile": [
            "ByOriginRadii"
        ],
        "inDepth": "Ellipse by Origin Radii creates an ellipse centered on the input Origin point, and has an x and y radius from the input xAxisRadius and yAxisRadius. This ellipse will be aligned with the World XY plane. In the example below, we generate two random numbers to create an origin point, then use two number sliders for the x and y axis radii."
    },
    {
        "Name": "ByOriginVectors",
        "categories": [
            "Geometry",
            "Ellipse"
        ],
        "folderPath": "Geometry/Ellipse/Create",
        "dynFile": [
            "ByOriginVectors"
        ],
        "imageFile": [
            "ByOriginVectors"
        ],
        "inDepth": "Ellipse by Origin Vectors creates an ellipse centered on the input origin points. In this case, the XAxisRadius and YAxisRadius require vectors as inputs. The two vectors must be orthogonal (at right angles) to each other. The two vectors will determine the plane of the ellipse. They need not be in the world X and Y directions. In the example, we first create an origin point by generating two random numbers. We then use a unit X and unit Y vector, which are then scaled by number sliders."
    },
    {
        "Name": "ByPlaneRadii",
        "categories": [
            "Geometry",
            "Ellipse"
        ],
        "folderPath": "Geometry/Ellipse/Create",
        "dynFile": [
            "ByPlaneRadii"
        ],
        "imageFile": [
            "ByPlaneRadii"
        ],
        "inDepth": "Ellipse by Plane Radii creates an ellipse centered at the input plane. The xAxisRadius and yAxisRadius take numbers as inputs, and correspond to the X and Y diretions of the input plane, which may be different from world X and Y directions. In the example below, we use a YZ plane as the input, then use two number sliders for the xAxisRadius and yAxisRadius. Because we used a YZ plane, the input xAxisRadius will correspond to the world Y direction, while the yAxisRadius will correspond to the world Z direction."
    },
    {
        "Name": "CenterPoint",
        "categories": [
            "Geometry",
            "Ellipse"
        ],
        "folderPath": "Geometry/Ellipse/Query",
        "dynFile": [
            "CenterPoint"
        ],
        "imageFile": [
            "CenterPoint"
        ],
        "inDepth": "Center Point will return the center point of an input ellipse. Note that this point does not contain any information about the orientation or plane of the ellipse. In the example below, we first create an ellipse by Plane Radii, then find the center point."
    },
    {
        "Name": "MajorAxis",
        "categories": [
            "Geometry",
            "Ellipse"
        ],
        "folderPath": "Geometry/Ellipse/Query",
        "dynFile": [
            "MajorAxis"
        ],
        "imageFile": [
            "MajorAxis"
        ],
        "inDepth": "Major Axis will return the longer of the two axes of the ellipse. The axis is output as a vector, which has a magnitude equal to the larger of the two radii. Note that Major and Minor axes are determined by length, not by direction. That is, the major axis might correspond to the xAxisRadius of one ellipse, but the yAxisRadius of a different ellipse."
    },
    {
        "Name": "MinorAxis",
        "categories": [
            "Geometry",
            "Ellipse"
        ],
        "folderPath": "Geometry/Ellipse/Query",
        "dynFile": [
            "MinorAxis"
        ],
        "imageFile": [
            "MinorAxis"
        ],
        "inDepth": "Minor Axis will return the shorter of the two axes of the ellipse. The axis is output as a vector, which has a magnitude equal to the shorter of the two radii. Note that Major and Minor axes are determined by length, not by direction. That is, the minor axis might correspond to the xAxisRadius of one ellipse, but the yAxisRadius of a different ellipse."
    },
    {
        "Name": "ByPlaneRadiiAngles",
        "categories": [
            "Geometry",
            "EllipseArc"
        ],
        "folderPath": "Geometry/EllipseArc/Create",
        "dynFile": [
            "ByPlaneRadiiAngles"
        ],
        "imageFile": [
            "ByPlaneRadiiAngles"
        ],
        "inDepth": "Ellipse Arc by Plane Radii Angles creates a portion of an ellipse. The input xRadius and yRadius give the radii of the ellipse along the X and Y directions of the input plane (which may be different than world X and Y). The startAngle input defines the beginning point of the arc along the ellipse in degrees, starting counter-clockwise from the plane X-axis, and continuing for a total arc length of the sweepAngle input. In the example below, we use the XY plane, and a series of number sliders to control the other input parameters."
    },
    {
        "Name": "CenterPoint",
        "categories": [
            "Geometry",
            "EllipseArc"
        ],
        "folderPath": "Geometry/EllipseArc/Query",
        "dynFile": [
            "CenterPoint"
        ],
        "imageFile": [
            "CenterPoint"
        ],
        "inDepth": "Center Point finds the center point of an ellipse arc, which is the same as the center point of the completed ellipse. In the example, we first create an Ellipse Arc by using the XY plane and a series of number sliders. We then use CenterPoint to extract the center of the ellipse."
    },
    {
        "Name": "MajorAxis",
        "categories": [
            "Geometry",
            "EllipseArc"
        ],
        "folderPath": "Geometry/EllipseArc/Query",
        "dynFile": [
            "MajorAxis"
        ],
        "imageFile": [
            "MajorAxis"
        ],
        "inDepth": "Major Axis will return the longer of the two axes of the ellipse. The axis is output as a vector, which has a magnitude equal to the larger of the two radii. Note that Major and Minor axes are determined by length, not by direction. That is, the major axis might correspond to the xAxisRadius of one ellipse, but the yAxisRadius of a different ellipse. In the example, we first create an Ellipse Arc by using the XY plane and a series of number sliders. We then use Major Axis to extract the major axis of the ellipse."
    },
    {
        "Name": "MinorAxis",
        "categories": [
            "Geometry",
            "EllipseArc"
        ],
        "folderPath": "Geometry/EllipseArc/Query",
        "dynFile": [
            "MinorAxis"
        ],
        "imageFile": [
            "MinorAxis"
        ],
        "inDepth": "Minor Axis will return the shorter of the two axes of the ellipse. The axis is output as a vector, which has a magnitude equal to the shorter of the two radii. Note that Major and Minor axes are determined by length, not by direction. That is, the minor axis might correspond to the xAxisRadius of one ellipse, but the yAxisRadius of a different ellipse.  In the example, we first create an Ellipse Arc by using the XY plane and a series of number sliders. We then use Minor Axis to extract the minor axis of the ellipse."
    },
    {
        "Name": "Plane",
        "categories": [
            "Geometry",
            "EllipseArc"
        ],
        "folderPath": "Geometry/EllipseArc/Query",
        "dynFile": [
            "Plane"
        ],
        "imageFile": [
            "Plane"
        ],
        "inDepth": "Plane finds the center point of an ellipse arc, which is the same as the plane of the completed ellipse. In the example, we first create an Ellipse Arc by using the XY plane and a series of number sliders. We then use Plane to extract the plane of the ellipse."
    },
    {
        "Name": "StartAngle",
        "categories": [
            "Geometry",
            "EllipseArc"
        ],
        "folderPath": "Geometry/EllipseArc/Query",
        "dynFile": [
            "StartAngle"
        ],
        "imageFile": [
            "StartAngle"
        ],
        "inDepth": "Start Angle finds the starting angle of the ellipse arc. This is measured in degrees counter-clockwise starting from the plane X-axis. In the example, we first create an Ellipse Arc by using the XY plane and a series of number sliders. We then use Start Angle to extract the angle of the beginning pont of the ellipse."
    },
    {
        "Name": "SweepAngle",
        "categories": [
            "Geometry",
            "EllipseArc"
        ],
        "folderPath": "Geometry/EllipseArc/Query",
        "dynFile": [
            "SweepAngle"
        ],
        "imageFile": [
            "SweepAngle"
        ],
        "inDepth": "Sweep Angle finds the starting angle of the ellipse arc. This is measured in degrees counter-clockwise on the ellipse plane, starting from the start angle. The end angle of the ellipse would be equal to the start angle plus the sweep angle. In the example, we first create an Ellipse Arc by using the XY plane and a series of number sliders. We then use Sweep Angle to extract arc length of the ellipse arc."
    },
    {
        "Name": "ByAxis",
        "categories": [
            "Geometry",
            "Helix"
        ],
        "folderPath": "Geometry/Helix/Create",
        "dynFile": [
            "ByAxis"
        ],
        "imageFile": [
            "ByAxis"
        ],
        "inDepth": "Helix By Axis creates a helix. The axis of the helix is defined by the input axis point and the axis direction. The helix will be created counter-clockwise around the axis, starting from the start point and continuing for an angular length of the Angle Turns input, in degrees. The Pitch input determines the distance of the helix per each 360 degrees in the direction of the axis. In the example below, we start the helix at the point (3,5) and use the Y-axis to define the helix axis. The start point of the helix is controlled by three number sliders. The pitch and angleTurns use two more number sliders. Note that the angleTurns is in degrees."
    },
    {
        "Name": "Angle",
        "categories": [
            "Geometry",
            "Helix"
        ],
        "folderPath": "Geometry/Helix/Query",
        "dynFile": [
            "Angle"
        ],
        "imageFile": [
            "Angle"
        ],
        "inDepth": "Angle will find the total angular length of a helix in degrees, where one complete turn is equal to 360. In the example below, we create a helix using Helix By Axis, then use Angle to find the total angle of the helix."
    },
    {
        "Name": "AxisDirection",
        "categories": [
            "Geometry",
            "Helix"
        ],
        "folderPath": "Geometry/Helix/Query",
        "dynFile": [
            "AxisDirection"
        ],
        "imageFile": [
            "AxisDirection"
        ],
        "inDepth": "Axis Direction will return the direction of the central axis of a helix as a vector. Together with the Axis Point, this defines the central axis. In the example below, we create a helix using Helix By Axis, then use Axis Direction to find the direction of the helix axis."
    },
    {
        "Name": "AxisPoint",
        "categories": [
            "Geometry",
            "Helix"
        ],
        "folderPath": "Geometry/Helix/Query",
        "dynFile": [
            "AxisPoint"
        ],
        "imageFile": [
            "AxisPoint"
        ],
        "inDepth": "Axis Point will return the base point of the helix axis. Together with the Axis Direction, this defines the central axis of a helix. In the example below, we create a helix using Helix By Axis, then use Axis Point to find the initial point of the helix axis."
    },
    {
        "Name": "Pitch",
        "categories": [
            "Geometry",
            "Helix"
        ],
        "folderPath": "Geometry/Helix/Query",
        "dynFile": [
            "Pitch"
        ],
        "imageFile": [
            "Pitch"
        ],
        "inDepth": "Pitch will return the linear distance along the axis direction that a helix spans in one complete turn (360 degrees). In the example below, we create a helix using Helix by Axis, then use Pitch to find the pitch of the helix."
    },
    {
        "Name": "Radius",
        "categories": [
            "Geometry",
            "Helix"
        ],
        "folderPath": "Geometry/Helix/Query",
        "dynFile": [
            "Radius"
        ],
        "imageFile": [
            "Radius"
        ],
        "inDepth": "Radius will return the distance from the central axis to the point on the helix on a plane perpendicular to the axis. In the example below, we create a helix using Helix by Axis, then use Radius to find the radius of the helix."
    },
    {
        "Name": "ByBestFitThroughPoints",
        "categories": [
            "Geometry",
            "Line"
        ],
        "folderPath": "Geometry/Line/Create",
        "dynFile": [
            "ByBestFitThroughPoints"
        ],
        "imageFile": [
            "ByBestFitThroughPoints"
        ],
        "inDepth": "Line by Best Fit Through Points will create a line by approximating a scatter plot of points. The input is a list of points. In this example, we use a number slider to control the number of random points generated, and then find the best fit line through the set of points. "
    },
    {
        "Name": "ByStartPointDirectionLength",
        "categories": [
            "Geometry",
            "Line"
        ],
        "folderPath": "Geometry/Line/Create",
        "dynFile": [
            "ByStartPointDirectionLength"
        ],
        "imageFile": [
            "ByStartPointDirectionLength"
        ],
        "inDepth": "Line by Start Point Direction Length creates a line beginning at the startPoint input, and with a length and direction according to the input direction vector and length. In the example below, we use a code block specify the x,y, and z coordinates of a point. We then use a number slider to control the length of the line."
    },
    {
        "Name": "ByStartPointEndPoint",
        "categories": [
            "Geometry",
            "Line"
        ],
        "folderPath": "Geometry/Line/Create",
        "dynFile": [
            "ByStartPointEndPoint"
        ],
        "imageFile": [
            "ByStartPointEndPoint"
        ],
        "inDepth": "Line By Start Point End Point will create a line between two input points. In this example, we use two code blocks to specify the x,y, and z coordinates of two points, and then create a line between the two points."
    },
    {
        "Name": "ByTangency",
        "categories": [
            "Geometry",
            "Line"
        ],
        "folderPath": "Geometry/Line/Create",
        "dynFile": [
            "ByTangency"
        ],
        "imageFile": [
            "ByTangency"
        ],
        "inDepth": "Line By Tangency creates a line tangent to an input curve, and with a length of 1 unit. The parameter input specifies the position along the curve to evaluate, with a parameter of zero being the beginning of the curve, and a value of 1 being the end of the curve. In the example, we use a Code Block to generate two lists corresponding to X and Y locations of a series of points. The points are used to draw a Nurbs Curve. We then use a number slider between 0 and 1 as an input parameter to create a line tangent to the curve."
    },
    {
        "Name": "Direction",
        "categories": [
            "Geometry",
            "Line"
        ],
        "folderPath": "Geometry/Line/Query",
        "dynFile": [
            "Direction"
        ],
        "imageFile": [
            "Direction"
        ],
        "inDepth": "Direction will return a vector that points in the same direction as a line. The magnitude of the vector is equal to the length of the original line. In the example below, we generate a set of random points, and then us ByBestFitThroughPoints to create a line. We use Direction to find the vector direction of the created line."
    },
    {
        "Name": "ControlPoints",
        "categories": [
            "Geometry",
            "NurbsCurve"
        ],
        "folderPath": "Geometry/NurbsCurve/Action",
        "dynFile": [
            "ControlPoints"
        ],
        "imageFile": [
            "ControlPoints"
        ],
        "inDepth": "Control Points will return a list of the control points of a NURBS curve. In the example, we first generate a number of random points, and then use NurbsCurve ByPoints to create a curve interpolated through the points. We can use Control Points to then get a list of the control points (instead of the original interpolated points) of the curve."
    },
    {
        "Name": "Knots",
        "categories": [
            "Geometry",
            "NurbsCurve"
        ],
        "folderPath": "Geometry/NurbsCurve/Action",
        "dynFile": [
            "Knots"
        ],
        "imageFile": [
            "Knots"
        ],
        "inDepth": "Knots will return the knots of a NURBS curve as a list of numbers. In the example, we first generate a number of random points, and then use NurbsCurve ByPoints to create a curve interpolated through the points. We can use Knots to then get a list of the knots for this curve."
    },
    {
        "Name": "Weights",
        "categories": [
            "Geometry",
            "NurbsCurve"
        ],
        "folderPath": "Geometry/NurbsCurve/Action",
        "dynFile": [
            "Weights"
        ],
        "imageFile": [
            "Weights"
        ],
        "inDepth": "Weights will return the weights of a NURBS curve as a list of numbers. Each weight corresponds to one control point of the curve. In the example, we first generate a number of random points, and then use NurbsCurve ByPoints to create a curve interpolated through the points. We can use Weights to then get a list of the weights for this curve."
    },
    {
        "Name": "Degree",
        "categories": [
            "Geometry",
            "NurbsCurve"
        ],
        "folderPath": "Geometry/NurbsCurve/Query",
        "dynFile": [
            "Degree"
        ],
        "imageFile": [
            "Degree"
        ],
        "inDepth": "Degree will return the degree of a NURBS curve. In the example, we first generate a number of random points, and then use NurbsCurve ByPoints to create a curve interpolated through the points. We can use Degree to then get the degree of the curve. Since we created the curve without specifying the degree, it used a default degree of three. (A polygonal curve of straight lines has a degree of one, while the most common degree for non-straight-segmented curves is 3)"
    },
    {
        "Name": "IsPeriodic",
        "categories": [
            "Geometry",
            "NurbsCurve"
        ],
        "folderPath": "Geometry/NurbsCurve/Query",
        "dynFile": [
            "IsPeriodic"
        ],
        "imageFile": [
            "IsPeriodic"
        ],
        "inDepth": "IsPeriodic returns a boolean value of true if the curve is periodic, and false if the curve is not periodic. In the example, we first generate a number of random points, and then use NurbsCurve ByPoints to create a curve interpolated through the points. We can use IsPeriodic to determine whether or not the curve is periodic."
    },
    {
        "Name": "IsRational",
        "categories": [
            "Geometry",
            "NurbsCurve"
        ],
        "folderPath": "Geometry/NurbsCurve/Query",
        "dynFile": [
            "IsRational"
        ],
        "imageFile": [
            "IsRational"
        ],
        "inDepth": "IsRational returns a boolean value of true if the curve is rational, and false if the curve is not rational. In the example, we first generate a number of random points, and then use NurbsCurve ByPoints to create a curve interpolated through the points. We can use IsRational to determine whether or not the curve is rational."
    },
    {
        "Name": "ByBestFitThroughPoints",
        "categories": [
            "Geometry",
            "Plane"
        ],
        "folderPath": "Geometry/Plane/Create",
        "dynFile": [
            "ByBestFitThroughPoints"
        ],
        "imageFile": [
            "ByBestFitThroughPoints"
        ],
        "inDepth": "Plane By Best Fit Through Points uses a set of points and finds the plane that best approximates the set. In the example, we use a series of RandomList components to generate random x,y and z coordinates. The points are created By Coordinates, and the list of points is then used as an input for ByBestFitThroughPoints."
    },
    {
        "Name": "ByLineAndPoint",
        "categories": [
            "Geometry",
            "Plane"
        ],
        "folderPath": "Geometry/Plane/Create",
        "dynFile": [
            "ByLineAndPoint"
        ],
        "imageFile": [
            "ByLineAndPoint"
        ],
        "inDepth": "Plane by Line and Point creates a plane using the input Point as the origin, and passing through the input line. The point must not lie on the axis of the line. In the example, we create a line by first using a set of random points and then creating a line with ByBestFitThroughPoints. An origin point is created with a code block providing the x,y, and z coordinates for a Point.ByCoordinates component. We then use the line and point as inputs to create a Plane by Line and Point."
    },
    {
        "Name": "ByOriginNormal",
        "categories": [
            "Geometry",
            "Plane"
        ],
        "folderPath": "Geometry/Plane/Create",
        "dynFile": [
            "ByOriginNormal"
        ],
        "imageFile": [
            "ByOriginNormal"
        ],
        "inDepth": "Plane by Origin Normal creates a plane using the input point as the origin, and perpendicular to the input Normal vector. In the example below, we use a code block to specify the x,y, and z coordinates of a Point By Coordinates. We then use that point as the Origin, and use a world Y-Axis as the normal vector for a Plane by Origin Normal."
    },
    {
        "Name": "ByOriginNormalXAxis",
        "categories": [
            "Geometry",
            "Plane"
        ],
        "folderPath": "Geometry/Plane/Create",
        "dynFile": [
            "ByOriginNormalXAxis"
        ],
        "imageFile": [
            "ByOriginNormalXAxis"
        ],
        "inDepth": "Plane by Origin Normal XAxis is similar to Plane By Origin Normal, but this allows us to also input a direction for the XAxis to control the orientation of the plane. If the input xAxis vector is not in the plane defined by the origin and normal inputs, it is first projected onto the plane to determine the Plane XAxis. In the example below, we use world YAxis as the normal vector, and use two code blocks to define the origin point and input xAxis."
    },
    {
        "Name": "ByOriginXAxisYAxis",
        "categories": [
            "Geometry",
            "Plane"
        ],
        "folderPath": "Geometry/Plane/Create",
        "dynFile": [
            "ByOriginXAxisYAxis"
        ],
        "imageFile": [
            "ByOriginXAxisYAxis"
        ],
        "inDepth": "Plane by Origin XAxis YAxis uses an origin point and two vectors to define a plane. The Normal vector of the plane is created by taking the cross product of the X and Y axis vectors. In the example below, we use world YAxis as the xAxis, and use two code blocks to define the origin point and input xAxis. "
    },
    {
        "Name": "ByThreePoints",
        "categories": [
            "Geometry",
            "Plane"
        ],
        "folderPath": "Geometry/Plane/Create",
        "dynFile": [
            "ByThreePoints"
        ],
        "imageFile": [
            "ByThreePoints"
        ],
        "inDepth": "Plane by Three Points will create a plane that passes through the three input points. The points must not be co-linear. In the example below, we use three code blocks to define the three initial points, then use ByThreePoints to create a plane."
    },
    {
        "Name": "XY",
        "categories": [
            "Geometry",
            "Plane"
        ],
        "folderPath": "Geometry/Plane/Create",
        "dynFile": [
            "XY"
        ],
        "imageFile": [
            "XY"
        ],
        "inDepth": "Plane XY creates a plane in the world XY directions. The normal of this plane is the world Z-Axis. In the example file, we show Plane XY, Plane YZ, and Plane XZ. In the image, the XY plane is highlighted."
    },
    {
        "Name": "XZ",
        "categories": [
            "Geometry",
            "Plane"
        ],
        "folderPath": "Geometry/Plane/Create",
        "dynFile": [
            "XZ"
        ],
        "imageFile": [
            "XZ"
        ],
        "inDepth": "Plane XZ creates a plane in the world XZ directions. The normal of this plane is the world Y-Axis. In the example file, we show Plane XY, Plane YZ, and Plane XZ. In the image, the XZ plane is highlighted."
    },
    {
        "Name": "YZ",
        "categories": [
            "Geometry",
            "Plane"
        ],
        "folderPath": "Geometry/Plane/Create",
        "dynFile": [
            "YZ"
        ],
        "imageFile": [
            "YZ"
        ],
        "inDepth": "Plane YZ creates a plane in the world YZ directions. The normal of this plane is the world X-Axis. In the example file, we show Plane XY, Plane YZ, and Plane XZ. In the image, the YZ plane is highlighted."
    },
    {
        "Name": "Offset",
        "categories": [
            "Geometry",
            "Plane"
        ],
        "folderPath": "Geometry/Plane/Action",
        "dynFile": [
            "Offset"
        ],
        "imageFile": [
            "Offset"
        ],
        "inDepth": "Plane Offset will create a new plane that is offset from the input plane. The amount of offset is controlled by the dist input (short for Distance). The offset is performed along the Normal direction of the plane. In the example below we first use a set of random points to create a Plane by Best Fit Through Points. We then use a Number Slider to control the offset distance."
    },
    {
        "Name": "ToCoordinateSystem",
        "categories": [
            "Geometry",
            "Plane"
        ],
        "folderPath": "Geometry/Plane/Action",
        "dynFile": [
            "ToCoordinateSystem"
        ],
        "imageFile": [
            "ToCoordinateSystem"
        ],
        "inDepth": "Plane To Coordinate System will return a Coordinate System based on the input plane, using the plane's origin, XAxis and YAxis. In the example below we first use a set of random points to create a Plane by Best Fit Through Points. We can then use ToCoordinateSystem to convert the Plane to a Coordinate System "
    },
    {
        "Name": "Normal",
        "categories": [
            "Geometry",
            "Plane"
        ],
        "folderPath": "Geometry/Plane/Query",
        "dynFile": [
            "Normal"
        ],
        "imageFile": [
            "Normal"
        ],
        "inDepth": "Plane Normal will find the normal vector of an input plane. This is also equal to taking the cross product of the plane XAxis and YAxis. In the example below we first use a set of random points to create a Plane by Best Fit Through Points. We can then find the normal vector of this plane."
    },
    {
        "Name": "Origin",
        "categories": [
            "Geometry",
            "Plane"
        ],
        "folderPath": "Geometry/Plane/Query",
        "dynFile": [
            "Origin"
        ],
        "imageFile": [
            "Origin"
        ],
        "inDepth": "Plane Origin will return the origin of an input plane as a point. This is specific to the plane, and is not necessarily the same as the world origin. In the example below, we first use a set of random points to create a Plane by Best Fit Through Points. We can then find the origin of this plane."
    },
    {
        "Name": "XAxis",
        "categories": [
            "Geometry",
            "Plane"
        ],
        "folderPath": "Geometry/Plane/Query",
        "dynFile": [
            "XAxis"
        ],
        "imageFile": [
            "XAxis"
        ],
        "inDepth": "Plane XAxis will return the y-axis of an input plane as a vector. This is specific to the plane, and is not necessarily the same as the world X-direction. In the example below, we first use a set of random points to create a Plane by Best Fit Through Points. We can then find the X-axis of this plane."
    },
    {
        "Name": "YAxis",
        "categories": [
            "Geometry",
            "Plane"
        ],
        "folderPath": "Geometry/Plane/Query",
        "dynFile": [
            "YAxis"
        ],
        "imageFile": [
            "YAxis"
        ],
        "inDepth": "Plane YAxis will return the y-axis of an input plane as a vector. This is specific to the plane, and is not necessarily the same as the world Y-direction. In the example below, we first use a set of random points to create a Plane by Best Fit Through Points. We can then find the Y-axis of this plane."
    },
    {
        "Name": "X",
        "categories": [
            "Geometry",
            "Point"
        ],
        "folderPath": "Geometry/Point/Query",
        "dynFile": [
            "X"
        ],
        "imageFile": [
            "X"
        ],
        "inDepth": "Point X returns the world space X value of an input point. In the example below, we use Point By Spherical Coordinates to create a point who's cartesian coordinate values are not necesarily known in advance, and then use Point X to get the x coordinate."
    },
    {
        "Name": "Y",
        "categories": [
            "Geometry",
            "Point"
        ],
        "folderPath": "Geometry/Point/Query",
        "dynFile": [
            "Y"
        ],
        "imageFile": [
            "Y"
        ],
        "inDepth": "Point Y returns the world space Y value of an input point. In the example below, we use Point By Spherical Coordinates to create a point who's cartesian coordinate values are not necesarily known in advance, and then use Point Y to get the y coordinate."
    },
    {
        "Name": "Z",
        "categories": [
            "Geometry",
            "Point"
        ],
        "folderPath": "Geometry/Point/Query",
        "dynFile": [
            "Z"
        ],
        "imageFile": [
            "Z"
        ],
        "inDepth": "Point Z returns the world space Z value of an input point. In the example below, we use Point By Spherical Coordinates to create a point who's cartesian coordinate values are not necesarily known in advance, and then use Point Z to get the z coordinate."
    },
    {
        "Name": "Add",
        "categories": [
            "Geometry",
            "Point"
        ],
        "folderPath": "Geometry/Point/Action",
        "dynFile": [
            "Add"
        ],
        "imageFile": [
            "Add"
        ],
        "inDepth": "Point Add will add the x,y, and z components of a input vector to the corresponding coordinates of the input point. This is the same as translating the point by the given vector, and is equivalent to using Geometry.Translate (Vector). In the example, we create a point using a code block to specify the x,y, and z coordinates, then add a world XAxis vector as the vectorToAdd. The result is the point translated by a distance of one in the positive x-direction."
    },
    {
        "Name": "AsVector",
        "categories": [
            "Geometry",
            "Point"
        ],
        "folderPath": "Geometry/Point/Action",
        "dynFile": [
            "AsVector"
        ],
        "imageFile": [
            "AsVector"
        ],
        "inDepth": "Point as Vector takes an input point and returns a vector with x,y, and z components equal to the cartesian coordinates of the point. This can also be thought of as creating a vector by two points, where the first point is the world origin and the second point is the input point. In the example below, we use PointBySphericalCoordinates to generate a point, then use AsVector to get a vector which we can control using spherical coordinates."
    },
    {
        "Name": "Project",
        "categories": [
            "Geometry",
            "Point"
        ],
        "folderPath": "Geometry/Point/Action",
        "dynFile": [
            "Project"
        ],
        "imageFile": [
            "Project"
        ],
        "inDepth": "Project will project a point along a given vector direction onto a specified geometry. The projection is only attempted in the positve direction of the vector. If the vector does not intersect the given geometry, it will return null. In the example below, we create a point using a code block to specify the x,y, and z coordinates. We use a sphere as the geometry to project onto, and the world XAxis as the projection Direction. The output is a point on the surface of the sphere that is projected from the original point."
    },
    {
        "Name": "PruneDuplicates",
        "categories": [
            "Geometry",
            "Point"
        ],
        "folderPath": "Geometry/Point/Action",
        "dynFile": [
            "PruneDuplicates"
        ],
        "imageFile": [
            "PruneDuplicates"
        ],
        "inDepth": "Prune Duplicates takes a list of points as an input, and will return a list with duplicate points removed. The tolerance input is used to determine how close two points need to be to be considered duplicates. If two points are closer than the tolerance, the first one in the list will be kept, and the other point removed. In the example, we generate a set of random points. We then use Prune Duplicates with a tolerance of one to remove any points that are closer than one unit to another point."
    },
    {
        "Name": "Subtract",
        "categories": [
            "Geometry",
            "Point"
        ],
        "folderPath": "Geometry/Point/Action",
        "dynFile": [
            "Subtract"
        ],
        "imageFile": [
            "Subtract"
        ],
        "inDepth": "Point Subtract will subtract the x,y, and z components of a input vector from the corresponding coordinates of the input point. This is the same as translating the point by the reverse of a given vector. In the example, we create a point using a code block to specify the x,y, and z coordinates, then add a world XAxis vector as the vectorToSubtract. The result is the point translated by a distance of one in the negative-x direction."
    },
    {
        "Name": "BasePlane",
        "categories": [
            "Geometry",
            "PolyCurve"
        ],
        "folderPath": "Geometry/PolyCurve/Action",
        "dynFile": [
            "BasePlane"
        ],
        "imageFile": [
            "BasePlane"
        ],
        "inDepth": "Base Plane will return the plane of a planar polycurve. If the curve is not planar, it will give an error. In the example below, we generate a set of random points and use PolyCurve By Points to create a PolyCurve. Because we only used x and y coordinates, the generated polycurve is planar in the world XY plane. "
    },
    {
        "Name": "CloseWithLine",
        "categories": [
            "Geometry",
            "PolyCurve"
        ],
        "folderPath": "Geometry/PolyCurve/Action",
        "dynFile": [
            "CloseWithLine"
        ],
        "imageFile": [
            "CloseWithLine"
        ],
        "inDepth": "Close With Line adds a straght line between the start and end point of an open PolyCurve. It returns a new polycurve that includes the added line. In the example below, we generate a set of random points and use PolyCuve By Points with the connectLastToFirst input set to false to create an open PolyCurve. Inputting this PolyCurve into Close With Line creates a new closed polycurve (and in this case would be equivalent to using a 'true' input for the connectLastToFirst option in PolyCurve By Points)"
    },
    {
        "Name": "CurveAtIndex",
        "categories": [
            "Geometry",
            "PolyCurve"
        ],
        "folderPath": "Geometry/PolyCurve/Action",
        "dynFile": [
            "CurveAtIndex"
        ],
        "imageFile": [
            "CurveAtIndex"
        ],
        "inDepth": "Curve At Index will return the curve segment at the input index of a given polycurve. If the number of curves in the polycurve is less than the give index, CurveAtIndex will return null. The endOrStart input accepts a boolean value of true or false. If true, CurveAtIndex will begin counting at the first segment of the PolyCurve. If false, it will count backwards from the last segment. In the example below, we generate a set of random points, and then use PolyCurve By Points to create an open PolyCurve. We can then use CurveAtIndex to extract specfic segments from the PolyCurve."
    },
    {
        "Name": "Curves",
        "categories": [
            "Geometry",
            "PolyCurve"
        ],
        "folderPath": "Geometry/PolyCurve/Action",
        "dynFile": [
            "Curves"
        ],
        "imageFile": [
            "Curves"
        ],
        "inDepth": "Curves will return the indvidual curves that make up a PolyCurve as a list of curves. In the example below, we generate a set of random points, and then use PolyCurve By Points to create an open PolyCurve. We can then use Curves to generate a list of the individual curves."
    },
    {
        "Name": "ExtendWithArc",
        "categories": [
            "Geometry",
            "PolyCurve"
        ],
        "folderPath": "Geometry/PolyCurve/Action",
        "dynFile": [
            "ExtendWithArc"
        ],
        "imageFile": [
            "ExtendWithArc"
        ],
        "inDepth": "Extend With Arc will add a circular arc to the beginning or end of an input PolyCurve, and returns a single combined PolyCurve. The radius input will determin the radius of the circle, while the length input determines the distance along the circle for the arc. The total length must be less than or equal to length of a complete circle with the given radius. The generated arc will be tangent to the end of the input PolyCurve. A boolean input for endOrStart controls which end of the PolyCurve the arc will be created. A value of 'true' will result in the arc created at the end of the PolyCurve, while 'false' will create the arc at the beginning of the PolyCurve. In the example below, we first use a set of random points and PolyCurve By Points to generate a PolyCurve. We then use two number sliders and a boolean toggle to set the parametrs for ExtendWithArc."
    },
    {
        "Name": "Offset",
        "categories": [
            "Geometry",
            "PolyCurve"
        ],
        "folderPath": "Geometry/PolyCurve/Action",
        "dynFile": [
            "Offset"
        ],
        "imageFile": [
            "Offset"
        ],
        "inDepth": "Offset will output a Curve that is offset from a given PolyCurve by the given distance. The input PolyCurve must be planar and not self-intersecting in order to be offset. The extendCircular input determines whether cornes in the resulting curve should be sharp or circular. Note that this component returns an output of type Curve, not a PolyCurve. In the example below, we generate a set of random points and use PolyCurve By Points to create a PolyCurve. We then use a Number Slider and a Boolean toggle to control the inputs of Offset. Note that increasing the number of initial points greater than 3 or 4 will often result in a self-intersecting curve, which cannot be offset."
    },
    {
        "Name": "NumberOfCurves",
        "categories": [
            "Geometry",
            "PolyCurve"
        ],
        "folderPath": "Geometry/PolyCurve/Query",
        "dynFile": [
            "NumberOfCurves"
        ],
        "imageFile": [
            "NumberOfCurves"
        ],
        "inDepth": "Number Of Curves returns the number of curve segments that make up a given PolyCurve. In the example below, we generate a set of random points and use PolyCurve By Points to create a PolyCurve. If connectLastToFirst is left as 'false', then the number of curves will be one less than the number of points. Otherwise, if we create a closed PolyCurve, the number of curves will be equal to the number of initial points."
    },
    {
        "Name": "Center",
        "categories": [
            "Geometry",
            "Polygon"
        ],
        "folderPath": "Geometry/Polygon/Action",
        "dynFile": [
            "Center"
        ],
        "imageFile": [
            "Center"
        ],
        "inDepth": "Polygon Center finds the center of a given polygon by taking the average value of the corners. For concave polygons, it's possible that the center may actually lie outside the polygon. In the example below, we first generate a list of random angles and radii to use as inputs to Point By Cylindrical Coordinates. By sorting the angles first, we ensure that the resulting polygon will be connected in order of increasing angle, and therefore will not be self-intersecting. We can then use Center to take the average of the points and find the polygon center."
    },
    {
        "Name": "ContainmentTest",
        "categories": [
            "Geometry",
            "Polygon"
        ],
        "folderPath": "Geometry/Polygon/Action",
        "dynFile": [
            "ContainmentTest"
        ],
        "imageFile": [
            "ContainmentTest"
        ],
        "inDepth": "Containment Test returns a boolean value depending on whether a given point is contained inside a given polygon. The polygon must be planar and non-self-intersecting in order for this to work. In the example below, we create a polygon using a series of points created By Cylindrical Coordinates. Leaving the elevation constant, and sorting the angles ensures a planar and non-self-intersecting polygon. We then create a point to test, and use ContainmentTest to see if the point is inside or outside the polygon."
    },
    {
        "Name": "Corners",
        "categories": [
            "Geometry",
            "Polygon"
        ],
        "folderPath": "Geometry/Polygon/Action",
        "dynFile": [
            "Corners"
        ],
        "imageFile": [
            "Corners"
        ],
        "inDepth": "Corners will return a list of points that are the corners of the given polygon. In the example below, we first generate a set of random points sorted by angle to use with Polygon By Points. We can get the points back out as a list by using Corners."
    },
    {
        "Name": "SelfIntersections",
        "categories": [
            "Geometry",
            "Polygon"
        ],
        "folderPath": "Geometry/Polygon/Action",
        "dynFile": [
            "SelfIntersections"
        ],
        "imageFile": [
            "SelfIntersections"
        ],
        "inDepth": "Self Intersections will return a list of all points where a polygon intersects itself. In the example below, we first generate a list of random unsorted angles and radii to use with Points By Cylindrical Coordinates. Because we kept the elevation constant, and did not sort the angles of these points, a polygon created with Polygon By Points will be planar and is likely to be self-intersecting. We can then find the intersection points using Self Intersections"
    },
    {
        "Name": "PlaneDeviation",
        "categories": [
            "Geometry",
            "Polygon"
        ],
        "folderPath": "Geometry/Polygon/Query",
        "dynFile": [
            "PlaneDeviation"
        ],
        "imageFile": [
            "PlaneDeviation"
        ],
        "inDepth": "Plane Deviation will first calculate the best fit plane through the points of a given polygon. It then averages the distance of each point to that plane to find the average deviation of the points of a polygon from the best fit plane. In the example below, we generate a list of random angles, elevations, and radii, and then use Points By Cylindrical Coordinates to create a set of non-planar points to use for Polygon By Points. Inputting this polygon into PlaneDeviation, we can find the average deviation of the points from a best-fit-plane."
    },
    {
        "Name": "Points",
        "categories": [
            "Geometry",
            "Polygon"
        ],
        "folderPath": "Geometry/Polygon/Query",
        "dynFile": [
            "Points"
        ],
        "imageFile": [
            "Points"
        ],
        "inDepth": "Points will return a list of points that are the end points of the segments of the given polygon. In the example below, we first generate a set of random points sorted by angle to use with Polygon By Points. We can get the points back out as a list by using Points."
    },
    {
        "Name": "ByJoinedSurfaces",
        "categories": [
            "Geometry",
            "Solid"
        ],
        "folderPath": "Geometry/Solid/Create",
        "dynFile": [
            "ByJoinedSurfaces"
        ],
        "imageFile": [
            "ByJoinedSurfaces"
        ],
        "inDepth": "Solid by Joined Surfaces takes a list of surfaces as an input and will return a single solid defined by the surfaces. The surfaces must define a closed surface. In the example below, we start with a circle as a base geometry. The circle is patched to create a surface, and that surface is translated in the z-direction. We then extrude the circle to produce the sides. List.Create is used to make a list consisting of the base, side, and top surfaces, and then we use ByJoinedSurfaces to turn the list into a single closed solid."
    },
    {
        "Name": "ByLoft (crossSections, guideCurve)",
        "categories": [
            "Geometry",
            "Solid"
        ],
        "folderPath": "Geometry/Solid/Create",
        "dynFile": [
            "ByLoft_guideCurve"
        ],
        "imageFile": [
            "ByLoft_guideCurve"
        ],
        "inDepth": "ByLoft with crossSections and guideCurve will create a solid by lofting between the input list of closed Cross Section curves. A guide Curve is provided to control the profile of the loft, rather than just lofting as a straight line. In the example below, we start with a rectangle as the base. The rectangle is translated, and then combined with the original into a list to provide the list of cross sections for ByLoft. A set of points is created using a cosine function to control the coordinates, and used to create a NurbsCurve ByPoints. ByLoft is used with the list of rectangles as the crossSections, and the NurbsCurve as the guide, producing a solid with rectangular cross sections, and a wave profile."
    },
    {
        "Name": "ByLoft (crossSections, guideCurves)",
        "categories": [
            "Geometry",
            "Solid"
        ],
        "folderPath": "Geometry/Solid/Create",
        "dynFile": [
            "ByLoft_guideCurves"
        ],
        "imageFile": [
            "ByLoft_guideCurves"
        ],
        "inDepth": "ByLoft with crossSections and guideCurves allows us to input a list of guide curves to produce different profiles along the perimeter of a lofted solid. In the example below, we use two offset rectangles as the crossSections. Two different guide curves are generate around the perimeter, one based on a Cosine function, and the other a simple line."
    },
    {
        "Name": "ByLoft (crossSections)",
        "categories": [
            "Geometry",
            "Solid"
        ],
        "folderPath": "Geometry/Solid/Create",
        "dynFile": [
            "ByLoft"
        ],
        "imageFile": [
            "ByLoft"
        ],
        "inDepth": "ByLoft with crossSections takes a list of closed curves as an input. It will produce a solid by lofting between the list of curves in order. In the example below, we start with a circle. We then produce a series of translated circles based on a sine curve. This list of curves is used as the input for ByLoft."
    },
    {
        "Name": "ByRevolve",
        "categories": [
            "Geometry",
            "Solid"
        ],
        "folderPath": "Geometry/Solid/Create",
        "dynFile": [
            "ByRevolve"
        ],
        "imageFile": [
            "ByRevolve"
        ],
        "inDepth": "Solid by Revolve creates a surface by rotating a given profile curve around an axis. The axis is defined by an axisOrigin point, and an axisDirection vector. The start angle determines where to begin the surface, measured in degrees, and the sweepAngle determines how far around the axis to continue the surface. In the example below, we use a curve generated with a cosine function as the profile curve, and two number sliders to control the startAngle and sweepAngle. The axisOrigin and axisDirection are left at the default values of the world origin and world z-axis for this example."
    },
    {
        "Name": "BySweep",
        "categories": [
            "Geometry",
            "Solid"
        ],
        "folderPath": "Geometry/Solid/Create",
        "dynFile": [
            "BySweep"
        ],
        "imageFile": [
            "BySweep"
        ],
        "inDepth": "Solid By Sweep will create a solid by sweeping an input closed profile curve along a specified path. In the example below, we use a rectangle as the base profile curve. The path is created by using a cosine function with a sequence of angles to vary the x-coordinates of a set of points. The points are used as the input to a NurbsCurve by Points node. We then create a solid by sweeping the rectangle along the created cosine curve."
    },
    {
        "Name": "ByUnion",
        "categories": [
            "Geometry",
            "Solid"
        ],
        "folderPath": "Geometry/Solid/Create",
        "dynFile": [
            "ByUnion"
        ],
        "imageFile": [
            "ByUnion"
        ],
        "inDepth": "Solid by Union will create a single new solid out of the union of a list of closed solids. The union is the combination of both solids, and the new solid will include all of the volume of the original solids. In the example below, we use a set of number sliders to control the position and radius of a sphere. We also use a default cuboid. We use a List.Create node to put both the cube and the sphere into a single list, which we use as the input for Solid ByUnion node."
    },
    {
        "Name": "Centroid",
        "categories": [
            "Geometry",
            "Solid"
        ],
        "folderPath": "Geometry/Solid/Action",
        "dynFile": [
            "Centroid"
        ],
        "imageFile": [
            "Centroid"
        ],
        "inDepth": "Centroid will return a point that is at the centroid of a solid. The centroid can be thought of as the center of mass of an solid object. Note that it is possible for the center of mass to exist outside the actual solid. In the example below, we use a set of circles to create a Solid ByLoft, and input the resulting solid into a Centroid node."
    },
    {
        "Name": "Chamfer",
        "categories": [
            "Geometry",
            "Solid"
        ],
        "folderPath": "Geometry/Solid/Action",
        "dynFile": [
            "Chamfer"
        ],
        "imageFile": [
            "Chamfer"
        ],
        "inDepth": "Chamfer will return a new solid with chamfered edges. The edges input specifies which edges to chamfer, while the offset input determines the extent of the chamfer. In the example below, we start with a cube using the default inputs. To get the appropriate edges of the cube, we first explode the cube to get the faces as a list of surfaces. We then use a Face.Edges node to extract the edges of the cube. We extract the first edge of each face with GetItemAtIndex. A number slider controls the offset distance for the chamfer."
    },
    {
        "Name": "Difference",
        "categories": [
            "Geometry",
            "Solid"
        ],
        "folderPath": "Geometry/Solid/Action",
        "dynFile": [
            "Difference"
        ],
        "imageFile": [
            "Difference"
        ],
        "inDepth": "Difference will create a new solid by subtracting one solid from another. The 'solid' input indicates the solid to subtract from, while the 'tool' input is the solid that will be subtracted. In the example below, we start with a default cube as the solid we are going to subtract from. We use a series of number sliders to control the position and radius of a sphere, which we use as the tool. If the sphere is intersecting the cube, then the result is a cube with the intersecting part of the sphere subtracted from it."
    },
    {
        "Name": "DifferenceAll",
        "categories": [
            "Geometry",
            "Solid"
        ],
        "folderPath": "Geometry/Solid/Action",
        "dynFile": [
            "DifferenceAll"
        ],
        "imageFile": [
            "DifferenceAll"
        ],
        "inDepth": "Difference All will create a new solid by subtracting a list of solids from one single solid. The 'solid' input indicates the solid to subtract from, while the 'tools' input is the list of solids that will be subtracted. The solids in this list will be unioned together to create a single solid, which is then subtracted from the 'solid' input. In the example below, we start with a default cube as the solid we are going to subtract from. We use a series of number sliders to control the position and radius of a sphere. By using a sequence of numbers as the z-coordinate, we create a list of several spheres. If the spheres are intersecting the cube, then the result is a cube with the intersecting parts of the spheres subtracted from it."
    },
    {
        "Name": "Fillet",
        "categories": [
            "Geometry",
            "Solid"
        ],
        "folderPath": "Geometry/Solid/Action",
        "dynFile": [
            "Fillet"
        ],
        "imageFile": [
            "Fillet"
        ],
        "inDepth": "Fillet will return a new solid with rounded edges. The edges input specifies which edges to fillet, while the offset input determines the radius of the fillet. In the example below, we start with a cube using the default inputs. To get the appropriate edges of the cube, we first explode the cube to get the faces as a list of surfaces. We then use a Face.Edges node to extract the edges of the cube. We extract the first edge of each face with GetItemAtIndex. A number slider controls the radius for each fillet."
    },
    {
        "Name": "ProjectInputOnto",
        "categories": [
            "Geometry",
            "Solid"
        ],
        "folderPath": "Geometry/Solid/Action",
        "dynFile": [
            "ProjectInputOnto"
        ],
        "imageFile": [
            "ProjectInputOnto"
        ],
        "inDepth": "Project Input Onto will proect an input geometry onto a given solid, using the projectDirection vector as the axis for projection. In the example below, we first create a solid to project onto by lofting a sequence of circles together with ByLoft. The geometry we are projecting is a vertical circle created next to the solid. We use the world YAxis as the projectDirection. The result is a curve that has been projected onto the irregular solid."
    },
    {
        "Name": "ThinShell",
        "categories": [
            "Geometry",
            "Solid"
        ],
        "folderPath": "Geometry/Solid/Action",
        "dynFile": [
            "ThinShell"
        ],
        "imageFile": [
            "ThinShell"
        ],
        "inDepth": "Thin Shell will create a new solid by offsetting the surfaces that make up the input solid. This can also be thought of as thickening the surfaces of the input solid. In the example below, we use a chamfered cube as our input solid. We have two number sliders to control the inner and outer thicknesses of the shell faces."
    },
    {
        "Name": "Union",
        "categories": [
            "Geometry",
            "Solid"
        ],
        "folderPath": "Geometry/Solid/Action",
        "dynFile": [
            "Union"
        ],
        "imageFile": [
            "Union"
        ],
        "inDepth": "Union will create a new solid by adding one solid to another. The 'solid' input indicates the solid to add to, while the 'tool' input is the solid that will be added. In the example below, we start with a default cube as the solid we are going to add to. We use a series of number sliders to control the position and radius of a sphere, which we use as the tool. If the sphere is intersecting the cube, then the result is a cube with the intersecting part of the sphere added to it."
    },
    {
        "Name": "UnionAll",
        "categories": [
            "Geometry",
            "Solid"
        ],
        "folderPath": "Geometry/Solid/Action",
        "dynFile": [
            "UnionAll"
        ],
        "imageFile": [
            "UnionAll"
        ],
        "inDepth": "Union All will create a new solid by adding a list of solids to one single solid. The 'solid' input indicates the solid to add to, while the 'tools' input is the list of solids that will be added. The solids in this list will be unioned together to create a single solid, which is then added to the 'solid' input. In the example below, we start with a default cube as the solid we are going to add to. We use a series of number sliders to control the position and radius of a sphere. By using a sequence of numbers as the z-coordinate, we create a list of several spheres. If the spheres are intersecting the cube, then the result is a cube with the intersecting parts of the spheres added to it."
    },
    {
        "Name": "Area",
        "categories": [
            "Geometry",
            "Solid"
        ],
        "folderPath": "Geometry/Solid/Query",
        "dynFile": [
            "Area"
        ],
        "imageFile": [
            "Area"
        ],
        "inDepth": "Volume will return the surface area of a given solid. In the example below, we start with a cube, and then chamfer the edges to produce a new solid. We can use Area to find the total area of all the surfaces of this solid."
    },
    {
        "Name": "Volume",
        "categories": [
            "Geometry",
            "Solid"
        ],
        "folderPath": "Geometry/Solid/Query",
        "dynFile": [
            "Volume"
        ],
        "imageFile": [
            "Volume"
        ],
        "inDepth": "Volume will return the volume of a given solid. In the example below, we start with a cube, and then chamfer the edges to produce a new solid. We can use Volume to find the new volume of this solid."
    },
    {
        "Name": "ByBestFit",
        "categories": [
            "Geometry",
            "Sphere"
        ],
        "folderPath": "Geometry/Sphere/Create",
        "dynFile": [
            "ByBestFit"
        ],
        "imageFile": [
            "ByBestFit"
        ],
        "inDepth": "Sphere by Best Fit will create a sphere based on a list of points as input. The sphere will be created to minimize the average distance from the list of points to the surface of the sphere. In the example below, we generate a set of random numbers to use as x,y, and z coordinates for a list of points. The number of points is controlled by an integer slider. The list of points is used as the input for a Sphere ByBestFit node."
    },
    {
        "Name": "ByCenterPointRadius",
        "categories": [
            "Geometry",
            "Sphere"
        ],
        "folderPath": "Geometry/Sphere/Create",
        "dynFile": [
            "ByCenterPointRadius"
        ],
        "imageFile": [
            "ByCenterPointRadius"
        ],
        "inDepth": "Sphere by Center Point Radius will create a sphere centered at the input point, and with an input radius. In the example below, we use a code block to specify the coordinates of a Point created by coordinates, and we use a number slider to determine the radius of the sphere."
    },
    {
        "Name": "CenterPoint",
        "categories": [
            "Geometry",
            "Sphere"
        ],
        "folderPath": "Geometry/Sphere/Query",
        "dynFile": [
            "CenterPoint"
        ],
        "imageFile": [
            "CenterPoint"
        ],
        "inDepth": "Center Point will return the center of an input sphere. In the example below, we use a ByBestFit node to create a sphere based on a set of random points. We then use a CenterPoint node to determine the center of the best fit sphere."
    },
    {
        "Name": "Radius",
        "categories": [
            "Geometry",
            "Sphere"
        ],
        "folderPath": "Geometry/Sphere/Query",
        "dynFile": [
            "Radius"
        ],
        "imageFile": [
            "Radius"
        ],
        "inDepth": "Radius will return the center of an input sphere. In the example below, we use a ByBestFit node to create a sphere based on a set of random points. We then use a Radius node to determine the size of the best fit sphere."
    },
    {
        "Name": "ByLoft (crossSections)",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Create",
        "dynFile": [
            "ByLoft"
        ],
        "imageFile": [
            "ByLoft"
        ],
        "inDepth": "Surface ByLoft with cross sections takes a list of curves as an input. It will produce a surface by lofting between the list of curves in order. In the example below we create two curves, a line and a sine curve. We use List.Create to combine these two curves into a list, which we use as an input for Surface ByLoft. The result is a surface that is lofted between a sine curve on one side, and a line on the other."
    },
    {
        "Name": "ByLoft (crossSections, guideCurve)",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Create",
        "dynFile": [
            "ByLoft_gc"
        ],
        "imageFile": [
            "ByLoft_gc"
        ],
        "inDepth": "Surface by Loft with cross sections and guide curves uses an extra input in addition to a list of cross sections to loft. This extra curve is a guide curve that directs the lofted surface. In the example below, we use two straight lines as the input cross sections. We create a sine curve to use as a guide curve. By using the guide curve, we create a surface with a sine curve profile, instead of just a flat surface lofted directly between the two cross section lines. "
    },
    {
        "Name": "ByLoft (crossSections, guideCurves)",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Create",
        "dynFile": [
            "ByLoft_gcs"
        ],
        "imageFile": [
            "ByLoft_gcs"
        ],
        "inDepth": "Surface by Loft with cross sections and guide curves takes a list of cross sections to loft between, and a separate list of guide curves to determine the profile of the loft. In the example below, we use two straight lines as the input cross sections. For the guide curves, we create one sine curve and one straight line. A number slider controls the distance between the sine curve and the straight line. The resulting loft interpolates between the sine curve and the straight line."
    },
    {
        "Name": "ByPatch",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Create",
        "dynFile": [
            "ByPatch"
        ],
        "imageFile": [
            "ByPatch"
        ],
        "inDepth": "Surface by Patch will create a surface by filling in the interior of a closed curve. In the example below, we first create a closed Nurbs Curve by using a series of points created with cylindrical coordines. A number slider controls the number of points to create, while a boolean toggle node controls whether the Nurbs Curve is closed on not. We use the Nurbs Curve as the input to a Surface ByPatch node, creating a surface on the inside of the closed curve."
    },
    {
        "Name": "ByPerimeterPoints",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Create",
        "dynFile": [
            "ByPerimeterPoints"
        ],
        "imageFile": [
            "ByPerimeterPoints"
        ],
        "inDepth": "Surface by Perimeter Points takes a list of points that defines the perimeter of a closed polygon, and creates a surface inside the resulting polygon. In the example below we create a series of points using cylindrical coordinates. The points are created at regular intervals around a cylinder with randomized inputs for the radius and elevation. The resulting list of points is used as the input for a Surface ByPerimeterPoints node."
    },
    {
        "Name": "ByRevolve",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Create",
        "dynFile": [
            "ByRevolve"
        ],
        "imageFile": [
            "ByRevolve"
        ],
        "inDepth": "Surface by Revolve creates a surface by rotating a given profile curve around an axis. The axis is defined by an axisOrigin point, and an axisDirection vector. The start angle determines where to begin the surface, measured in degrees, and the sweepAngle determines how far around the axis to continue the surface. In the example below, we use a curve generated with a cosine function as the profile curve, and two number sliders to control the startAngle and sweepAngle. The axisOrigin and axisDirection are left at the default values of the world origin and world z-axis for this example"
    },
    {
        "Name": "ByRuledLoft",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Create",
        "dynFile": [
            "ByRuledLoft"
        ],
        "imageFile": [
            "ByRuledLoft"
        ],
        "inDepth": "Surface by Ruled Loft takes an ordered list of curves as an input and lofts a straigth-line ruled surface between the curves. Compared to ByLoft, ByRuledLoft can be slightly faster, but the resulting surface is less smooth. In the example below, we start with a line along the X-axis. We translate this line into a series of lines that follow a sine curve in the y-direction. Using this resulting list of lines as the input for a Surface ByRuledLoft results in a surface with straight-line segments between the input curves."
    },
    {
        "Name": "BySweep",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Create",
        "dynFile": [
            "BySweep"
        ],
        "imageFile": [
            "BySweep"
        ],
        "inDepth": "Surface by Sweep will create a surface by sweeping an input curve along a specfied path. In the example below, we use a sine curve in the y-direction as the profile curve. We rotate this curve by -90 degrees around the world z-axis to use as a path curve. Surface BySweep moves the profile curve along the path curve creating a surface."
    },
    {
        "Name": "BySweep2Rails",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Create",
        "dynFile": [
            "BySweep2Rails"
        ],
        "imageFile": [
            "BySweep2Rails"
        ],
        "inDepth": "Surface by Sweep 2 Rails takes an input curve and uses two guide curves to sweep the profile curve along. In the example below, we use a half-circle as the input profile. We create two diverging lines to use as the rail curves for a BySweep2Rails node. The result is a surface with a half-circle profile that grows as the arc moves along the diverging lines."
    },
    {
        "Name": "ApproximateWithTolerance",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Action",
        "dynFile": [
            "ApproximateWithTolerance"
        ],
        "imageFile": [
            "ApproximateWithTolerance"
        ],
        "inDepth": "Approximate with Tolerance will create a Nurbs Surface that approximates an input surface. The tolerance input determines how accurately the result will match the original surface. In the example below, we create a surface using a ByPatch node with a close Nurbs Curve as an input. Note that when we use this surface as the input for a ApproximateWithTolerance node, the result is an untrimmed Nurbs Surface with four sides."
    },
    {
        "Name": "CoordinateSystemAtParameter",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Action",
        "dynFile": [
            "CoordinateSystemAtParameter"
        ],
        "imageFile": [
            "CoordinateSystemAtParameter"
        ],
        "inDepth": "Coordinate System at Parameter uses U and V input parameters and returns a coordinate system. The x-axis, y-axis, and z-axis of the Coordinate System are determined by the Normal direction, U direction, and V direction, respectively. In the example below, we first create a surface by using a BySweep2Rails. We then use two number sliders to determine the U and V parameters to create a Coordinate System with a CoordnateSystemAtParameter node."
    },
    {
        "Name": "CurvatureAtParameter",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Action",
        "dynFile": [
            "CurvatureAtParameter"
        ],
        "imageFile": [
            "CurvatureAtParameter"
        ],
        "inDepth": "Curvature At Parameter uses U and V input parameters and returns a coordinate system based on the normal, U direction, and V direction at the UV position on the surface. The Normal vector determines the z-axis, while the U and V directions determine the direction of the X and Y axes. The length of the axes are determined by the U and V curvature. In the example below, we first create a surface by using a BySweep2Rails. We then use two number sliders to determine the U and V parameters to create a Coordinate System with a CurvatureAtParameter node."
    },
    {
        "Name": "DerivativesAtParameter",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Action",
        "dynFile": [
            "DerivativesAtParameter"
        ],
        "imageFile": [
            "DerivativesAtParameter"
        ],
        "inDepth": "Derivatives At Parameter uses U and V input parameters and returns the U and V derivaties of the surface at the input UV position on the surface. The derivatives are returned as a list of two vectors, with the first vector being the U derivative and the second vector being the V derivative. In the example below, we first create a surface by using a BySweep2Rails. We then use two number sliders to determine the U and V parameters to determine the derivatives with a DerivativesAtParameter node. "
    },
    {
        "Name": "FlipNormalDirection",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Action",
        "dynFile": [
            "FlipNormalDirection"
        ],
        "imageFile": [
            "FlipNormalDirection"
        ],
        "inDepth": "Flip Normal Direction will flip the direction of the normal vectors of a surface. In the example below, we first create a surface by using a BySweep2Rails. The Normal direction of this surface points up in the positive z-direction. By usinging a FlipNormalDirection node, we create a new surface with the same geometry, but with the normals pointing down in the negative z-direction."
    },
    {
        "Name": "GaussianCurvatureAtParameter",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Action",
        "dynFile": [
            "GaussianCurvatureAtParameter"
        ],
        "imageFile": [
            "GaussianCurvatureAtParameter"
        ],
        "inDepth": "Gaussian Curvature At Parameter uses U and V input parameters and returns the curvature of the surface at the input UV position of the surface. The Gaussian Curvature is calculated as the product of the two principal curvatures (in the U and V directions). In the example below, we first create a surface by using a BySweep2Rails. We then use two number sliders to determine the U and V parameters to find the gaussian curvature with a GaussianCurvatureAtParameter node."
    },
    {
        "Name": "GetIsoline",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Action",
        "dynFile": [
            "GetIsoline"
        ],
        "imageFile": [
            "GetIsoline"
        ],
        "inDepth": "Get Isoline will return the isoline of a surface at an input U or V parameter. The input isoDirection is used to determine whether the U direction or V direction is used. An isoDirection of 0 corresponds to the U direction, while an isoDirection of 1 corresponds to the V direction. In the example below, we first create a surface by using a BySweep2Rails. We then use two number sliders. The first slider controls the U or V direction of the isolines, while the second determines the parameter to find the isoline of."
    },
    {
        "Name": "NormalAtParameter",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Action",
        "dynFile": [
            "NormalAtParameter"
        ],
        "imageFile": [
            "NormalAtParameter"
        ],
        "inDepth": "Normal At Parameter uses U and V input parameters and returns the Normal vector of the surface at the input UV position on the surface. In the example below, we first create a surface by using a Sweep2Rails. We then use two number sliders to determine the U and V parameters to determine the Normal with a NormalAtParameter node."
    },
    {
        "Name": "NormalAtPoint",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Action",
        "dynFile": [
            "NormalAtPoint"
        ],
        "imageFile": [
            "NormalAtPoint"
        ],
        "inDepth": "Normal At Point finds the Normal vector of the surface at the input point on a surface. If the input point is not on the surface, this node will find the point on the surface that is nearest to the input point. In the example below, we first create a surface by using a BySweep2Rails. We then use a Code Block to specify a point to find the normal at. The point is not on the surface, so the node uses the closest point on the surface as the position to find the normal at."
    },
    {
        "Name": "Offset",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Action",
        "dynFile": [
            "Offset"
        ],
        "imageFile": [
            "Offset"
        ],
        "inDepth": "Offset will create a new surface that is offset from the input surface at distance specified by the distance input. A positive distance will create the offset surface according to the Normal direction of the surface, while a negative distance will result in the offset on the opposite side of the surface. In the example below, we first create a surface by using a BySweep2Rails node. We then use a number slider to control the distance of the offset in an Offset node."
    },
    {
        "Name": "PerimeterCurves",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Action",
        "dynFile": [
            "PerimeterCurves"
        ],
        "imageFile": [
            "PerimeterCurves"
        ],
        "inDepth": "Perimeter Curves will return the edge curves of an open surface as a list of curves. In the example below, we first create a surface by using a BySweep2Rails node. We then extract the perimeter edges by using a PerimeterCurves node. "
    },
    {
        "Name": "PointAtParameter",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Action",
        "dynFile": [
            "PointAtParameter"
        ],
        "imageFile": [
            "PointAtParameter"
        ],
        "inDepth": "Point At Parameter will return the point on a surface specified by U and V parameters. In the example below, we first create a surface by using a BySweep2Rails node. We then use two number sliders to control the U and V values of the parameter for a PointAtParameter node."
    },
    {
        "Name": "PrincipalCurvaturesAtParameter",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Action",
        "dynFile": [
            "PrincipalCurvaturesAtParameter"
        ],
        "imageFile": [
            "PrincipalCurvaturesAtParameter"
        ],
        "inDepth": "Principal Curvatures at Parameter uses U and V input parameters and returns the curvatures in the U and V directions. This node returns a list of two numbers, with the first being the curvature in the U direction and the second being the curvature in the V direction. In the example below, we first create a surface by using a BySweep2Rails. We then use two number sliders to determine the U and V parameters to find the curvatures using a PrincipalCurvaturesAtParameter node."
    },
    {
        "Name": "PrincipalDirectionsAtParameter",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Action",
        "dynFile": [
            "PrincipalDirectionsAtParameter"
        ],
        "imageFile": [
            "PrincipalDirectionsAtParameter"
        ],
        "inDepth": "Principal Directions at Parameter uses U and V input parameters and returns the curvatures in the U and V directions. This node returns a list of two vectors, with the first being the direction vector in the U direction and the second being the direction vector in the V direction. In the example below, we first create a surface by using a BySweep2Rails. We then use two number sliders to determine the U and V parameters to find the directions using a PrincipalDirectionsAtParameter node."
    },
    {
        "Name": "ProjectInputOnto",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Action",
        "dynFile": [
            "ProjectInputOnto"
        ],
        "imageFile": [
            "ProjectInputOnto"
        ],
        "inDepth": "Project Input Onto will project an input geometry onto a given surface along a given direction. In the example below, we first create a surface by using a BySweep2Rails. This is the surface we will project onto. We make a circle at the origin to use as the geometry to project, and simply use the world Z-direction as the direction vector for projection. The result is a circle projected onto the surface."
    },
    {
        "Name": "SubtractFrom",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Action",
        "dynFile": [
            "SubtractFrom"
        ],
        "imageFile": [
            "SubtractFrom"
        ],
        "inDepth": "Subtract From will create a new surface by subtracting the input trimming geometry from they input surface. In the example below, we first create a surface by using a BySweep2Rails. We then use a series of number slider to contrel the length, width, and height of a cuboid. By using a SubtractFrom node, we can trim the surface by subracting out the area that intersects with the cuboid."
    },
    {
        "Name": "TangentAtUParameter",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Action",
        "dynFile": [
            "TangentAtUParameter"
        ],
        "imageFile": [
            "TangentAtUParameter"
        ],
        "inDepth": "Tangent at U Parameter will return the tangent vector in the U direction at a specified UV position on a surface.  In the example below, we first create a surface by using a BySweep2Rails. We then use two number sliders to determine the U and V parameters to find the U tangent vector."
    },
    {
        "Name": "TangentAtVParameter",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Action",
        "dynFile": [
            "TangentAtVParameter"
        ],
        "imageFile": [
            "TangentAtVParameter"
        ],
        "inDepth": "Tangent at U Parameter will return the tangent vector in the V direction at a specified UV position on a surface.  In the example below, we first create a surface by using a BySweep2Rails. We then use two number sliders to determine the U and V parameters to find the V tangent vector."
    },
    {
        "Name": "Thicken (surface, thickness)",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Action",
        "dynFile": [
            "Thicken"
        ],
        "imageFile": [
            "Thicken"
        ],
        "inDepth": "Thicken will create a solid by offsetting a surface according to the thickness input and capping the ends to close the solid. In  the example below, we first create a surface by using a BySweep2Rails. We then create a solid by using a number slider to dermine the thickness input of a Thicken node."
    },
    {
        "Name": "Thicken (surface, thickness, both_sides)",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Action",
        "dynFile": [
            "Thicken_bothSides"
        ],
        "imageFile": [
            "Thicken_bothSides"
        ],
        "inDepth": "Thicken will create a solid by offsetting a surface according to the thickness input and capping the ends to close the solid. This Thicken node has an extra input to specify whether to thicken on both sides or not. The both_sides input takes a boolean value. In the example below, we first create a surface by using a BySweep2Rails. We then create a solid by using a number slider to dermine the thickness input of a Thicken node. A boolean toggle controls whether to thicken on both sides or just one. Note that the thickness parameter determines the total thickness of the final solid, so if both_sides is set to true, the result will be offset from the original surface by half the input thickness on both sides."
    },
    {
        "Name": "ToNurbsSurface",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Action",
        "dynFile": [
            "ToNurbsSurface"
        ],
        "imageFile": [
            "ToNurbsSurface"
        ],
        "inDepth": "Surface To Nurbs Surface takes a surface as input and returns a Nurbs Surface that approximates the input surface. In the example below, we create a surface using a ByPatch node with a close Nurbs Curve as an input. Note that when we use this surface as the input for a ToNurbsSurface node, the result is an untrimmed Nurbs Surface with four sides."
    },
    {
        "Name": "UVParameterAtPoint",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "folderPath": "Geometry/Surface/Action",
        "dynFile": [
            "UVParameterAtPoint"
        ],
        "imageFile": [
            "UVParameterAtPoint"
        ],
        "inDepth": "UV Parameter At Point finds the UV position of the surface at the input point on a surface. If the input point is not on the surface, this node will find the point on the surface that is nearest to the input point. In the example below, we first create a surface by using a BySweep2Rails. We then use a Code Block to specify a point to find the UN parameter at. The point is not on the surface, so the node uses the closest point on the surface as the position to find the UV parameter of."
    },
    {
        "Name": "AddItemToEnd",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "AddItemToEnd"
        ],
        "imageFile": [
            "AddItemToEnd"
        ],
        "inDepth": "Add Item to End will insert a specified item at the end of a given list. Note that if a list object is used as the item to add, the entire list is added as a single object, producing a list within a list. To combine two lists together into a single flat list, see List.Join. In the example below, we use a code block to generate a range of numbers from zero to five, stepping by one. We then add a new item, the number 20, to the end of that list using AddItemToEnd."
    },
    {
        "Name": "AddItemToFront",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "AddItemToFront"
        ],
        "imageFile": [
            "AddItemToFront"
        ],
        "inDepth": "Add Item to Front will insert a specified item at the beginning of a given list. The new item will have index 0, while the original items will all be shifted by an index of 1. Note that if a list object is used as the item to add, the entire list is added as a single object, producing a list within a list. To combine two lists together into a single flat list, see List.Join. In the example below, we use a code block to generate a range of numbers from zero to five, stepping by one. We then add a new item, the number 20, to the front of that list using AddItemToFront."
    },
    {
        "Name": "AllIndicesOf",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "AllIndicesOf"
        ],
        "imageFile": [
            "AllIndicesOf"
        ],
        "inDepth": "All Indicies Of will search a given list for the input item, and returns a list of the indices at which that item is found. In the example below, we first generate a list of random numbers between zero and 5. We can then use AllIndiciesOf to search that list for an input number."
    },
    {
        "Name": "Chop",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "Chop"
        ],
        "imageFile": [
            "Chop"
        ],
        "inDepth": "Chop will split a given list into smaller lists according to a list of input integer lengths. It returns a nested list with the first list containing a number of elements equal to the first number of the list input into 'lengths', the second list containing a number of elements equal to the second number of the list input into 'lengths' and so on. Chop will repeat the last number in the 'lengths' input until all elements from the input list are chopped. In the example below, we use a code block to generate a range of numbers between 0 and 5, stepping by one. This list has 6 elements in it. We use a second code block to create a list of lengths to chop the first list into."
    },
    {
        "Name": "Combinations",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "Combinations"
        ],
        "imageFile": [
            "Combinations"
        ],
        "inDepth": "Combinations will return a nested list that includes all possible combinations of the items in the input list with a given length. For combinations, the order of the elements does not matter, so the output list {0,1} is considered the same combination as {1,0}. If 'replace' is set to true, the items will be replaced back into the original list, allowing for elements to be used repeatedly in a combination. In the example below, we use a code block to generate a range of numbers from 0 to 5, stepping by one. We use Combinations with an input length of 3 to generate all the different ways to combine 3 of those numbers. A boolean toggle allows to select whether numbers are replaced or not."
    },
    {
        "Name": "ContainsItem",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "ContainsItem"
        ],
        "imageFile": [
            "ContainsItem"
        ],
        "inDepth": "Contains Item searches through a given list for an input item and returns a boolean value based on whether the item is found within the list or not. In the example below, we use a code block to generate a range of numbers from zero to 5, stepping by one. We then use a ContainsItem node to search for the number 3. Since 3 is contained within the list, ContainItem returns the value 'true'."
    },
    {
        "Name": "Count",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "Count"
        ],
        "imageFile": [
            "Count"
        ],
        "inDepth": "Count returns the number of items within a list. This only counts first level items, so if one of the items is a nested list itself, that item is still counted once. In the example below, we use a code block to generate a range of numbers from 0 to 5 stepping by one. By using a Count node, we can see that this list has 6 items. "
    },
    {
        "Name": "Cycle",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "Cycle"
        ],
        "imageFile": [
            "Cycle"
        ],
        "inDepth": "Cycle will take an input list and return a new list comprised of the input list repeated according the input 'amount'. In the example below, we first use a code block to generate a range of numbers from zero to five, stepping by one. We then use a Cycle node with an input amount of 3. The result is a list with 18 elements, consisting of 3 cycles of the original list."
    },
    {
        "Name": "Deconstruct",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "Deconstruct"
        ],
        "imageFile": [
            "Deconstruct"
        ],
        "inDepth": "Deconstruct will take an input list and separate the first item in the list from the remainder. This node has two outputs. The first output is the first item of the original list. The second output is a list with the remaining elements from the original list. In the example below, we first use a code block to generate a range of numbers from zero to five, stepping by one. We then use a Deconstruct node to separate the first item from the remainder. The result is the item '0' as one output, and a list of the range from 1 to 5 as a second output."
    },
    {
        "Name": "FirstIndexOf",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "FirstIndexOf"
        ],
        "imageFile": [
            "FirstIndexOf"
        ],
        "inDepth": "First Index Of will search through a given list and return the index of the first instance of the input item to search for. In the example below, we first generate list of ten random numbers between 0 and 4. By using a FirstIndexOf node, we can search for a specific item, and get the index of the first time that item is found in the last."
    },
    {
        "Name": "FirstItem",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "FirstItem"
        ],
        "imageFile": [
            "FirstItem"
        ],
        "inDepth": "First Item simply returns the first item of an input list. In the example below, we generate a list of ten random numbers between zero and five. We then use FirstItem node to return the first item of the list. "
    },
    {
        "Name": "Flatten",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "Flatten"
        ],
        "imageFile": [
            "Flatten"
        ],
        "inDepth": "Flatten will take a nested list and flatten levels of the list by combining the first levels into a single level. The 'amt' input determines how many levels to flatten. Flatten works starts from the first branch. In the example below, we first generate a range of numbers from 1 to 5, stepping by one. This creates a list of 5 elements. We use this list as the input for the lengths of a cuboid, producing a list of 5 cuboids. By exploding the cuboids, we get a list of 6 faces for each cuboid. We now have 5 lists of 6 faces, for a total of 30 elements. We go one step further by finding the edges of each face. The result is 5 lists of 6 lists of 4 edges, or a total of 120 elements. By using a Flatten node, we take the first level, the initial 5 different lists, and combine that into a single list. The resulting output is 30 lists of 4 edges. "
    },
    {
        "Name": "GetItemAtIndex",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "GetItemAtIndex"
        ],
        "imageFile": [
            "GetItemAtIndex"
        ],
        "inDepth": "Get Item At Index takes an input list, and an integer and returns the item from the list found at the input index. In the example below, we first use a code block to generate a range of numbers from zero to 5, stepping by one. We can then extract a single element at a specified index by using a GetItemAtIndex node."
    },
    {
        "Name": "GroupByKey",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "GroupByKey"
        ],
        "imageFile": [
            "GroupByKey"
        ],
        "inDepth": "Group By Key takes an input list of items to group, and a list of keys to determine how the first list is grouped. The list of keys should have the same number of elements as the input list. Items in the original list that correspond to matching keys will be grouped together in an output list. In the example below, we use a range of numbers between 0 and 9 as the input list. We also generate a list of 10 random numbers between 0 and 4 to use as the keys. GroupByKey outputs a nested list of elements, grouped according to the corresponding key. It also outputs a list of the unique keys."
    },
    {
        "Name": "IsEmpty",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "IsEmpty"
        ],
        "imageFile": [
            "IsEmpty"
        ],
        "inDepth": "Is Empty takes a list as input, and returns a boolean value based on whether or not the input list is empty. In the example below, we first use a code block to generate a range of numbers from zero to 5, stepping by one. We input this list into an IsEmpty node. Since the list is not empty, IsEmpty returns a 'false' value."
    },
    {
        "Name": "Join",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "Join"
        ],
        "imageFile": [
            "Join"
        ],
        "inDepth": "Join will take the input lists and join them together into a single list. You adjust the number of input points by using the '+' and '-' buttons on the Join node. In the example below, we first use two codes blocks to generate two ranges of numbers. One is the odd numbers {1,3,5}, while the second is the even numbers {0,2,4}. By using a Join node, we can join these two lists into a single list {1,3,5,0,2,6}. "
    },
    {
        "Name": "LastItem",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "LastItem"
        ],
        "imageFile": [
            "LastItem"
        ],
        "inDepth": "Last Item simply returns the last item of an input list. In the example below, we generate a list of ten random numbers between zero and five. We then use LastItem node to return the last item of the list. "
    },
    {
        "Name": "List.CartesianProduct",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "ListCartesianProduct"
        ],
        "imageFile": [
            "ListCartesianProduct"
        ],
        "inDepth": "Cartesian Product will apply an input combinator to each pair of items across two lists. The first item of the first input list will be combined with each element of the second list in turn, followed by the second item in the first list combined with each element of the second list, and so on. In the example below, we use addition as our combinator. Note that we leave the inputs to the Addition empty, causing the node to return a 'function', which will act as the combinator for our Cartesian Product node. We then use two code blocks to create two ranges of numbers: {0,1,2,3,4,5} and {1,3,5} to combine together. For a simple operation like addition with two numbers, using Cartesian Product is equivalent to using an Addition node directly and changing the lacing to Cross Product. Both are shown in the example below as a comparison."
    },
    {
        "Name": "List.Combine",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "ListCombine"
        ],
        "imageFile": [
            "ListCombine"
        ],
        "inDepth": "Combine will apply an input combinator to corresponding elements in two input lists. In the example below, we use addition as our combinator. Note that we leave the inputs to the Addition empty, causing the node to return a 'function'.  We then use two code blocks to create two ranges of numbers: {0,1,2,3,4,5} and {1,3,5} to combine together. If the two lists do not have the same number of elements, Combine will return 'null' for the unmatched elements."
    },
    {
        "Name": "List.Filter",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "ListFilter"
        ],
        "imageFile": [
            "ListFilter"
        ],
        "inDepth": "Filter takes an input list and splits it into two new list according to an input condition test. The condition is applied to each element in the list. If the condition evaluates to 'true', that list item will be put in the 'in' output, otherwise it will be in the 'out' output. In the example below, we first use a code block to generate a range of numbers from zero to five, stepping by one. For the condition input, we use a Greater Than node with the number '2' input as the y value. Note that the x input is left blank. This causes the Greater Node to return a function. When applied as the condition for a Filter node, the items from the input list to filter will be used as the x input for the Greater Than function. The result is two list, the first list containing the elements greater than 2, and the second containing the elements less than or equal to 2."
    },
    {
        "Name": "List.LaceLongest",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "ListLaceLongest"
        ],
        "imageFile": [
            "ListLaceLongest"
        ],
        "inDepth": "Lace Longest will apply an input combinator to corresponding elements in two input lists. In the example below, we use addition as our combinator. Note that we leave the inputs to the Addition empty, causing the node to return a 'function'.  We then use two code blocks to create two ranges of numbers: {0,1,2,3,4,5} and {1,3,5} to combine together. Lace Longest behaves in the same way as List.Combine, except instead of returning 'null' for unmatched elements it will repeat the last element of the shorter list. For a simple operation like addition of two elements, this is equivalent to using the Addition node directly and changing the lacing to 'Longest'."
    },
    {
        "Name": "List.LaceShortest",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "ListLaceShortest"
        ],
        "imageFile": [
            "ListLaceShortest"
        ],
        "inDepth": "Lace Shortest will apply an input combinator to corresponding elements in two input lists. In the example below, we use addition as our combinator. Note that we leave the inputs to the Addition empty, causing the node to return a 'function'.  We then use two code blocks to create two ranges of numbers: {0,1,2,3,4,5} and {1,3,5} to combine together. Lace Shortest behaves in the same way as List.Combine, except instead of returning 'null' for unmatched elements it will ignore the unmatched elements of the longer list. For a simple operation like addition of two elements, this is equivalent to using the Addition node directly and changing the lacing to 'Shortest'."
    },
    {
        "Name": "List.Map",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "ListMap"
        ],
        "imageFile": [
            "ListMap"
        ],
        "inDepth": "Map will take an input function and apply it to each element of an input list. In the example below, we first use a code block to generate a range of numbers from zero to five with a step of one. We use an Addition node with a y input of 3 as the f(x) input. Note that by leaving the x input blank on the Addition node, it returns a function. The output from List.Map contains each number from the original increased by 3."
    },
    {
        "Name": "List.Reduce",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "ListReduce"
        ],
        "imageFile": [
            "ListReduce"
        ],
        "inDepth": "List.Reduce will combine the elements in a list together by applying a reductor function sequentially to each item in the list, using the accumulated result as the first argument to combine with each subsequent element. The 'seed' input is the initial first argument to combine with the first element of the list. In the example below, we use an Addition node as our reductor function. The two inputs to the Addition node are left blank. A seed of 10 is used, and a range {0,1,2,3,4,5} is used as the list to reduce. List.Reduce will start with the seed 10 and combine it with the first element from the list using addition. The result will then be combined with the second element, and so on until the whole list is completed."
    },
    {
        "Name": "List.Scan",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "ListScan"
        ],
        "imageFile": [
            "ListScan"
        ],
        "inDepth": "List.Scan will combine the elements in a list together by applying a reductor function sequentially to each item in the list, using the accumulated result as the first argument to combine with each subsequent element. Each result is output to a list showing the accumulated values. The 'seed' input is the initial first argument to combine with the first element of the list. In the example below, we use an Addition node as our reductor function. The two inputs to the Addition node are left blank. A seed of 10 is used, and a range {0,1,2,3,4,5} is used as the list to reduce. List.Scan will start with the seed 10 and combine it with the first element from the list using addition. The result will then be combined with the second element, and so on until the whole list is completed."
    },
    {
        "Name": "MaximumItem",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "MaximumItem"
        ],
        "imageFile": [
            "MaximumItem"
        ],
        "inDepth": "Maximum Item will search through a list of values and return the item with the maximum value. In the example below we generate a list of 10 random numbers between 0 and 49. We then use a MaximumItem node to find the largest item in the list."
    },
    {
        "Name": "MinimumItem",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "MinimumItem"
        ],
        "imageFile": [
            "MinimumItem"
        ],
        "inDepth": "Minimum Item will search through a list of values and return the item with the minimum value. In the example below we generate a list of 10 random numbers between 0 and 49. We then use a MinimumItem node to find the smallest item in the list."
    },
    {
        "Name": "OfRepeatedItem",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "OfRepeatedItem"
        ],
        "imageFile": [
            "OfRepeatedItem"
        ],
        "inDepth": "Of Repeated Item will create a list by repeated a given item a certain number of times specified by the 'amount' input. In the example below, we create a list consisting of the number 4 repeated ten times."
    },
    {
        "Name": "Permutations",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "Permutations"
        ],
        "imageFile": [
            "Permutations"
        ],
        "inDepth": "Permutations will create a nested list consisting of all permutations of a specified length from a given input list. In the example below, we use a code block to create a range of numbers from 0 to 5, stepping by one. We then use a Permutation node with an length input of 3 to generate all permutations of three elements from the range {0,1,2,3,4,5}."
    },
    {
        "Name": "RemoveItemAtIndex",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "RemoveItemAtIndex"
        ],
        "imageFile": [
            "RemoveItemAtIndex"
        ],
        "inDepth": "Remove Item At Index will take an input list of items, and create a new list by removing the items at specified indices. In the example below we start with a range of numbers from zero to five. We then remove the item with index 3."
    },
    {
        "Name": "ReplaceByCondition",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "ReplaceByCondition"
        ],
        "imageFile": [
            "ReplaceByCondition"
        ],
        "inDepth": "Replace By Condition will take a given list and evaluate each item with a given condition. If the condition evaluates to 'true', the corresponding item will be replaced in the output list with the item specified in the replaceWith input. In the example below, we use a Formula node and enter the formula x%2==0, which finds the remainder of a given item after dividing by 2, and then checks to see if that remainder is equal to zero. This formula will return 'true' for even integers. Note that the input x is left blank. Using this formula as the condition in a ReplaceByCondition node results in an output list where each even number is replaced by the specified item, in this case the integer 10."
    },
    {
        "Name": "ReplaceItemAtIndex",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "ReplaceItemAtIndex"
        ],
        "imageFile": [
            "ReplaceItemAtIndex"
        ],
        "inDepth": "Replace Item At Index will take an input list, a list of indices at which to replace items, and a new item to replace with. In the example below, we start with a range of numbers from zero to five. We then use a ReplaceItemAtIndex node to replace the item at index 3 with a new item, in this case the integer 10."
    },
    {
        "Name": "RestOfItems",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "RestOfItems"
        ],
        "imageFile": [
            "RestOfItems"
        ],
        "inDepth": "Rest Of Items will remove the first element from a list and return the remaining elements in a new list. In the example below, we start with a range of numbers from zero to five. After using a RestOfItems node, the output list is a range of numbers from one to five. The first element from the original list has been removed."
    },
    {
        "Name": "Slice",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "Slice"
        ],
        "imageFile": [
            "Slice"
        ],
        "inDepth": "Slice will return a sublist from an input last. The start input specifies which index the output list will start with. The end input specifies when to stop taking elements from the input. This end index is not included in the output list. In the example below, using a start index of 2 and an end input of 5 results in a new list consisting of the items with indices 2,3, and 4 from the orginal list."
    },
    {
        "Name": "SortByKey",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "SortByKey"
        ],
        "imageFile": [
            "SortByKey"
        ],
        "inDepth": "Sort By Key takes an input list to sort, and a list of corresponding sortable keys. Sort By Key will sort the list of keys in ascending order, and will rearrange the input list to correspond to the new order of the sorted keys. This node outputs both the rearranged list, and the sorted list of keys. In the example below, we use a range from zero to nine as our input list. For the list of keys, we generate a list of 10 random numbers between zero and four. The list of keys is sorted numerically, while the range from 0 to 9 is rearranged according to the order of the corresponding elements from the list of keys."
    },
    {
        "Name": "Sublists",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "Sublists"
        ],
        "imageFile": [
            "Sublists"
        ],
        "inDepth": "Sublists will take a input list and return a series of sublists based on the input range and offset. The range determines which elements of the input list to put into the first sublist. The offset is applied to the range, and the new range will determine the second sublist. This process repeats, increasing the range by the given offset until the resulting sublist is empty. In the example below, we start with a range of numbers from zero to nine. The range 0 to 5 is used as the sublist range, and we use an offset of 2. In the output of nested sublists, the first list contains the elements with indicies in the range 0..5, the second list contains the elements with indicies 2..7. As this is repeated, the subsequent sublists get shorter as the end of the range becomes larger than the length of the initial list."
    },
    {
        "Name": "TakeItems",
        "categories": [
            "Core",
            "List"
        ],
        "folderPath": "Core/List/Action",
        "dynFile": [
            "TakeItems"
        ],
        "imageFile": [
            "TakeItems"
        ],
        "inDepth": "Take Items will return a new list with the input number of elements taking from the beginning of the input list. In the example below, we start with a range of numbers from zero to nine. We use an integer slider to specify the amount of elements to take from the original list. With an input of 4, the output list will be the first 4 elemenst from the original list."
    },
    {
        "Name": "If",
        "categories": [
            "Core",
            "Logic"
        ],
        "folderPath": "Core/Logic/Create",
        "dynFile": [
            "If"
        ],
        "imageFile": [
            "If"
        ],
        "inDepth": "If acts as a conditional control node. The 'test' input takes a boolean value, while the 'true' and 'false' inputs can accept any data type. If the test value is 'true', the node will return the item from the 'true' input, if test is 'false', the node will return the item from the 'false' input. In the example below, we first generate a list of random numbers between zero and 99. The number of items in the list is controlled by an integer slider. We use a code block with the formula 'x%a==0' to test for divisibility by a second number, determined by a second number slider. This generates a list of boolean values corresponding to whether the items in the random list are divisible by the number determined by the second integer slider. This list of boolean values is used as the 'test' input for an If node. We use a default Sphere as the 'true' input, and a default Cuboid as the 'false' input. The result from the If node is a list of either spheres or cuboids. Finally, we use a Translate node to spread the list of geometries apart."
    },
    {
        "Name": "And",
        "categories": [
            "Core",
            "Logic"
        ],
        "folderPath": "Core/Logic/Create",
        "dynFile": [
            "And"
        ],
        "imageFile": [
            "And"
        ],
        "inDepth": "And will take a variable number of boolean inputs. You can increase or decrease the number of inputs by using the '+' and '-' buttons on the And node. Each input must be a single boolean value. And will return 'true' if all of the inputs are true, otherwise it will return 'false'. In the example below, we have three boolean toggles used as inputs for an And node. When all three are set to 'true', And will return 'true'."
    },
    {
        "Name": "Or",
        "categories": [
            "Core",
            "Logic"
        ],
        "folderPath": "Core/Logic/Create",
        "dynFile": [
            "Or"
        ],
        "imageFile": [
            "Or"
        ],
        "inDepth": "Or will take a variable number of boolean inputs. You can increase or decrease the number of inputs by using the '+' and '-' buttons on the Or node. Each input must be a single boolean value. Or will return 'true' if at least one of the inputs are true, otherwise if all inputs are 'false', it will return 'false'. In the example below, we have three boolean toggles used as inputs for an Or node. When all three are set to 'false', Or will return 'false'."
    },
    {
        "Name": "Xor",
        "categories": [
            "Core",
            "Logic"
        ],
        "folderPath": "Core/Logic/Create",
        "dynFile": [
            "Xor"
        ],
        "imageFile": [
            "Xor"
        ],
        "inDepth": "Xor will accept two boolean values, or two lists of boolean values and determines whether the values are the same or different. Xor compares two values and returns 'true' if exactly one of the inputs is 'true'. If both values are 'true' or if both values are 'false', Xor will return 'false'. In the example below, we start with two lists of boolean values. Together, these lists represent the four possible combinations of true and false values. Notice that unlike And and Or nodes, Xor only allows two values."
    },
    {
        "Name": "PointAtParameter",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "PointAtParameter"
        ],
        "imageFile": [
            "PointAtParameter"
        ],
        "inDepth": "Point At Parameter will return a point at a given parameter along an input curve. The parameterization of a curve is bounded between zero and one, where the start of the curve has a parameter of zero, and the end of the curve has a parameter of one. In the example below, we use two sets of random numbers to generate a list of points. These points are used to create a Nurbs Curve by Control Points. A number slider is set to the range of zero to one, and used as the input parameter to a Point At Parameter node."
    },
    {
        "Name": "PointAtSegmentLength",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "PointAtSegmentLength"
        ],
        "imageFile": [
            "PointAtSegmentLength"
        ],
        "inDepth": "Point At Segment Length will return the point on a curve at a given length along the curve, measured from the start point of the curve. If the input length is greater than the length of the curve, the node will return the end point of the curve. In the example below, we use two sets of random numbers to generate a list of points. These points are used to create a Nurbs Curve by Control Points. A number slider is and used as the input length to a Point At Segment Length node. "
    },
    {
        "Name": "PointsAtEqualChordLength",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "PointsAtEqualChordLength"
        ],
        "imageFile": [
            "PointsAtEqualChordLength"
        ],
        "inDepth": "Points At Equal Chord Length will return a list of points along an input curve by dividing the curve into equal straight-line chord lengths. The number of divisions to use is input as an integer, and will result in that number of points divided equally in the interior of the curve. This node will not include the end points of the curve. In the example below, we use two sets of random numbers to generate a list of points. These points are used to create a Nurbs Curve by Control Points. An integer slider is used for the divisions input in a PointsAtEqualChordLength node."
    },
    {
        "Name": "PointsAtEqualSegmentLength",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "PointsAtEqualSegmentLength"
        ],
        "imageFile": [
            "PointsAtEqualSegmentLength"
        ],
        "inDepth": "Points At Equal Segment Length will return a list of points along an input curve by dividing the curve into equal length segments. The number of divisions to use is input as an integer, and will result in that number of points divided equally in the interior of the curve. This node will not include the end points of the curve. In the example below, we use two sets of random numbers to generate a list of points. These points are used to create a Nurbs Curve by Control Points. An integer slider is used for the divisions input in a PointsAtEqualSegmentLength node."
    },
    {
        "Name": "SegmentLengthAtParameter",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "SegmentLengthAtParameter"
        ],
        "imageFile": [
            "SegmentLengthAtParameter"
        ],
        "inDepth": "Segment Length At Parameter will return the length of a curve between the start point and the input parameter, where zero is the parameter at the beginning of the curve, and one is the parameter at the end of the curve. In the example below, we use two sets of random numbers to generate a list of points. These points are used to create a Nurbs Curve by Control Points. A number slider set to the range zero to one is used for the parameter input in a SegmentLengthAtParameter node."
    },
    {
        "Name": "SegmentLengthBetweenParameters",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "SegmentLengthBetweenParameters"
        ],
        "imageFile": [
            "SegmentLengthBetweenParameters"
        ],
        "inDepth": "Segment Length Between Parameters will return the length of a curve between the input start parameter and the input end parameter, where a value of zero is the parameter at the beginning of the curve and a value of one is the parameter at the end of the curve. In the example below, we use two sets of random numbers to generate a list of points. These points are used to create a Nurbs Curve by Control Points. Two number sliders set to the range zero to one is used for the parameter inputs in a SegmentLengthBetweenParameters node."
    },
    {
        "Name": "TrimInteriorByParameter",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "TrimInteriorByParameter"
        ],
        "imageFile": [
            "TrimInteriorByParameter"
        ],
        "inDepth": "Trim Interior By Parameter will remove the interior portion of a given curve, based on the two input parameters. This node will output the two remaining exterior parts of the curve as a list of two curves.  In the example below, we use two sets of random numbers to generate a list of points. These points are used to create a Nurbs Curve by Control Points. Two number sliders set to the range zero to one is used for the parameter inputs in a TrimInteriorByParameter node."
    },
    {
        "Name": "ApproximateWithArcAndLineSegments",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "ApproximateWithArcAndLineSegments"
        ],
        "imageFile": [
            "ApproximateWithArcAndLineSegments"
        ],
        "inDepth": "Approximate with Arc and Line Segments takes a curve as input, and returns a list of straight line and arc curves that approximate the original curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. This curve is then used as the input for an ApproximateWithArcAndLineSegments node."
    },
    {
        "Name": "CoordinateSystemAtParameter",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "CoordinateSystemAtParameter"
        ],
        "imageFile": [
            "CoordinateSystemAtParameter"
        ],
        "inDepth": "Coordinate System At Parameter will return a coordinate system aligned with the input curve at the specified parameter. The parameterization of a curve is measured in the range from zero to one, with zero representing the start of the curve and one representing the end of the curve. The resulting coordinate system will have its x-axis in the direction of the normal of the curve and the y-axis in the direction of the tangent of the curve at the specified parameter. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider set to the range 0 to 1 is used to control the parameter input for a CoordinateSystemAtParameter node."
    },
    {
        "Name": "CoordinateSystemAtSegmentLength",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "CoordinateSystemAtSegmentLength"
        ],
        "imageFile": [
            "CoordinateSystemAtSegmentLength"
        ],
        "inDepth": "Coordinate System At Segment Length will return a coordinate system aligned with the input curve at the specified curve length, measured from the start point of the curve. The resulting coordinate system will have its x-axis in the direction of the normal of the curve and the y-axis in the direction of the tangent of the curve at the specified length. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider is used to control the segment length input for a CoordinateSystemAtParameter node. If the specified length is longer than the length of the curve, this node will return a Coordinate System at the end point of the curve."
    },
    {
        "Name": "EndParameter",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "EndParameter"
        ],
        "imageFile": [
            "EndParameter"
        ],
        "inDepth": "End Parameter will return a number that represents the end of the domain in which the input curve can be evaluated. In most cases the end parameter will be one. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. This curve is then used as the input to an EndParameter node. "
    },
    {
        "Name": "Extend",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "Extend"
        ],
        "imageFile": [
            "Extend"
        ],
        "inDepth": "Extend will extend a input curve by a given input distance. The pickSide input takes the start or end point of the curve as input, and determines which end of the curve to extend. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. We use the query node Curve.EndPoint to find the end point of the curve, to use as the 'pickSide' input. A number slider allows us to control the distance of the extension."
    },
    {
        "Name": "ExtendEnd",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "ExtendEnd"
        ],
        "imageFile": [
            "ExtendEnd"
        ],
        "inDepth": "Extend End will extend a input curve by a given input distance, starting from the end point of the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider allows us to control the distance of the extension."
    },
    {
        "Name": "ExtendStart",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "ExtendStart"
        ],
        "imageFile": [
            "ExtendStart"
        ],
        "inDepth": "Extend Start will extend a input curve by a given input distance, starting from the start point of the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider allows us to control the distance of the extension."
    },
    {
        "Name": "Extrude (curve, direction)",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "Extrude_direction"
        ],
        "imageFile": [
            "Extrude_direction"
        ],
        "inDepth": "Extrude by direction will extrude an input curve using an input vector to determine the direction of the extrusion. The length of the vector will be used for the extrusion distance. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A Code Block is used to specify the x,y, and z components of a Vector.ByCoordinates node. This vector is then used as the direction input in an Extrude node."
    },
    {
        "Name": "Extrude (curve, direction, distance)",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "Extrude_direction_distance"
        ],
        "imageFile": [
            "Extrude_direction_distance"
        ],
        "inDepth": "Extrude by direction and distance will extrude an input curve using an input vector to determine the direction of the extrusion. A separate distance input will be used for the extrusion distance. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A Code Block is used to specify the x,y, and z components of a Vector.ByCoordinates node. This vector is then used as the direction input in an Extrude node while a number slider is used to control the distance input."
    },
    {
        "Name": "Extrude (curve, distance)",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "Extrude_distance"
        ],
        "imageFile": [
            "Extrude_distance"
        ],
        "inDepth": "Extrude by distance will extrude an input curve using an input number to determine the distance of the extrusion. The direction of the normal vector along the curve will be used for the extrusion direction. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider is used as the distance input in an Extrude node."
    },
    {
        "Name": "ExtrudeAsSolid (curve, direction)",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "ExtrudeAsSolid_direction"
        ],
        "imageFile": [
            "ExtrudeAsSolid_direction"
        ],
        "inDepth": "Extrude As Solid by direction will extrude an input closed, planar curve using an input vector to determine the direction of the extrusion. The length of the vector will be used for the extrusion distance. This node will cap the the ends of the extrusion to create a solid. In the example below, we first create a Nurbs Curve using a ByPoints node, with a set of randomly generated points as the input. A Code Block is used to specify the x,y, and z components of a Vector.ByCoordinates node. This vector is then used as the direction input in an ExtrudeAsSolid node."
    },
    {
        "Name": "ExtrudeAsSolid (curve, direction, distance)",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "ExtrudeAsSolid_direction_distance"
        ],
        "imageFile": [
            "ExtrudeAsSolid_direction_distance"
        ],
        "inDepth": "Extrude As Solid by direction and distance will extrude an input closed, planar curve using an input vector to determine the direction of the extrusion. A separate distance input will be used for the extrusion distance. This node will cap the the ends of the extrusion to create a solid. In the example below, we first create a Nurbs Curve using a ByPoints node, with a set of randomly generated points as the input. A Code Block is used to specify the x,y, and z components of a Vector.ByCoordinates node. This vector is then used as the direction input in an ExtrudeAsSolid node while a number slider is used to control the distance input."
    },
    {
        "Name": "ExtrudeAsSolid (curve, distance)",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "ExtrudeAsSolid_distance"
        ],
        "imageFile": [
            "ExtrudeAsSolid_distance"
        ],
        "inDepth": "Extrude As Solid by distance will extrude an input closed, planar curve using an input number to determine the distance of the extrusion. The direction of the extrusion is determined by the normal vector of the plane the curve lies in. This node will cap the the ends of the extrusion to create a solid. In the example below, we first create a Nurbs Curve using a ByPoints node, with a set of randomly generated points as the input. A Number Slider is used as the distance input in an ExtrudeAsSolid node."
    },
    {
        "Name": "HorizontalFrameAtParameter",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "HorizontalFrameAtParameter"
        ],
        "imageFile": [
            "HorizontalFrameAtParameter"
        ],
        "inDepth": "Horizontal Frame At Parameter will return a coordinate system aligned with the input curve at the specified parameter. The parameterization of a curve is measured in the range from zero to one, with zero representing the start of the curve and one representing the end of the curve. The resulting coordinate system will have its z-axis in the world Z direction, and the y-axis in the direction of the tangent of the curve at the specified parameter. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider set to the range 0 to 1 is used to control the parameter input for a HorizontalFrameAtParameter node."
    },
    {
        "Name": "NormalAtParameter",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "NormalAtParameter"
        ],
        "imageFile": [
            "NormalAtParameter"
        ],
        "inDepth": "Normal At Parameter will return a vector aligned with the normal direction at the specified parameter of a curve. The parameterization of a curve is measured in the range from zero to one, with zero representing the start of the curve and one representing the end of the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider set to the range 0 to 1 is used to control the parameter input for a NormalAtParameter node."
    },
    {
        "Name": "Offset",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "Offset"
        ],
        "imageFile": [
            "Offset"
        ],
        "inDepth": "Offset will create a new curve offset by a specified distance from an input curve. The input curve must be planar. A negative direction will produce an offset on the opposite side of the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider set to the range 0 to 1 is used to control the parameter input for an Offset node."
    },
    {
        "Name": "ParameterAtChordLength",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "ParameterAtChordLength"
        ],
        "imageFile": [
            "ParameterAtChordLength"
        ],
        "inDepth": "Parameter At Chord Length will return the parameter of a point that is a given chord length from an initial specified parameter. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider is used to control the straight-line chord distance to find a parameter at. A second number slider set to the range 0 to 1 is used to control the initial point along the curve from which the chord distance will be measured. Finally, a boolean toggle is used to determine which direction to measure the chord distance from."
    },
    {
        "Name": "ParameterAtPoint",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "ParameterAtPoint"
        ],
        "imageFile": [
            "ParameterAtPoint"
        ],
        "inDepth": "Parameter at Point will return the parameter value of a specified point along a curve. If the input point is not on the curve, Parameter At Point will return the parameter of the point on the curve closes to the input point. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. An extra single point is created with a Code Block to specify the x and y coordinates. The ParameterAtPoint node returns the parameter along the curve at the point that is closest to the input point."
    },
    {
        "Name": "ParameterAtSegmentLength",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "ParameterAtSegmentLength"
        ],
        "imageFile": [
            "ParameterAtSegmentLength"
        ],
        "inDepth": "Parameter At Segment Length will return the parameter of a point that is a given length along the curve from the start point. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider is used to control the segment length to find a parameter at. If the input segment length is longer than the curve, this node will return the parameter value of the end point of the curve."
    },
    {
        "Name": "PointsAtChordLengthFromPoint",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "PointsAtChordLengthFromPoint"
        ],
        "imageFile": [
            "PointsAtChordLengthFromPoint"
        ],
        "inDepth": "Points At Chord Length From Point will return a list of points along a curve, measured sequentially according to an input chord length starting from a specified point along the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A PointAtParameter node is used with a number slider set to the range 0 to 1 to determine the initial point along the curve for a PointsAtChordLengthFromPoint node. Finally, a second number slider is used to adjust the straight-line chord length to use."
    },
    {
        "Name": "PointsAtSegmentLengthFromPoint",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "PointsAtSegmentLengthFromPoint"
        ],
        "imageFile": [
            "PointsAtSegmentLengthFromPoint"
        ],
        "inDepth": "Points At Segment Length From Point will return a list of points along a curve, measured sequentially according to an input segment length starting from a specified point along the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A PointAtParameter node is used with a number slider set to the range 0 to 1 to determine the initial point along the curve for a PointsAtSegmentLengthFromPoint node. Finally, a second number slider is used to adjust the curve segment length to use"
    },
    {
        "Name": "Project",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "Project"
        ],
        "imageFile": [
            "Project"
        ],
        "inDepth": "Project will project an input curve along a given projection direction onto a specified baseGeometry. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A sphere is created with a default radius of 1, and using a Code Block to specify the coordinates of the centerPoint. We use the world Y-axis as the direction vector for projection in a Project node. The output is a curve that results from the original curve being projected in the Y direction onto the sphere."
    },
    {
        "Name": "PullOntoPlane",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "PullOntoPlane"
        ],
        "imageFile": [
            "PullOntoPlane"
        ],
        "inDepth": "Pull Onto Plane will create a new curve by projecting an input curve onto an input plane, using the normal of the plane as the direction of projection. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. We use the world XY plane as the plane to project onto in a PullOntoPlane node. The result is a planar curve on the XY plane."
    },
    {
        "Name": "PullOntoSurface",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "PullOntoSurface"
        ],
        "imageFile": [
            "PullOntoSurface"
        ],
        "inDepth": "Pull Onto Surface will create a new curve by projecting an input curve onto an input surface, using the normal vectors of the surface as the directions of projection. In the example below, we first create surface by using a Surface.BySweep node that uses curves generated according to a sine curve. This surface is used as the base surface to pull onto in a PullOntoSurface node. For the curve, we create a circle by using a Code Block to specify the coordinates of the center point, and a number slider to control the radius of the circle. The result is a projection of the cirle onto the surface. "
    },
    {
        "Name": "Reverse",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "Reverse"
        ],
        "imageFile": [
            "Reverse"
        ],
        "inDepth": "Reverse will reverse the inherent direction of a given curve. This will switch the start point and end point of the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. We then use a Reverse node to change the direction of the curve."
    },
    {
        "Name": "SplitByParameter (curve, parameter)",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "SplitByParameter"
        ],
        "imageFile": [
            "SplitByParameter"
        ],
        "inDepth": "Split By Parameter (curve, parameter) will take a curve and a single parameter as input. It will split the curve at the specified parameter, and return the two resulting curves as a list. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider set to the range of 0 to 1 is used to adjust the parameter to split the curve at."
    },
    {
        "Name": "SplitByParameter (curve, parameters)",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "SplitByParameters"
        ],
        "imageFile": [
            "SplitByParameters"
        ],
        "inDepth": "Split By Parameter (curve, parameters) will take a curve and a list of parameters as input. It will split the curve at the specified parameters, and return a list of resulting curves. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A Code Block is used to create a series of numbers between 0 and 1 to use as the list of parameters to split the cure at."
    },
    {
        "Name": "StartParameter",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "StartParameter"
        ],
        "imageFile": [
            "StartParameter"
        ],
        "inDepth": "Start Parameter will return a number that represents the start of the domain in which the input curve can be evaluated. In most cases the start parameter will be zero. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. This curve is then used as the input to an StartParameter node."
    },
    {
        "Name": "SweepAsSolid",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "SweepAsSolid"
        ],
        "imageFile": [
            "SweepAsSolid"
        ],
        "inDepth": "Sweep As Solid will create a solid by sweeping an input closed profile curve along a specified path. In the example below, we use a rectangle as the base profile curve. The path is created by using a cosine function with a sequence of angles to vary the x-coordinates of a set of points. The points are used as the input to a NurbsCurve.ByPoints node. We then create a solid by sweeping the rectangle along the created cosine curve."
    },
    {
        "Name": "SweepAsSurface",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "SweepAsSurface"
        ],
        "imageFile": [
            "SweepAsSurface"
        ],
        "inDepth": "SweepAsSurface will create a surface by sweeping an input curve along a specfied path. In the example below, we create a curve to sweep by useing a Code Block to create three points of an Arc.ByThreePoints node. A path curve is created a simple line along the x-axis. SweepAsSurface moves the profile curve along the path curve creating a surface."
    },
    {
        "Name": "TangentAtParameter",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "TangentAtParameter"
        ],
        "imageFile": [
            "TangentAtParameter"
        ],
        "inDepth": "Tangent At Parameter will return a vector aligned with the tangent direction at the specified parameter of a curve. The parameterization of a curve is measured in the range from zero to one, with zero representing the start of the curve and one representing the end of the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider set to the range 0 to 1 is used to control the parameter input for a TangentAtParameter node."
    },
    {
        "Name": "ToNurbsCurve",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "ToNurbsCurve"
        ],
        "imageFile": [
            "ToNurbsCurve"
        ],
        "inDepth": "To Nurbs Curve takes a curve as input, and returns a Nurbs curve that approximates the input curve. In the example below, we create an arc by using a Code Block to define three points and using an Arc.ByThreePoints node. This arc is converted to a Nurbs Curve by using a ToNurbsCurve node. Note that the default degree of the resulting Nurbs Curve is 3."
    },
    {
        "Name": "TrimByEndParameter",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "TrimByEndParameter"
        ],
        "imageFile": [
            "TrimByEndParameter"
        ],
        "inDepth": "Trim By End Parameter will remove the end of an input curve by trimming the curve at the specified parameter. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider set to the range 0 to 1 is used to control the parameter input for a TrimByEndParameter node."
    },
    {
        "Name": "TrimByParameter",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "TrimByParameter"
        ],
        "imageFile": [
            "TrimByParameter"
        ],
        "inDepth": "Trim By Parameter will remove the start and end of an input curve by trimming the curve at the specified parameters, and will return the resulting middle section of the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. Two number sliders set to the range 0 to 1 are used to control the start and end parameter inputs for a TrimByParameter node."
    },
    {
        "Name": "TrimByStartParameter",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "TrimByStartParameter"
        ],
        "imageFile": [
            "TrimByStartParameter"
        ],
        "inDepth": "Trim By Start Parameter will remove the beginning of an input curve by trimming the curve at the specified parameter. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider set to the range 0 to 1 is used to control the parameter input for a TrimByStartParameter node."
    },
    {
        "Name": "TrimSegmentsByParameter (curve, parameters)",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "TrimSegmentsByParameter"
        ],
        "imageFile": [
            "TrimSegmentsByParameter"
        ],
        "inDepth": "Trim Segments By Parameter first splits a curve at points determined by an input list of parameters. It then returns only the even numbered segments that result from the split. In the example below,  we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A Code Block is used to create a range of number between zero and one, stepping by 0.1. Using this as the input parameters for a TrimSegmentsByParameter node results in a list of curve that are effectively a dashed line version of the original curve."
    },
    {
        "Name": "TrimSegmentsByParameter (curve, parameters, discardEvenSegments)",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "TrimSegmentsByParameter_even"
        ],
        "imageFile": [
            "TrimSegmentsByParameter_even"
        ],
        "inDepth": "Trim Segments By Parameter, with discardEvenSegments first splits a curve at points determined by an input list of parameters. It then returns either the odd numbered segments or the even numbered sugements, as determined by the boolean value of the discardEvenSegments input. In the example below,  we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A Code Block is used to create a range of number between zero and one, stepping by 0.1. Using this as the input parameters for a TrimSegmentsByParameter node results in a list of curve that are effectively a dashed line version of the original curve."
    },
    {
        "Name": "PointAtChordLength",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "PointAtChordLength"
        ],
        "imageFile": [
            "PointAtChordLength"
        ],
        "inDepth": "Point At Chord Length will return the point that is a given chord length from an initial specified parameter. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider is used to control the straight-line chord distance to find a point at. A second number slider set to the range 0 to 1 is used to control the initial point along the curve from which the chord distance will be measured. Finally, a boolean toggle is used to determine which direction to measure the chord distance from."
    },
    {
        "Name": "Patch",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "Patch"
        ],
        "imageFile": [
            "Patch"
        ],
        "inDepth": "Patch will attempt to create a surface using an input curve as the boundary. The input curve must be closed. In the example below, we first use a Point.ByCylindricalCoordinates node to create a set of points at set intervals in a circle, but with random elevations and radii. We then use a NurbsCurve.ByPoints node to create a closed curve based on these points. A Patch node is cused to create a surface from the boundary closed curve. Note that because the points were created with random radii and elevations, not all arrangements result in a curve that is able to be patched."
    },
    {
        "Name": "PlaneAtParameter",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "PlaneAtParameter"
        ],
        "imageFile": [
            "PlaneAtParameter"
        ],
        "inDepth": "Plane At Parameter will return a plane aligned with a curve at a specified parameter. The normal vector of the resulting plane will correspond to the tangent of the curve. The parameterization of a curve is measured in the range from zero to one, with zero representing the start of the curve and one representing the end of the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider set to the range 0 to 1 is used to control the parameter input for a PlaneAtParameter node."
    },
    {
        "Name": "PlaneAtSegmentLength",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "PlaneAtSegmentLength"
        ],
        "imageFile": [
            "PlaneAtSegmentLength"
        ],
        "inDepth": "Plane At Segment Length will return a plane aligned with a curve at a point that is a specified distance along the curve, measured from the start point. If the input length is greater than the total length of the curve, this node will use the end point of the curve. The normal vector of the resulting plane will correspond to the tangent of the curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. A number slider is used to control the parameter input for a PlaneAtSegmentLength node."
    },
    {
        "Name": "SplitByPoints",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "SplitByPoints"
        ],
        "imageFile": [
            "SplitByPoints"
        ],
        "inDepth": "Split By Points will split an input curve at specified points, and will return a list of resulting segments. If the specified points are not on the curve, this node will find the points along the curve that are closest to the input points and split the curve at those resulting points. In the example below, we first create a Nurbs Curve using a ByPoints node, with a set of randomly generated points as the input. The same set of points is used as the list of points in a SplitByPoints node. The result is a list of curve segments between the generated points."
    },
    {
        "Name": "ByBlendBetweenCurves",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Create",
        "dynFile": [
            "ByBlendBetweenCurves"
        ],
        "imageFile": [
            "ByBlendBetweenCurves"
        ],
        "inDepth": "Curve by Blend Between Curves will create a new curve that connects two input curves. The two 'endOrStart' inputs determine whether to connect the end or start points of each curve. The created curve will match the curvature of the original curves at the connection points. In the example below, we start with one arc and one line. We blend between the start of the arch and the end of the line to connect the two curves. Two boolean toggle nodes let us control which ends of the two curves to blend between."
    },
    {
        "Name": "ByIsoCurveOnSurface",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Create",
        "dynFile": [
            "ByIsoCurveOnSurface"
        ],
        "imageFile": [
            "ByIsoCurveOnSurface"
        ],
        "inDepth": "Curve by IsoCurve on Surface will create a curve that is the isocurve on a surface by specifying the U or V direction, and specifying the parameter in the opposite direction at which to create the curve. The 'direction' input determines which direction of isocurve to create. A value of one corresponds to the u-direction, while a value of zero corresponds to the v-direction. In the example below, we first create grid of points, and translate them in the Z-direction by a random amount. These points are used to create surface by using a NurbsSurface.ByPoints node. This surface is used as the baseSurface of a ByIsoCurveOnSurface node. A number slider set to a range of 0 to 1 and a step of 1 is used to control whether we extract the isocurve in the u or in the v direction. A second number slider is used to determine the parameter at which the isocurve is extracted."
    },
    {
        "Name": "ByParameterLineOnSurface",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Create",
        "dynFile": [
            "ByParameterLineOnSurface"
        ],
        "imageFile": [
            "ByParameterLineOnSurface"
        ],
        "inDepth": "Curve by Parameter Line On Surface will create a line along a surface between two input UV coordinates. n the example below, we first create grid of points, and translate them in the Z-direction by a random amount. These points are used to create surface by using a NurbsSurface.ByPoints node. This surface is used as the baseSurface of a ByParameterLineOnSurface node. A set of number sliders are used to adjust the U and V inputs of two UV.ByCoordinates nodes, which are then used to determing the start and end point of the line on the surface."
    },
    {
        "Name": "EndPoint",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Query",
        "dynFile": [
            "EndPoint"
        ],
        "imageFile": [
            "EndPoint"
        ],
        "inDepth": "End Point will return the end point of an input curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. We can find the end point of this curve by using an EndPoint node."
    },
    {
        "Name": "IsClosed",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Query",
        "dynFile": [
            "IsClosed"
        ],
        "imageFile": [
            "IsClosed"
        ],
        "inDepth": "Is Closed will return a boolean value that corresponds to whether the input curve is closed or not. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. We can then test whether this curve is closed by using a IsClosed node. "
    },
    {
        "Name": "IsPlanar",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Query",
        "dynFile": [
            "IsPlanar"
        ],
        "imageFile": [
            "IsPlanar"
        ],
        "inDepth": "Is Planar will return a boolean value that corresponds to whether the input curve is planar or not. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. We can then test whether this curve is planar by using a IsPlanar node."
    },
    {
        "Name": "Length",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Query",
        "dynFile": [
            "Length"
        ],
        "imageFile": [
            "Length"
        ],
        "inDepth": "Length will return the length of an input curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. We can find the length of this curve by using an Length node."
    },
    {
        "Name": "Normal",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Query",
        "dynFile": [
            "Normal"
        ],
        "imageFile": [
            "Normal"
        ],
        "inDepth": "Normal will return the normal vector of an input curve. The curve must be planar for this node. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. We can find the normal of this curve by using a Normal node."
    },
    {
        "Name": "StartPoint",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Query",
        "dynFile": [
            "StartPoint"
        ],
        "imageFile": [
            "StartPoint"
        ],
        "inDepth": "Start Point will return the start point of an input curve. In the example below, we first create a Nurbs Curve using a ByControlPoints node, with a set of randomly generated points as the input. We can find the start point of this curve by using a StartPoint node."
    },
    {
        "Name": "Join (curve, curve)",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "Join_curve"
        ],
        "imageFile": [
            "Join_curve"
        ],
        "inDepth": "Join will take two curves as input and return a PolyCurve that results from joining the two curves together.  In the example below, we start with one arc and one line. We blend between the start of the arch and the end of the line to connect the two curves. The Arc and the resulting blended curve are then joined into a PolyCurve using a Join node."
    },
    {
        "Name": "Join (curve, curves)",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "folderPath": "Geometry/Curve/Action",
        "dynFile": [
            "Join_curves"
        ],
        "imageFile": [
            "Join_curves"
        ],
        "inDepth": "Join will take one input curve and one list of input curves, and will return a PolyCurve that results from joining the curves together.  In the example below, we start with one arc and one line. We blend between the start of the arch and the end of the line to connect the two curves. The arc and line are put into a single list by using a List.Create node. This list is then used as the input along with the blended curve in a Join node to create a single PolyCurve out of the three curves."
    },
    {
        "Name": "Brightness",
        "categories": [
            "Core",
            "Color"
        ],
        "folderPath": "Core/Color/Action",
        "dynFile": [
            "Brightness"
        ],
        "imageFile": [
            "Brightness"
        ],
        "inDepth": "Brightness will return the brightness value of an input color in the range 0 to 1. In the example below, we create two colors using ByARGB nodes, and then add the two colors together. The brightness value of the resulting color is found by using a Brightness node."
    },
    {
        "Name": "Components",
        "categories": [
            "Core",
            "Color"
        ],
        "folderPath": "Core/Color/Action",
        "dynFile": [
            "Components"
        ],
        "imageFile": [
            "Components"
        ],
        "inDepth": "Components will return the Alpha, Red, Blue, and Green values of an input color in the range 0 to 255. In the example below, we create two colors using ByARGB nodes, and then add the two colors together. The resulting individual color components can then be extracted using a Components node."
    },
    {
        "Name": "Hue",
        "categories": [
            "Core",
            "Color"
        ],
        "folderPath": "Core/Color/Action",
        "dynFile": [
            "Hue"
        ],
        "imageFile": [
            "Hue"
        ],
        "inDepth": "Hue will return the hue value of an input color. In the example below, we create two colors using ByARGB nodes, and then add the two colors together. The hue value of the resulting color is found by using a Hue node."
    },
    {
        "Name": "Saturation",
        "categories": [
            "Core",
            "Color"
        ],
        "folderPath": "Core/Color/Action",
        "dynFile": [
            "Saturation"
        ],
        "imageFile": [
            "Saturation"
        ],
        "inDepth": "Saturation will return the saturation value of an input color in the range 0 to 1. In the example below, we create two colors using ByARGB nodes, and then add the two colors together. The saturation value of the resulting color is found by using a Saturation node."
    },
    {
        "Name": "Add",
        "categories": [
            "Core",
            "Color"
        ],
        "folderPath": "Core/Color/Create",
        "dynFile": [
            "Add"
        ],
        "imageFile": [
            "Add"
        ],
        "inDepth": "Add will add the individual channels of two colors together, and return the resulting color. Note that the resulting values must be less than 255. In the example below, we create two colors using ByARGB nodes. We then use an Add node to add the two colors together. A Display.ByGeometryColor node is used with a default cuboid in order to visualize the resulting color."
    },
    {
        "Name": "ByARGB",
        "categories": [
            "Core",
            "Color"
        ],
        "folderPath": "Core/Color/Create",
        "dynFile": [
            "ByARGB"
        ],
        "imageFile": [
            "ByARGB"
        ],
        "inDepth": "ByARGB will create a color using input Alpha, Red, Green, and Blue values. The input values are in the range 0 to 255. In the example below, we use 4 number sliders set to the range 0 to 255 to control the input values of a ByARGB node. A Display.ByGeometryColor node is used with a default cuboid in order to visualize the resulting color."
    },
    {
        "Name": "Color Range",
        "categories": [
            "Core",
            "Color"
        ],
        "folderPath": "Core/Color/Create",
        "dynFile": [
            "Color_Range"
        ],
        "imageFile": [
            "Color_Range"
        ],
        "inDepth": "Color Range will create a gradient between a set of input colors, and allow colors from that gradient to be selected by a list of input values. The first input, colors, is a list of colors to use in the gradient. The second inut, indices, will determine the relative location of the input colors in the gradient. This list should correspond to the list of colors, each value being in the range 0 to 1. The exact value is not important, only the relative position of the values. The color corresponding to the lowest value will be on the left of the gradient, and the color corresponding to the highest value will be on the right side of the gradient. The final values input allows the user to select points along the gradient in the range 0 to 1 to output. In the example below, we first create two colors: red and green. The order of these colors in the gradient is determined by a list that we create with a code block. A third code block is used to create a range of numbers between 0 and 1 that will determine the output colors from the gradient. A set of cubes is generated along the x-axis, and these cubes are finally colored according the gradient by using a Display.ByGeometryColor node."
    },
    {
        "Name": "Divide",
        "categories": [
            "Core",
            "Color"
        ],
        "folderPath": "Core/Color/Create",
        "dynFile": [
            "Divide"
        ],
        "imageFile": [
            "Divide"
        ],
        "inDepth": "Divide will divide the individual channels a color by in input number, and return the resulting color. Note that the resulting values must be less than 255. In the example below, we create a color using ByARGB nodes. We then use a Divide node to divide the color by a number controlled with a number slider. A Display.ByGeometryColor node is used with a default cuboid in order to visualize the resulting color."
    },
    {
        "Name": "Multiply",
        "categories": [
            "Core",
            "Color"
        ],
        "folderPath": "Core/Color/Create",
        "dynFile": [
            "Multiply"
        ],
        "imageFile": [
            "Multiply"
        ],
        "inDepth": "Multiply will multiply the individual channels a color by in input number, and return the resulting color. Note that the resulting values must be less than 255. In the example below, we create a color using ByARGB nodes. We then use a Multiply node to multiply the color by a number controlled with a number slider. A Display.ByGeometryColor node is used with a default cuboid in order to visualize the resulting color."
    },
    {
        "Name": "Alpha",
        "categories": [
            "Core",
            "Color"
        ],
        "folderPath": "Core/Color/Query",
        "dynFile": [
            "Alpha"
        ],
        "imageFile": [
            "Alpha"
        ],
        "inDepth": "Alpha will return the alpha value of an input color in the range 0 to 255. In the example below, we create two colors using ByARGB nodes, and then add the two colors together. The alpha value of the resulting color is found by using an Alpha node."
    },
    {
        "Name": "Blue",
        "categories": [
            "Core",
            "Color"
        ],
        "folderPath": "Core/Color/Query",
        "dynFile": [
            "Blue"
        ],
        "imageFile": [
            "Blue"
        ],
        "inDepth": "Blue will return the blue value of an input color in the range 0 to 255. In the example below, we create two colors using ByARGB nodes, and then add the two colors together. The blue value of the resulting color is found by using a Blue node."
    },
    {
        "Name": "Green",
        "categories": [
            "Core",
            "Color"
        ],
        "folderPath": "Core/Color/Query",
        "dynFile": [
            "Green"
        ],
        "imageFile": [
            "Green"
        ],
        "inDepth": "Green will return the green value of an input color in the range 0 to 255. In the example below, we create two colors using ByARGB nodes, and then add the two colors together. The green value of the resulting color is found by using a Green node."
    },
    {
        "Name": "Red",
        "categories": [
            "Core",
            "Color"
        ],
        "folderPath": "Core/Color/Query",
        "dynFile": [
            "Red"
        ],
        "imageFile": [
            "Red"
        ],
        "inDepth": "Red will return the red value of an input color in the range 0 to 255. In the example below, we create two colors using ByARGB nodes, and then add the two colors together. The red value of the resulting color is found by using a Red node."
    },
    {
        "Name": "GetColorAtParameter",
        "categories": [
            "Core",
            "ColorRange2D"
        ],
        "folderPath": "Core/ColorRange2D/Action",
        "dynFile": [
            "GetColorAtParameter"
        ],
        "imageFile": [
            "GetColorAtParameter"
        ],
        "inDepth": "GetColorAtParameter takes an input 2D color range, and returns a list of colors at specified UV parameters in the range 0 to 1. In the example below, we first create a 2D Color Range using a ByColorsAndParameters node with a list of colors and list of parameters to set the range. A code block is used to generate a range of numbers between 0 and 1, which is used as the u and v inputs in a UV.ByCoordinates node. The lacing of this node is set to cross product. A set of cubes is created in a similar manner, which a Point.ByCoordinates node with cross product lacing used to created an array of cubes. We then use a Display.ByGeometryColor node with the array of cubes and the list of colors obtained from the GetColorAtParameter node."
    },
    {
        "Name": "ByColorsAndParameters",
        "categories": [
            "Core",
            "ColorRange2D"
        ],
        "folderPath": "Core/ColorRange2D/Create",
        "dynFile": [
            "ByColorsAndParameters"
        ],
        "imageFile": [
            "ByColorsAndParameters"
        ],
        "inDepth": "ByColorsAndParameters creates an  2D color range from a list of input colors and a corresponding list of specified UV parameters in the range 0 to 1. In the example below, we use a code block to create three different colors (in this case simply green, red, and blue) and to combine them into a list. We use a separate code block to create three UV parameters, one for each color. These two lists are used as inputs to a ByColorsAndParameters node. We use a subsequent GetColorAtParameter node, along with a Display.ByGeometryColor node to visualize the 2D color range across a set of cubes."
    },
    {
        "Name": "Boolean",
        "categories": [
            "Core",
            "Input"
        ],
        "folderPath": "Core/Input/Create",
        "dynFile": [
            "Boolean"
        ],
        "imageFile": [
            "Boolean"
        ],
        "inDepth": "The Boolean node allows the user to toggle between two boolean values 'true' or 'false' by selecting the appropriate radio button. "
    },
    {
        "Name": "Date Time",
        "categories": [
            "Core",
            "Input"
        ],
        "folderPath": "Core/Input/Create",
        "dynFile": [
            "DateTime"
        ],
        "imageFile": [
            "DateTime"
        ],
        "inDepth": "DateTime will create a datetime object with the specified input month, day, year, and time. The format must be in the form: 'January 01, 1900 12:00 AM' The month must be capitalized and written out in full. The day must be two digits, the year must be four digits."
    },
    {
        "Name": "Directory Path",
        "categories": [
            "Core",
            "Input"
        ],
        "folderPath": "Core/Input/Create",
        "dynFile": [
            "DirectoryPath"
        ],
        "imageFile": [
            "DirectoryPath"
        ],
        "inDepth": "Directory Path allows the user to select a directory from their computer. To set the directory path, click the 'Browse...' button on the Directory Path node, then navigate to the desired directory. If this node is added to a previously saved .dyn file, this node will default to the directory of the .dyn file."
    },
    {
        "Name": "File Path",
        "categories": [
            "Core",
            "Input"
        ],
        "folderPath": "Core/Input/Create",
        "dynFile": [
            "FilePath"
        ],
        "imageFile": [
            "FilePath"
        ],
        "inDepth": "File Path allows the user to select a file from their computer. To set the file path, click the 'Browse...' button on the File Path node, then navigate to the desired file."
    },
    {
        "Name": "Number",
        "categories": [
            "Core",
            "Input"
        ],
        "folderPath": "Core/Input/Create",
        "dynFile": [
            "Number"
        ],
        "imageFile": [
            "Number"
        ],
        "inDepth": "The Number node allows a user to enter a static number. This node is useful for things like constants that don't change values. Numbers can also be created by using a Code Block node. In the example below, the number is paired with a code block to create a list sequence with a variable step size."
    },
    {
        "Name": "String",
        "categories": [
            "Core",
            "Input"
        ],
        "folderPath": "Core/Input/Create",
        "dynFile": [
            "String"
        ],
        "imageFile": [
            "String"
        ],
        "inDepth": "The String node allows a user to enter a string value. A string can also be created with a Code Block by surrounding the string in quotes. In the example below, we use a String node and a Code Block to create the strings 'Hello' and 'World'. A String.Join node is used to combine the two strings together. A second String node is used with a blank space to act as the separator, resulting in the output string 'Hello World'."
    },
    {
        "Name": "Abs (number)",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Abs"
        ],
        "imageFile": [
            "Abs"
        ],
        "inDepth": "Abs will return the absolute value of an input value. In the example below, we use a number slider to control the input to an Abs node."
    },
    {
        "Name": "Abs (integer)",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Abs"
        ],
        "imageFile": [
            "Abs"
        ],
        "inDepth": "Abs will return the absolute value of an input value. In the example below, we use an integer slider to control the input to an Abs node."
    },
    {
        "Name": "Acos",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Acos"
        ],
        "imageFile": [
            "Acos"
        ],
        "inDepth": "Acos will return the inverse cosine, also known as the ArcCosine, of an input number between -1 and 1. This output angle is returned in degrees. In the example below we use a number slider set to the range -1 to 1 to control the input to an Acos node."
    },
    {
        "Name": "Asin",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Asin"
        ],
        "imageFile": [
            "Asin"
        ],
        "inDepth": "Asin will return the inverse sine, also known as the ArcSine, of an input number between -1 and 1. This output angle is returned in degrees. In the example below we use a number slider set to the range -1 to 1 to control the input to an Asin node."
    },
    {
        "Name": "Atan",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Atan"
        ],
        "imageFile": [
            "Atan"
        ],
        "inDepth": "Atan will return the inverse sine, also known as the ArcTangent, of an input number. This output angle is returned in degrees. In the example below we use a number slider to control the input to an Atan node."
    },
    {
        "Name": "Atan2",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Atan2"
        ],
        "imageFile": [
            "Atan2"
        ],
        "inDepth": "Atan2 will return the inverse sine, also known as the ArcTangen, of the ratio of an input numerator and denomnator. This output angle is returned in degrees. In the example below we use two number sliders to control the inputs to an Atan2 node."
    },
    {
        "Name": "Average",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Average"
        ],
        "imageFile": [
            "Average"
        ],
        "inDepth": "Average will return the average (arithmetic mean) of a list of numbers. In the example below, we first use three number sliders to create three numbers to find the average of. We then use a List.Create node combine these three numbers into a list that we can then use as the input for an Average node."
    },
    {
        "Name": "Ceiling",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Ceiling"
        ],
        "imageFile": [
            "Ceiling"
        ],
        "inDepth": "Ceiling will find the nearest integer that greater than an input number. This can also be thought of as rounding up to the nearest integer. In the example below, we use a number slider to control the input to a Ceiling node."
    },
    {
        "Name": "Cos",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Cos"
        ],
        "imageFile": [
            "Cos"
        ],
        "inDepth": "Cos will return the cosine of an input angle in degrees. In the example below, we use a number slider set to the range -360 to 360 to control the input angle to a Cos node."
    },
    {
        "Name": "Cosh",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Cosh"
        ],
        "imageFile": [
            "Cosh"
        ],
        "inDepth": "Cosh will return the hyperbolic cosine of an input angle in radians. In the example below, we use a number slider set to the range -6.28 to 6.28 to control the input angle to a Cosh node."
    },
    {
        "Name": "DegreesToRadians",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "DegreesToRadians"
        ],
        "imageFile": [
            "DegreesToRadians"
        ],
        "inDepth": "DegreesToRadians will convert an input angle from degrees to radians. In the example below, we use a number slider set to the range -360 to 360 to control the input angle to a DegreesToRadians node."
    },
    {
        "Name": "DivRem",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "DivRem"
        ],
        "imageFile": [
            "DivRem"
        ],
        "inDepth": "DivRem will return the remainder of an input number after dividing by a given divisor. This is also known as Modulus, and is equivalent to the operator '%'. In the example below, we use two number sliders to set the dividend and divisor for a DivRem node."
    },
    {
        "Name": "Exp",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Exp"
        ],
        "imageFile": [
            "Exp"
        ],
        "inDepth": "Exp is the exponential function with a base of 'e'. The input number is applied as an exponent to the constant 'e'. In the example below we use a number slider to control the input number to an Exp node. "
    },
    {
        "Name": "Factorial",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Factorial"
        ],
        "imageFile": [
            "Factorial"
        ],
        "inDepth": "Factorial will return the factorial of an input positive integer. If a decimal value is input, factorial will first round the input to the nearest integer. In the example below we use a number slider to control the input to a Factorial node."
    },
    {
        "Name": "Floor",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Floor"
        ],
        "imageFile": [
            "Floor"
        ],
        "inDepth": "Floor will find the nearest integer that less than an input number. This can also be thought of as rounding down to the nearest integer. In the example below, we use a number slider to control the input to a Floo node."
    },
    {
        "Name": "Log (number)",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Log"
        ],
        "imageFile": [
            "Log"
        ],
        "inDepth": "Log will return the natural log (base e) of an input number. In the example below, we use a number slider to control the input to a Log node."
    },
    {
        "Name": "Log (number, logBase)",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Log_base"
        ],
        "imageFile": [
            "Log_base"
        ],
        "inDepth": "Log with logBase allows the use to specify the base to use for a logarithm with the logBase input. In the example below, we use two number sliders, one to control the input number to find the logarithm of and a second number slider to set the base of the logarithm."
    },
    {
        "Name": "Log10",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Log10"
        ],
        "imageFile": [
            "Log10"
        ],
        "inDepth": "Log10 will return the log base 10 of an input number. In the example below, we use a number slider to control the input to a Log10 node."
    },
    {
        "Name": "Max (int1, int2)",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Max_int"
        ],
        "imageFile": [
            "Max_int"
        ],
        "inDepth": "Max will return the greater of two input integers. In the example below, we use two integer sliders to control the inputs to a Max node."
    },
    {
        "Name": "Max (value1, value2)",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Max"
        ],
        "imageFile": [
            "Max"
        ],
        "inDepth": "Max will return the greater of two input number. In the example below, we use two number sliders to control the inputs to a Max node."
    },
    {
        "Name": "Min (int1, int2)",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Min_int"
        ],
        "imageFile": [
            "Min_int"
        ],
        "inDepth": "Min will return the lesser of two input integers. In the example below, we use two integer sliders to control the inputs to a Min node."
    },
    {
        "Name": "Min (value1, value2)",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Min"
        ],
        "imageFile": [
            "Min"
        ],
        "inDepth": "Min will return the lesser of two input number. In the example below, we use two number sliders to control the inputs to a Min node."
    },
    {
        "Name": "Pow",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Pow"
        ],
        "imageFile": [
            "Pow"
        ],
        "inDepth": "Pow will return the result of an input number raised to an input power. In the example below, we use two number sliders to control the two inputs to a Pow node."
    },
    {
        "Name": "RadiansToDegrees",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "RadiansToDegrees"
        ],
        "imageFile": [
            "RadiansToDegrees"
        ],
        "inDepth": "RadiansToDegrees will convert an input angle from radians to degrees. In the example below, we use a number slider to control the input angle to a RadiansToDegrees node."
    },
    {
        "Name": "Rand",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Rand"
        ],
        "imageFile": [
            "Rand"
        ],
        "inDepth": "Rand will generate a random number in the range 0 to 1. Each instance of Rand will produce a different random number, but the number for a specific instance will remain constant."
    },
    {
        "Name": "Random (seed)",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Random"
        ],
        "imageFile": [
            "Random"
        ],
        "inDepth": "Random with a given seed allows the user to input a seed number to produce a pseudo-random number. Every Rand node with the same seed number will produce the same pseudo-random number. In the example below, we use an integer slider as the input seed into a Rand node."
    },
    {
        "Name": "Random (value1, value2)",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Random_range"
        ],
        "imageFile": [
            "Random_range"
        ],
        "inDepth": "Random with two value inputs allows the user to control the range of the generated random number. It will produce a random number between the two input values. In the example below, we use two number sliders to control the two inputs into a Random node."
    },
    {
        "Name": "RandomList",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "RandomList"
        ],
        "imageFile": [
            "RandomList"
        ],
        "inDepth": "RandomList will generate a list of random numbers in the range 0 to 1. The amount of random to generate is controlled by a number slider."
    },
    {
        "Name": "RemapRange",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "RemapRange"
        ],
        "imageFile": [
            "RemapRange"
        ],
        "inDepth": "RemapRange will take a list of numbers and produce a linear scaling of those numbers into a new specified range. The minimum value of the original list is mapped to the newMin input, while the maximum value of the orginila list is mapped to the newMax input. The remaining numbers are scaled to maintain the distribution ratio. In the example below, we use a RandomList node to generate a list of numbers to remap. We use two number sliders to control the new minimum and maximum values of the resulting list."
    },
    {
        "Name": "Round (number)",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Round"
        ],
        "imageFile": [
            "Round"
        ],
        "inDepth": "Round will round the input number to the nearest integer. In the example below, we use a number slider to control the input to a Round node."
    },
    {
        "Name": "Round (number, digits)",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Round_digits"
        ],
        "imageFile": [
            "Round_digits"
        ],
        "inDepth": "Round with digits allows the user to select the number of decimal places to round the input number to. An input of zero will round to the nearest whole number. Values less than zero are not permitted. In the example below, we use a Rand node to generate a random number. An integer slider is used to control the 'digits' input in a Round node."
    },
    {
        "Name": "Sign (integer)",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Sign"
        ],
        "imageFile": [
            "Sign"
        ],
        "inDepth": "Sign will return 1, 0, or -1 depending on whether the input number is greater than, equal to, or less than zero. In the example below, we use a number slider to control the input to a Sign node."
    },
    {
        "Name": "Sign (number)",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Sign"
        ],
        "imageFile": [
            "Sign"
        ],
        "inDepth": "Sign will return 1, 0, or -1 depending on whether the input number is greater than, equal to, or less than zero. In the example below, we use a number slider to control the input to a Sign node."
    },
    {
        "Name": "Sin",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Sin"
        ],
        "imageFile": [
            "Sin"
        ],
        "inDepth": "Sin will return the sine of an input angle in degrees. In the example below, we use a number slider set to the range -360 to 360 to control the input angle to a Sin node."
    },
    {
        "Name": "Sinh",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Sinh"
        ],
        "imageFile": [
            "Sinh"
        ],
        "inDepth": "Sinh will return the hyperbolic sine of an input angle in radians. In the example below, we use a number slider set to the range -6.28 to 6.28 to control the input angle to a Sinh node."
    },
    {
        "Name": "Sqrt",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Sqrt"
        ],
        "imageFile": [
            "Sqrt"
        ],
        "inDepth": "Sqrt will return the square root of an input number. Sqrt will only accept positive numbers. In the example below we use a number slider to control the input to a Sqrt node."
    },
    {
        "Name": "Sum",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Sum"
        ],
        "imageFile": [
            "Sum"
        ],
        "inDepth": "Sum will find the sum of the values of an input list. In the example below, we use three number sliders to create three numbers. We then use a List.Create node to combine them into a list that can be used as the input to a Sum node."
    },
    {
        "Name": "Tan",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Tan"
        ],
        "imageFile": [
            "Tan"
        ],
        "inDepth": "Tan will return the tangent of an input angle in degrees. In the example below, we use a number slider set to the range -360 to 360 to control the input angle to a Tan node."
    },
    {
        "Name": "Tanh",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Create",
        "dynFile": [
            "Tanh"
        ],
        "imageFile": [
            "Tanh"
        ],
        "inDepth": "Tanh will return the hyperbolic tangent of an input angle in radians. In the example below, we use a number slider set to the range -6.28 to 6.28 to control the input angle to a Tanh node."
    },
    {
        "Name": "E",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Query",
        "dynFile": [
            "E"
        ],
        "imageFile": [
            "E"
        ],
        "inDepth": "E will return the constant e = 2.71828..."
    },
    {
        "Name": "GoldenRatio",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Query",
        "dynFile": [
            "GoldenRatio"
        ],
        "imageFile": [
            "GoldenRatio"
        ],
        "inDepth": "GoldenRatio will return the golden ratio constant, also known as 'phi', equal to 1.61803... "
    },
    {
        "Name": "PI",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Query",
        "dynFile": [
            "Pi"
        ],
        "imageFile": [
            "Pi"
        ],
        "inDepth": "Pi will return the constant pi = 3.14159265..."
    },
    {
        "Name": "PiTimes2",
        "categories": [
            "Core",
            "Math"
        ],
        "folderPath": "Core/Math/Query",
        "dynFile": [
            "PiTimes2"
        ],
        "imageFile": [
            "PiTimes2"
        ],
        "inDepth": "PiTimes2 will return the constant pi multiplied by 2 = 6.28318..."
    },
    {
        "Name": "!=",
        "categories": [
            "Operators"
        ],
        "folderPath": "Operators",
        "dynFile": [
            "NotEqualTo"
        ],
        "imageFile": [
            "NotEqualTo"
        ],
        "inDepth": "!= is the Not Equal To operator. It takes two input values and returns true if the two values are not equal to each other and returns false if the two values are equal. In the example below, we use two number sliders to control the inputs to a != operator."
    },
    {
        "Name": "%",
        "categories": [
            "Operators"
        ],
        "folderPath": "Operators",
        "dynFile": [
            "Modulo"
        ],
        "imageFile": [
            "Modulo"
        ],
        "inDepth": "% is the Modulo operator. It returns the remainder of the x input after being divided by the y input. In the example below, we use two number sliders to control the inputs to a % operator."
    },
    {
        "Name": "&&",
        "categories": [
            "Operators"
        ],
        "folderPath": "Operators",
        "dynFile": [
            "And"
        ],
        "imageFile": [
            "And"
        ],
        "inDepth": "&& is the And operator. It takes two boolean values as input and returns true if both values are true. If one or both values are false, it will return false. In the example below, we use two boolean toggle nodes to control the inputs to the && operator."
    },
    {
        "Name": "*",
        "categories": [
            "Operators"
        ],
        "folderPath": "Operators",
        "dynFile": [
            "Multiply"
        ],
        "imageFile": [
            "Multiply"
        ],
        "inDepth": "* is the multiplication operator. It will return the product of the two input numbers. In the example below, we use two number sliders to control the inputs to the * operator."
    },
    {
        "Name": "+",
        "categories": [
            "Operators"
        ],
        "folderPath": "Operators",
        "dynFile": [
            "Add"
        ],
        "imageFile": [
            "Add"
        ],
        "inDepth": "+ is the addition operator. It will return the sum ofy the two input numbers. In the example below, we use two number sliders to control the inputs to the + operator."
    },
    {
        "Name": "-",
        "categories": [
            "Operators"
        ],
        "folderPath": "Operators",
        "dynFile": [
            "Subtract"
        ],
        "imageFile": [
            "Subtract"
        ],
        "inDepth": "- is the subtraction operator. It will return the result of the y input subtracted from the x input. In the example below, we use two number sliders to control the inputs to the - operator."
    },
    {
        "Name": "/",
        "categories": [
            "Operators"
        ],
        "folderPath": "Operators",
        "dynFile": [
            "Divide"
        ],
        "imageFile": [
            "Divide"
        ],
        "inDepth": "/ is the division operator. It will return the result of the x input divided by the y input. In the example below, we use two number sliders to control the inputs to the / operator."
    },
    {
        "Name": "<",
        "categories": [
            "Operators"
        ],
        "folderPath": "Operators",
        "dynFile": [
            "LessThan"
        ],
        "imageFile": [
            "LessThan"
        ],
        "inDepth": "< is the Less Than operator. If the x input is less than the y input, it will return true. If x is greater than y, or if the two value are equal, this operator will return false. In the example below, we use two number sliders to control the inputs to the < operator."
    },
    {
        "Name": "<=",
        "categories": [
            "Operators"
        ],
        "folderPath": "Operators",
        "dynFile": [
            "LessThanOrEqualTo"
        ],
        "imageFile": [
            "LessThanOrEqualTo"
        ],
        "inDepth": "<= is the Less Than Or Equal To operator. If the x input is less than the y input, or if the two values are equal, it will return true. If x is greater than y, this operator will return false. In the example below, we use two number sliders to control the inputs to the <= operator."
    },
    {
        "Name": "==",
        "categories": [
            "Operators"
        ],
        "folderPath": "Operators",
        "dynFile": [
            "EqualTo"
        ],
        "imageFile": [
            "EqualTo"
        ],
        "inDepth": "== is the Equal To operator. If the x input is equal to the y input, it will return true. If the two values are not equal, this operator will return false. In the example below, we use two number sliders to control the inputs to the == operator."
    },
    {
        "Name": ">",
        "categories": [
            "Operators"
        ],
        "folderPath": "Operators",
        "dynFile": [
            "GreaterThan"
        ],
        "imageFile": [
            "GreaterThan"
        ],
        "inDepth": "> is the Greater Than operator. If the x input is greater than the y input, it will return true. If x is less than y, or if the two value are equal, this operator will return false. In the example below, we use two number sliders to control the inputs to the > operator."
    },
    {
        "Name": ">=",
        "categories": [
            "Operators"
        ],
        "folderPath": "Operators",
        "dynFile": [
            "GreaterThanOrEqualTo"
        ],
        "imageFile": [
            "GreaterThanOrEqualTo"
        ],
        "inDepth": ">= is the Greater Than Or Equal To operator. If the x input is greater than the y input, or if the two values are equal, it will return true. If x is less than y, this operator will return false. In the example below, we use two number sliders to control the inputs to the >= operator."
    },
    {
        "Name": "Not",
        "categories": [
            "Operators"
        ],
        "folderPath": "Operators",
        "dynFile": [
            "Not"
        ],
        "imageFile": [
            "Not"
        ],
        "inDepth": "Not (also written as exclamation point) will return the opposite of an input boolean value. In the example below, we use a boolean toggle node as the input to a Not operator.",
        "index": 411
    },
    {
        "Name": "||",
        "categories": [
            "Operators"
        ],
        "folderPath": "Operators",
        "dynFile": [
            "Or"
        ],
        "imageFile": [
            "Or"
        ],
        "inDepth": "|| is the Or operator. It takes two boolean values as input and returns true if one or both values are true. If both values are false, it will return false. In the example below, we use two boolean toggle nodes to control the inputs to the || operator."
    },
    {
        "Name": "Center",
        "categories": [
            "Core",
            "String"
        ],
        "folderPath": "Core/String/Create",
        "dynFile": [
            "Center"
        ],
        "imageFile": [
            "Center"
        ],
        "inDepth": "Center will increase the width of an input string according to the newWidth input by adding the padChars input on both sides of the original string. If the original string is longer than the newWidth input, this node will return the original string unchanged. In the example below, we use the string 'Hello World' as the input string. A string with an underscore character is used as the padding character, while an integer slider is used to control the new width of the centered string."
    },
    {
        "Name": "ChangeCase",
        "categories": [
            "Core",
            "String"
        ],
        "folderPath": "Core/String/Create",
        "dynFile": [
            "ChangeCase"
        ],
        "imageFile": [
            "ChangeCase"
        ],
        "inDepth": "Change Case takes a string and a boolean value as input. If the boolean input is 'true', it will change the input string to upper case. If the boolean input is false, it will change the input string to lower case. In the example below, we use an example string 'Hello World' as the input string, and a boolean toggle to specify whether to change the string to all upper case or all lower case letters."
    },
    {
        "Name": "Concat",
        "categories": [
            "Core",
            "String"
        ],
        "folderPath": "Core/String/Create",
        "dynFile": [
            "Concat"
        ],
        "imageFile": [
            "Concat"
        ],
        "inDepth": "Concat will concatenate multiple strings together into a single string. The number of input strings can be changed by using the '+' and '-' buttons on the Concat node. In the example below, we start with two separate strings 'Hello' and 'World'. They are concatenated together to 'HelloWorld' using the Concat node."
    },
    {
        "Name": "Contains",
        "categories": [
            "Core",
            "String"
        ],
        "folderPath": "Core/String/Create",
        "dynFile": [
            "Contains"
        ],
        "imageFile": [
            "Contains"
        ],
        "inDepth": "Contains will search one given string for a second input string. If the first string contains the second, it will return true. If not, it will return false. By default, this node is case sensitive. A boolean value can be used to ignore the case of the strings when searching. In the example below we use the string 'Hello World' and search for the string 'E'. By using a boolean toggle set to true for the ignoreCase input, the Contains node returns true."
    },
    {
        "Name": "CountOccurrences",
        "categories": [
            "Core",
            "String"
        ],
        "folderPath": "Core/String/Create",
        "dynFile": [
            "CountOccurrences"
        ],
        "imageFile": [
            "CountOccurrences"
        ],
        "inDepth": "Count Occurrences will search a given string for a second input string, and will return the number of times that second string is found within the first string. By default this node is case sensitive. A boolean value can be used in the 'ignoreCase' input to make the node ignore the case of the strings. In the example below, we using the string 'Hello World' and search for the string 'L'. Because ignoreCase is set to true, the CountOccurrences finds the given string three times within 'Hello World'."
    },
    {
        "Name": "EndsWith",
        "categories": [
            "Core",
            "String"
        ],
        "folderPath": "Core/String/Create",
        "dynFile": [
            "EndsWith"
        ],
        "imageFile": [
            "EndsWith"
        ],
        "inDepth": "Ends With will return a boolean value based on whether a given string ends with a second input string. By default this node is case sensitive. A boolean value can be used in the 'ignoreCase' input to make the node ignore the case of the strings. In the example below, we use the string 'Hello World' as the original string, and use a second string 'orld' as the string to search for. Because 'Hello World' ends in the string 'orld', the EndsWith node returns true."
    },
    {
        "Name": "IndexOf",
        "categories": [
            "Core",
            "String"
        ],
        "folderPath": "Core/String/Create",
        "dynFile": [
            "IndexOf"
        ],
        "imageFile": [
            "IndexOf"
        ],
        "inDepth": "IndexOf will search a given string for a second input string. If the second string is found, this node will return the index of the first character of the first occurrence of the string.  By default this node is case sensitive. A boolean value can be used in the 'ignoreCase' input to make the node ignore the case of the strings. In the example below, we use the string 'Hello World', and search for the character 'o', This letter occurs twice in the string, but only the index of the first occurrence is returned by the IndexOf node."
    },
    {
        "Name": "Insert",
        "categories": [
            "Core",
            "String"
        ],
        "folderPath": "Core/String/Create",
        "dynFile": [
            "Insert"
        ],
        "imageFile": [
            "Insert"
        ],
        "inDepth": "Insert will insert a given string into a base string at a specified index. In the example below, we start with the base string 'Hello World'. We use a second string 'Hi!' as the string to insert. An integery slider is used to control the index at which the second string will be inserted into the base string."
    },
    {
        "Name": "Join",
        "categories": [
            "Core",
            "String"
        ],
        "folderPath": "Core/String/Create",
        "dynFile": [
            "Join"
        ],
        "imageFile": [
            "Join"
        ],
        "inDepth": "Join will concatenate a series of strings together into a single string using a specified separator string between them. In the example below, we use an underscore character as the separator. We create three strings to concatenate together. The number of string inputs this node will accept can be changed by using the '+' and '-' buttons on the node."
    },
    {
        "Name": "LastIndexOf",
        "categories": [
            "Core",
            "String"
        ],
        "folderPath": "Core/String/Create",
        "dynFile": [
            "LastIndexOf"
        ],
        "imageFile": [
            "LastIndexOf"
        ],
        "inDepth": "Last Index Of will search a given string for a second input string. If the second string is found, this node will return the index of the last occurrence. By default this node is case sensitive. A boolean value can be used in the 'ignoreCase' input to make the node ignore the case of the strings. In the example below, we use the string 'Hello World', and search for the string 'o'. This string is found twice within the base string, and the index of the final occurrence of the string is returned."
    },
    {
        "Name": "Length",
        "categories": [
            "Core",
            "String"
        ],
        "folderPath": "Core/String/Create",
        "dynFile": [
            "Length"
        ],
        "imageFile": [
            "Length"
        ],
        "inDepth": "Length returns the number of characters in an input string. In the example below, we start with the string 'Hello World'. By using a Length node, we see that this string has 11 characters."
    },
    {
        "Name": "PadLeft",
        "categories": [
            "Core",
            "String"
        ],
        "folderPath": "Core/String/Create",
        "dynFile": [
            "PadLeft"
        ],
        "imageFile": [
            "PadLeft"
        ],
        "inDepth": "PadLeft will increase the width of an input string according to the newWidth input by adding the padChars input on the left side of the original string. If the original string is longer than the newWidth input, this node will return the original string unchanged. In the example below, we use the string 'Hello World' as the input string. A string with an underscore character is used as the padding character, while an integer slider is used to control the new width of the string."
    },
    {
        "Name": "PadRight",
        "categories": [
            "Core",
            "String"
        ],
        "folderPath": "Core/String/Create",
        "dynFile": [
            "PadRight"
        ],
        "imageFile": [
            "PadRight"
        ],
        "inDepth": "PadRight will increase the width of an input string according to the newWidth input by adding the padChars input on the right side of the original string. If the original string is longer than the newWidth input, this node will return the original string unchanged. In the example below, we use the string 'Hello World' as the input string. A string with an underscore character is used as the padding character, while an integer slider is used to control the new width of the string."
    },
    {
        "Name": "Remove",
        "categories": [
            "Core",
            "String"
        ],
        "folderPath": "Core/String/Create",
        "dynFile": [
            "Remove"
        ],
        "imageFile": [
            "Remove"
        ],
        "inDepth": "Remove takes a string as input, and will remove characters from that string starting at the 'startIndex' input. The number of characters to be removed is specified by the 'count' index. In the example below, we start with the string 'Hello World'. Two integer sliders are used to control the startIndex and count of the characters to be removed by a Remove node."
    },
    {
        "Name": "Replace",
        "categories": [
            "Core",
            "String"
        ],
        "folderPath": "Core/String/Create",
        "dynFile": [
            "Replace"
        ],
        "imageFile": [
            "Replace"
        ],
        "inDepth": "Replace will search a given string for a second input string. If that string is found, it will be replaced by a third input string. This node is case sensitive. In the example below, we start with the string 'Hello World'. The string 'o' is used as the string to search for, and a third string 'Hi!' is input as the string to replace with. Because the letter 'o' occurs twice within the original string, it is replaced in both occurrence with the string 'Hi!'."
    },
    {
        "Name": "Split",
        "categories": [
            "Core",
            "String"
        ],
        "folderPath": "Core/String/Create",
        "dynFile": [
            "Split"
        ],
        "imageFile": [
            "Split"
        ],
        "inDepth": "Split takes an input string and splits it according to a series of separators. The separator strings, if found, are removed from the original string, and a list of the fragments are returned. The number of separators to split by can be adjusted by using the '+' and '-' buttons on the node. In the example below, we start with the string 'Hello World'. The string 'o' is used as the separators string. The result is three fragments of the original string."
    },
    {
        "Name": "StartsWith",
        "categories": [
            "Core",
            "String"
        ],
        "folderPath": "Core/String/Create",
        "dynFile": [
            "StartsWith"
        ],
        "imageFile": [
            "StartsWith"
        ],
        "inDepth": "Starts With will return a boolean value based on whether a given string starts with a second input string. By default this node is case sensitive. A boolean value can be used in the 'ignoreCase' input to make the node ignore the case of the strings. In the example below, we use the string 'Hello World' as the original string, and use a second string 'h' as the string to search for. Because 'Hello World' starts with the string 'h' and ignoreCase is set to true, the StartsWith node returns true."
    },
    {
        "Name": "Substring",
        "categories": [
            "Core",
            "String"
        ],
        "folderPath": "Core/String/Create",
        "dynFile": [
            "Substring"
        ],
        "imageFile": [
            "Substring"
        ],
        "inDepth": "Substring takes an input string and returns a sub string based on the start index and length inputs. In the example below, we start with the string 'Hello World'. Two integer sliders are used to control where to start the substring and how many characters to take."
    },
    {
        "Name": "ToLower",
        "categories": [
            "Core",
            "String"
        ],
        "folderPath": "Core/String/Create",
        "dynFile": [
            "ToLower"
        ],
        "imageFile": [
            "ToLower"
        ],
        "inDepth": "To Lower will convert an input string to lower case letters. In the example below we start with the string 'Hello World'. By using a ToLower node, we change this string to 'hello world'."
    },
    {
        "Name": "ToNumber",
        "categories": [
            "Core",
            "String"
        ],
        "folderPath": "Core/String/Create",
        "dynFile": [
            "ToNumber"
        ],
        "imageFile": [
            "ToNumber"
        ],
        "inDepth": "To Number will convert an input string to a number data type. This node requires a string that has the format of a number. In the example below, we can see that the string 'Hello World' cannot be converted to a number, while the string '5.2' can be converted to number 5.2 "
    },
    {
        "Name": "ToUpper",
        "categories": [
            "Core",
            "String"
        ],
        "folderPath": "Core/String/Create",
        "dynFile": [
            "ToUpper"
        ],
        "imageFile": [
            "ToUpper"
        ],
        "inDepth": "To Upper will convert an input string to upper case letters. In the example below we start with the string 'Hello World'. By using a ToUpper node, we change this string to 'HELLO WORLD'."
    },
    {
        "Name": "TrimLeadingWhitespace",
        "categories": [
            "Core",
            "String"
        ],
        "folderPath": "Core/String/Create",
        "dynFile": [
            "TrimWhitespace"
        ],
        "imageFile": [
            "TrimWhitespace"
        ],
        "inDepth": "TrimLeadingWhitespace will remove the whitespace at the beginning of an input string. In the example below, we start with the string '     Hello World     ', which has several leading and trailing spaces. By using TrimLeadingWhitespace, we can remove the spaces at the beginning of the string."
    },
    {
        "Name": "TrimTrailingWhitespace",
        "categories": [
            "Core",
            "String"
        ],
        "folderPath": "Core/String/Create",
        "dynFile": [
            "TrimWhitespace"
        ],
        "imageFile": [
            "TrimWhitespace"
        ],
        "inDepth": "TrimTrailingWhitespace will remove the whitespace at the end of an input string. In the example below, we start with the string '     Hello World     ', which has several leading and trailing spaces. By using TrimTrailingWhitespace, we can remove the spaces at the end of the string."
    },
    {
        "Name": "TrimWhitespace",
        "categories": [
            "Core",
            "String"
        ],
        "folderPath": "Core/String/Create",
        "dynFile": [
            "TrimWhitespace"
        ],
        "imageFile": [
            "TrimWhitespace"
        ],
        "inDepth": "TrimWhitespace will remove all the whitespace of an input string. In the example below, we start with the string '     Hello World     ', which has several leading and trailing spaces. By using TrigWhitespace, we can remove the spaces at the beginning and end of the string, as well as the space between 'Hello' and 'World'."
    },
    {
        "Name": "Directory.FromPath",
        "categories": [
            "Core",
            "File"
        ],
        "folderPath": "Core/File/Action",
        "dynFile": [
            "DirectoryFromPath"
        ],
        "imageFile": [
            "DirectoryFromPath"
        ],
        "inDepth": "Directory FromPath will create a directory object from an input directory path. In the example below, we use a Directory Path input node, which allows us to select a directory path by clicking the 'Browse...' button. A directory path can also be created as a string. A Directory.FromPath node is used to convert the directory path string into a directory object that can be used for directory inputs, such as a Contents node."
    },
    {
        "Name": "File.FromPath",
        "categories": [
            "Core",
            "File"
        ],
        "folderPath": "Core/File/Action",
        "dynFile": [
            "FileFromPath"
        ],
        "imageFile": [
            "FileFromPath"
        ],
        "inDepth": "File FromPath will create a file object from an input file path. In the example below, we use a File Path input node, which allows us to select a file path by clicking the 'Browse...' button. A file path can also be created manually as a string. A File.FromPath node is used to convert the file path string into a file object that can be used for file inputs, such as a ReadFromFile node"
    },
    {
        "Name": "ReadFromFile",
        "categories": [
            "Core",
            "File",
            "CSV"
        ],
        "folderPath": "Core/File/CSV/Action",
        "dynFile": [
            "ReadFromFile"
        ],
        "imageFile": [
            "ReadFromFile"
        ],
        "inDepth": "Read From File takes a file as input. The file should be a text file that has data separated by commas. The different lines in the file correspond to the outer list, while the individual values in each line correspond to the inner lists. In the example below, we first use a File Path node and a File.FromPath node to create a file object that points to a text file. Then we use a ReadFromFile node to create a list from the CSV file."
    },
    {
        "Name": "WriteToFile",
        "categories": [
            "Core",
            "File",
            "CSV"
        ],
        "folderPath": "Core/File/CSV/Action",
        "dynFile": [
            "WriteToFile"
        ],
        "imageFile": [
            "WriteToFile"
        ],
        "inDepth": "Write To File will produce a CSV file from list of data. The outer lists correspond to lines in the resulting file, while the inner lists correspond to individual values separated by commas in each line. In the example below, we use a File Path node to specify the file we want to write to. A Code Block node is used to create an example list that we will write as a CSV."
    },
    {
        "Name": "Contents",
        "categories": [
            "Core",
            "File",
            "Directory"
        ],
        "folderPath": "Core/File/Directory/Action",
        "dynFile": [
            "Contents"
        ],
        "imageFile": [
            "Contents"
        ],
        "inDepth": "Contents will return a list of files and directories that are contained within a given directory. An optional searchString can be used to filter the results. In the example below, we first use a Directory Path node and a Directory.FromPath node to create a directory object. We can then get the contents of this directory with a Contents node. We use the search string '*.txt' to filter for only text files."
    },
    {
        "Name": "Copy",
        "categories": [
            "Core",
            "File",
            "Directory"
        ],
        "folderPath": "Core/File/Directory/Action",
        "dynFile": [
            "Copy"
        ],
        "imageFile": [
            "Copy"
        ],
        "inDepth": "Copy will copy the files and subfolders from one directory to another. The directory to copy from is input as a director object, while the directory to copy to is input as a director path object. An additional boolean input gives the option to overwrite files or not. This node is automatically activated when the input values change.  In the example below, we first use a Directory Path node and a Directory.FromPath node to create a directory object. A second Directory Path node is used to specify the directory we want to copy to."
    },
    {
        "Name": "Delete",
        "categories": [
            "Core",
            "File",
            "Directory"
        ],
        "folderPath": "Core/File/Directory/Action",
        "dynFile": [
            "Delete"
        ],
        "imageFile": [
            "Delete"
        ],
        "inDepth": "Delete will delete the directory specified by the input directory path. A second input accepts a boolean value to control whether the delete node is recursive or not. If recursive is set to false, this node will only delete empty directories. If recursive is set to true, the node will delete all the files and subfolders within the given directory. In the example below, we use a Directory Path node to set the directory to delete, and we use a boolean toggle to set the recursive input to true."
    },
    {
        "Name": "Exists",
        "categories": [
            "Core",
            "File",
            "Directory"
        ],
        "folderPath": "Core/File/Directory/Action",
        "dynFile": [
            "Exists"
        ],
        "imageFile": [
            "Exists"
        ],
        "inDepth": "Exists takes a directory path as input and returns a boolean value based on whether that directory path exists or not. In the example below, we previously used a Delete node to delete the directory specified by the Directory Path. Using an Exists node with the same directory shows that the directory no longer exists."
    },
    {
        "Name": "Move",
        "categories": [
            "Core",
            "File",
            "Directory"
        ],
        "folderPath": "Core/File/Directory/Action",
        "dynFile": [
            "Move"
        ],
        "imageFile": [
            "Move"
        ],
        "inDepth": "Move will move the files from the current directory to a new directory. If the new directory does not exist, this node will create it. This node is automatically activated when the input values change. In the example below, we use a Directory Path node to specify the directory to copy from. Since the directory we want to move to does not yet exist, we use a Code Block to manually specify the path of the directory to move to."
    },
    {
        "Name": "Copy",
        "categories": [
            "Core",
            "File",
            "File"
        ],
        "folderPath": "Core/File/File/Action",
        "dynFile": [
            "Copy"
        ],
        "imageFile": [
            "Copy"
        ],
        "inDepth": "Copy will copy a file specified by an input file object to a new file specified by a file path. A boolean input gives the option to overwrite existing files. This node is automatically activated when the input values change. In the example below, we first use a File Path node followed by a File.FromPath node to create a file object to copy. A destination path is created by using a Combine node that allows us to combine a directory path with a file name."
    },
    {
        "Name": "Delete",
        "categories": [
            "Core",
            "File",
            "File"
        ],
        "folderPath": "Core/File/File/Action",
        "dynFile": [
            "Delete"
        ],
        "imageFile": [
            "Delete"
        ],
        "inDepth": "Delete will delete a file specified by an input file path. In the example below, we use a File Path node to browse for the file we want to delete."
    },
    {
        "Name": "Exists",
        "categories": [
            "Core",
            "File",
            "File"
        ],
        "folderPath": "Core/File/File/Action",
        "dynFile": [
            "Exists"
        ],
        "imageFile": [
            "Exists"
        ],
        "inDepth": "Exists will return a boolean value based on whether a file exists or not. In the example below, we use a File Path node to input a file path. After using a Delete node, we can see by using an Exists node that the file no longer exists."
    },
    {
        "Name": "Move",
        "categories": [
            "Core",
            "File",
            "File"
        ],
        "folderPath": "Core/File/File/Action",
        "dynFile": [
            "Move"
        ],
        "imageFile": [
            "Move"
        ],
        "inDepth": "Move will move a file from a specifed path to a new path. A boolean input gives the option to overwrite any existing files. In the example below, we use a File Path node to browse for a file to move. We get the file name from that file by using a FileName node, and combine that with a Director Path to create a new file path to move the file to."
    },
    {
        "Name": "ReadText",
        "categories": [
            "Core",
            "File",
            "File"
        ],
        "folderPath": "Core/File/File/Action",
        "dynFile": [
            "ReadText"
        ],
        "imageFile": [
            "ReadText"
        ],
        "inDepth": "ReadText will create a string from specified file path. In the example below, we use a File Path node to browse for the file to read. A Watch node is used to see the string that results from the ReadText node."
    },
    {
        "Name": "WriteText",
        "categories": [
            "Core",
            "File",
            "File"
        ],
        "folderPath": "Core/File/File/Action",
        "dynFile": [
            "WriteText"
        ],
        "imageFile": [
            "WriteText"
        ],
        "inDepth": "WriteText will write a string to a specified file. If the file does not exists, this node will create the file. To create newlines in the output file, we can use the escape character '\\r\\n'. In the example below, we have a list of strings that we want to write as three separate lines in a text file. We join the list into a single string using '\\r\\n' as the separator. We then use a WriteText node to write this to a text file."
    },
    {
        "Name": "ChangeExtension",
        "categories": [
            "Core",
            "File",
            "FilePath"
        ],
        "folderPath": "Core/File/FilePath/Action",
        "dynFile": [
            "ChangeExtension"
        ],
        "imageFile": [
            "ChangeExtension"
        ],
        "inDepth": "Change Extension will replace the extension of an input file path object with a specified new extension input as a string. In the example below, we use a File Path node to browse for a .txt file. We then use a ChangeExtension node to create a new file path with a different extension by replacing the .txt with a .exp extension."
    },
    {
        "Name": "Combine",
        "categories": [
            "Core",
            "File",
            "FilePath"
        ],
        "folderPath": "Core/File/FilePath/Action",
        "dynFile": [
            "Combine"
        ],
        "imageFile": [
            "Combine"
        ],
        "inDepth": "Combine will join multiple inputs together into a single string. In the example below, we use a Director Path to select a director. We specify a file name by using a Code Block. We then use a Combine node to join the director path and file name together into a file path."
    },
    {
        "Name": "DirectoryName",
        "categories": [
            "Core",
            "File",
            "FilePath"
        ],
        "folderPath": "Core/File/FilePath/Action",
        "dynFile": [
            "DirectoryName"
        ],
        "imageFile": [
            "DirectoryName"
        ],
        "inDepth": "Directory Name will return the director of a file or director path. In the example below, we use a DirectorPath node to extract the directory from a file path. In addition to FileName and Extension, this allows us to break apart a file path into separate components."
    },
    {
        "Name": "Extension",
        "categories": [
            "Core",
            "File",
            "FilePath"
        ],
        "folderPath": "Core/File/FilePath/Action",
        "dynFile": [
            "Extension"
        ],
        "imageFile": [
            "Extension"
        ],
        "inDepth": "Extension will return the extension from a file path. In addition to FileName and DirectoryName, this allows us to break apart a file path into separate components."
    },
    {
        "Name": "FileName",
        "categories": [
            "Core",
            "File",
            "FilePath"
        ],
        "folderPath": "Core/File/FilePath/Action",
        "dynFile": [
            "FileName"
        ],
        "imageFile": [
            "FileName"
        ],
        "inDepth": "File Name will return the file name from an input file path. A boolean input provides to option to return the file name with or without the extension. In addition to DirectoryName and Extension, this allows us to break apart a file path into separate components."
    },
    {
        "Name": "HasExtension",
        "categories": [
            "Core",
            "File",
            "FilePath"
        ],
        "folderPath": "Core/File/FilePath/Action",
        "dynFile": [
            "HasExtension"
        ],
        "imageFile": [
            "HasExtension"
        ],
        "inDepth": "Has Extension returns a boolean value that is true if the input file path has an extension, and false if the input file path does not have an extension. In the example below, we use a File Path node to browse for a file. This path has the extension .txt, so HasExtension returns true."
    },
    {
        "Name": "Dimensions",
        "categories": [
            "Core",
            "File",
            "Image"
        ],
        "folderPath": "Core/File/Image/Action",
        "dynFile": [
            "Dimensions"
        ],
        "imageFile": [
            "Dimensions"
        ],
        "inDepth": "Dimensions will return the width and height of an input image in pixels. In the example below, we first use a File Path node and a File.FromPath to create a file object that points to an image. Image.ReadFromFile is then used to create an image object based on the file. A Dimensions node shows us that this image has a width and height of 270 pixels."
    },
    {
        "Name": "FromPixels (colors, width, height)",
        "categories": [
            "Core",
            "File",
            "Image"
        ],
        "folderPath": "Core/File/Image/Action",
        "dynFile": [
            "FromPixels_cwh"
        ],
        "imageFile": [
            "FromPixels_cwh"
        ],
        "inDepth": "From Pixels with width and height will create an image from an input flat list of colors, where each color will become one pixel. The width multiplied by the height should equal the total number of colors. In the example below, we first create a list of colors using a ByARGB node. A code block creates a range of values from 0 to 255, which when connected to the r and g inputs produces a series of colors from black to yellow. We create a image with a width of 8. A Count node and Division node are used to determine the height of the image. A Watch Image node can be used to preview the image created."
    },
    {
        "Name": "FromPixels (colors)",
        "categories": [
            "Core",
            "File",
            "Image"
        ],
        "folderPath": "Core/File/Image/Action",
        "dynFile": [
            "FromPixels_c"
        ],
        "imageFile": [
            "FromPixels_c"
        ],
        "inDepth": "From Pixels will create an image object from an input two-dimensional array of colors. In the example below, we first use a code block to generate a range of numbers from 0 to 255. A Color.ByARGB node is used to create colors from this range, and the lacing of this node is set to Cross Product to create a two-dimensional array. We then use an Image.FromPixels node to create an image. A Watch Image node can be used to preview the image created."
    },
    {
        "Name": "Pixels",
        "categories": [
            "Core",
            "File",
            "Image"
        ],
        "folderPath": "Core/File/Image/Action",
        "dynFile": [
            "Pixels"
        ],
        "imageFile": [
            "Pixels"
        ],
        "inDepth": "Pixels will return a list of colors from an input image as a two-dimensional array. The Pixels node has two additional inputs to specify the number of x and y samples to use to extract pixels from. In the example below, we read an image using a ReadFromFile node. This image is then input into a Pixels node to extract the pixel colors."
    },
    {
        "Name": "ReadFromFile",
        "categories": [
            "Core",
            "File",
            "Image"
        ],
        "folderPath": "Core/File/Image/Action",
        "dynFile": [
            "ReadFromFile"
        ],
        "imageFile": [
            "ReadFromFile"
        ],
        "inDepth": "Read From File will create an image object from an input file object. In the example below, we use a FilePath node followed by a File.FromPath node to create a file object to use as the input to a ReadFromFile node. A Watch Image node is used to preview the loaded image."
    },
    {
        "Name": "WriteToFile",
        "categories": [
            "Core",
            "File",
            "Image"
        ],
        "folderPath": "Core/File/Image/Action",
        "dynFile": [
            "WriteToFile"
        ],
        "imageFile": [
            "WriteToFile"
        ],
        "inDepth": "Write to File will write an image to a specified file path. This node is automatically activated when the inputs change. In the example below, we use an Image.FromPixels node to create an image object based on a generated set of colors. A FilePath node is used to specify the directory and file name to write this image to."
    },
    {
        "Name": "AllFalse",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [
            "AllFalse"
        ],
        "imageFile": [
            "AllFalse"
        ],
        "folderPath": [
            "BuiltIn",
            "Action"
        ],
        "inDepth": "AllFalse only returns <strong>true</strong> if <em>every</em> item in a list is false.",
        "index": 464
    },
    {
        "Name": "IsAlmostEqualTo",
        "categories": [
            "Analyze",
            "AnalysisExtensions"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Analyze/AnalysisExtensions/Action",
        "inDepth": "Add in-depth information about IsAlmostEqualTo...",
        "index": 465
    },
    {
        "Name": "ByPointAndString",
        "categories": [
            "Analyze",
            "Label"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Analyze/Label/Create",
        "inDepth": "Add in-depth information about ByPointAndString...",
        "index": 466
    },
    {
        "Name": "AllTrue",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about AllTrue...",
        "index": 467
    },
    {
        "Name": "Contains (list, element)",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about Contains (list, element)...",
        "index": 468
    },
    {
        "Name": "ContainsKey",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about ContainsKey...",
        "index": 469
    },
    {
        "Name": "CountFalse",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about CountFalse...",
        "index": 470
    },
    {
        "Name": "CountTrue",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about CountTrue...",
        "index": 471
    },
    {
        "Name": "Equals",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about Equals...",
        "index": 472
    },
    {
        "Name": "GetKeys",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about GetKeys...",
        "index": 473
    },
    {
        "Name": "GetValues",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about GetValues...",
        "index": 474
    },
    {
        "Name": "GroupByFunction",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about GroupByFunction...",
        "index": 475
    },
    {
        "Name": "ImportFromCSV (filePath, transpose)",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about ImportFromCSV (filePath, transpose)...",
        "index": 476
    },
    {
        "Name": "ImportFromCSV (filePath)",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about ImportFromCSV (filePath)...",
        "index": 477
    },
    {
        "Name": "Insert (list, element, index)",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about Insert (list, element, index)...",
        "index": 478
    },
    {
        "Name": "IsHomogeneous",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about IsHomogeneous...",
        "index": 479
    },
    {
        "Name": "IsRectangular",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about IsRectangular...",
        "index": 480
    },
    {
        "Name": "IsUniformDepth",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about IsUniformDepth...",
        "index": 481
    },
    {
        "Name": "LoopWhile",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about LoopWhile...",
        "index": 482
    },
    {
        "Name": "Map",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about Map...",
        "index": 483
    },
    {
        "Name": "MapTo",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about MapTo...",
        "index": 484
    },
    {
        "Name": "MaximumItemByKey",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about MaximumItemByKey...",
        "index": 485
    },
    {
        "Name": "MinimumItemByKey",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about MinimumItemByKey...",
        "index": 486
    },
    {
        "Name": "NewtonRootFind1DNoDeriv",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about NewtonRootFind1DNoDeriv...",
        "index": 487
    },
    {
        "Name": "NewtonRootFind1DWithDeriv",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about NewtonRootFind1DWithDeriv...",
        "index": 488
    },
    {
        "Name": "NormalizeDepth (list)",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about NormalizeDepth (list)...",
        "index": 489
    },
    {
        "Name": "NormalizeDepth (list, rank)",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about NormalizeDepth (list, rank)...",
        "index": 490
    },
    {
        "Name": "Rank",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about Rank...",
        "index": 491
    },
    {
        "Name": "RemoveIfNot",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about RemoveIfNot...",
        "index": 492
    },
    {
        "Name": "RemoveKey",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about RemoveKey...",
        "index": 493
    },
    {
        "Name": "Reorder",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about Reorder...",
        "index": 494
    },
    {
        "Name": "SetDifference",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about SetDifference...",
        "index": 495
    },
    {
        "Name": "SetIntersection",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about SetIntersection...",
        "index": 496
    },
    {
        "Name": "SetUnion",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about SetUnion...",
        "index": 497
    },
    {
        "Name": "SortByFunction",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about SortByFunction...",
        "index": 498
    },
    {
        "Name": "SortIndexByValue (list, ascending)",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about SortIndexByValue (list, ascending)...",
        "index": 499
    },
    {
        "Name": "SortIndexByValue (list)",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about SortIndexByValue (list)...",
        "index": 500
    },
    {
        "Name": "TrueForAll",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about TrueForAll...",
        "index": 501
    },
    {
        "Name": "TrueForAny",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about TrueForAny...",
        "index": 502
    },
    {
        "Name": "AddTimeSpan",
        "categories": [
            "Core",
            "DateTime"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/DateTime/Action",
        "inDepth": "Add in-depth information about AddTimeSpan...",
        "index": 503
    },
    {
        "Name": "ByDate",
        "categories": [
            "Core",
            "DateTime"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/DateTime/Action",
        "inDepth": "Add in-depth information about ByDate...",
        "index": 504
    },
    {
        "Name": "ByDateAndTime",
        "categories": [
            "Core",
            "DateTime"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/DateTime/Action",
        "inDepth": "Add in-depth information about ByDateAndTime...",
        "index": 505
    },
    {
        "Name": "Date",
        "categories": [
            "Core",
            "DateTime"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/DateTime/Action",
        "inDepth": "Add in-depth information about Date...",
        "index": 506
    },
    {
        "Name": "DayOfWeek",
        "categories": [
            "Core",
            "DateTime"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/DateTime/Action",
        "inDepth": "Add in-depth information about DayOfWeek...",
        "index": 507
    },
    {
        "Name": "DayOfYear",
        "categories": [
            "Core",
            "DateTime"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/DateTime/Action",
        "inDepth": "Add in-depth information about DayOfYear...",
        "index": 508
    },
    {
        "Name": "DaysInMonth",
        "categories": [
            "Core",
            "DateTime"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/DateTime/Action",
        "inDepth": "Add in-depth information about DaysInMonth...",
        "index": 509
    },
    {
        "Name": "FromString",
        "categories": [
            "Core",
            "DateTime"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/DateTime/Action",
        "inDepth": "Add in-depth information about FromString...",
        "index": 510
    },
    {
        "Name": "IsDaylightSavingsTime",
        "categories": [
            "Core",
            "DateTime"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/DateTime/Action",
        "inDepth": "Add in-depth information about IsDaylightSavingsTime...",
        "index": 511
    },
    {
        "Name": "IsLeapYear",
        "categories": [
            "Core",
            "DateTime"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/DateTime/Action",
        "inDepth": "Add in-depth information about IsLeapYear...",
        "index": 512
    },
    {
        "Name": "SubtractTimeSpan",
        "categories": [
            "Core",
            "DateTime"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/DateTime/Action",
        "inDepth": "Add in-depth information about SubtractTimeSpan...",
        "index": 513
    },
    {
        "Name": "TimeOfDay",
        "categories": [
            "Core",
            "DateTime"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/DateTime/Action",
        "inDepth": "Add in-depth information about TimeOfDay...",
        "index": 514
    },
    {
        "Name": "MaxValue",
        "categories": [
            "Core",
            "DateTime"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/DateTime/Query",
        "inDepth": "Add in-depth information about MaxValue...",
        "index": 515
    },
    {
        "Name": "MinValue (",
        "categories": [
            "Core",
            "DateTime"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/DateTime/Query",
        "inDepth": "Add in-depth information about MinValue (...",
        "index": 516
    },
    {
        "Name": "MinValue (year, month, day)",
        "categories": [
            "Core",
            "DateTime"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/DateTime/Query",
        "inDepth": "Add in-depth information about MinValue (year, month, day)...",
        "index": 517
    },
    {
        "Name": "Now",
        "categories": [
            "Core",
            "DateTime"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/DateTime/Query",
        "inDepth": "Add in-depth information about Now...",
        "index": 518
    },
    {
        "Name": "Today",
        "categories": [
            "Core",
            "DateTime"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/DateTime/Query",
        "inDepth": "Add in-depth information about Today...",
        "index": 519
    },
    {
        "Name": "Friday",
        "categories": [
            "Core",
            "DayOfWeek"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/DayOfWeek/Query",
        "inDepth": "Add in-depth information about Friday...",
        "index": 520
    },
    {
        "Name": "Monday",
        "categories": [
            "Core",
            "DayOfWeek"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/DayOfWeek/Query",
        "inDepth": "Add in-depth information about Monday...",
        "index": 521
    },
    {
        "Name": "Saturday",
        "categories": [
            "Core",
            "DayOfWeek"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/DayOfWeek/Query",
        "inDepth": "Add in-depth information about Saturday...",
        "index": 522
    },
    {
        "Name": "Sunday",
        "categories": [
            "Core",
            "DayOfWeek"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/DayOfWeek/Query",
        "inDepth": "Add in-depth information about Sunday...",
        "index": 523
    },
    {
        "Name": "Thursday",
        "categories": [
            "Core",
            "DayOfWeek"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/DayOfWeek/Query",
        "inDepth": "Add in-depth information about Thursday...",
        "index": 524
    },
    {
        "Name": "Tuesday",
        "categories": [
            "Core",
            "DayOfWeek"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/DayOfWeek/Query",
        "inDepth": "Add in-depth information about Tuesday...",
        "index": 525
    },
    {
        "Name": "Wednesday",
        "categories": [
            "Core",
            "DayOfWeek"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/DayOfWeek/Query",
        "inDepth": "Add in-depth information about Wednesday...",
        "index": 526
    },
    {
        "Name": "Function.Apply",
        "categories": [
            "Core",
            "Evaluate"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/Evaluate/Action",
        "inDepth": "Add in-depth information about Function.Apply...",
        "index": 527
    },
    {
        "Name": "Function.Compose",
        "categories": [
            "Core",
            "Evaluate"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/Evaluate/Action",
        "inDepth": "Add in-depth information about Function.Compose...",
        "index": 528
    },
    {
        "Name": "Evaluate",
        "categories": [
            "Core",
            "Formula"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/Formula/Action",
        "inDepth": "Add in-depth information about Evaluate...",
        "index": 529
    },
    {
        "Name": "Code Block (",
        "categories": [
            "Core",
            "Input"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/Input/Action",
        "inDepth": "Add in-depth information about Code Block (...",
        "index": 530
    },
    {
        "Name": "Input",
        "categories": [
            "Core",
            "Input"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/Input/Action",
        "inDepth": "Add in-depth information about Input...",
        "index": 531
    },
    {
        "Name": "Output",
        "categories": [
            "Core",
            "Input"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/Input/Action",
        "inDepth": "Add in-depth information about Output...",
        "index": 532
    },
    {
        "Name": "Clean",
        "categories": [
            "Core",
            "List"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/List/Action",
        "inDepth": "Add in-depth information about Clean...",
        "index": 533
    },
    {
        "Name": "DiagonalLeft",
        "categories": [
            "Core",
            "List"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/List/Action",
        "inDepth": "Add in-depth information about DiagonalLeft...",
        "index": 534
    },
    {
        "Name": "DiagonalRight",
        "categories": [
            "Core",
            "List"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/List/Action",
        "inDepth": "Add in-depth information about DiagonalRight...",
        "index": 535
    },
    {
        "Name": "Empty",
        "categories": [
            "Core",
            "List"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/List/Query",
        "inDepth": "Add in-depth information about Empty...",
        "index": 536
    },
    {
        "Name": "ByLatitudeAndLongitude",
        "categories": [
            "Core",
            "Location"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/Location/Create",
        "inDepth": "Add in-depth information about ByLatitudeAndLongitude...",
        "index": 537
    },
    {
        "Name": "Latitude",
        "categories": [
            "Core",
            "Location"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/Location/Query",
        "inDepth": "Add in-depth information about Latitude...",
        "index": 538
    },
    {
        "Name": "Longitude",
        "categories": [
            "Core",
            "Location"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/Location/Query",
        "inDepth": "Add in-depth information about Longitude...",
        "index": 539
    },
    {
        "Name": "Name",
        "categories": [
            "Core",
            "Location"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/Location/Query",
        "inDepth": "Add in-depth information about Name...",
        "index": 540
    },
    {
        "Name": "ScopeIf",
        "categories": [
            "Core",
            "Logic"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/Logic/Action",
        "inDepth": "Add in-depth information about ScopeIf...",
        "index": 541
    },
    {
        "Name": "Identity",
        "categories": [
            "Core",
            "Object"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/Object/Action",
        "inDepth": "Add in-depth information about Identity...",
        "index": 542
    },
    {
        "Name": "IsNull",
        "categories": [
            "Core",
            "Object"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/Object/Action",
        "inDepth": "Add in-depth information about IsNull...",
        "index": 543
    },
    {
        "Name": "Type",
        "categories": [
            "Core",
            "Object"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/Object/Action",
        "inDepth": "Add in-depth information about Type...",
        "index": 544
    },
    {
        "Name": "Formula (IN[0]) (IN[0])",
        "categories": [
            "Core",
            "Scripting"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/Scripting/Action",
        "inDepth": "Add in-depth information about Formula (IN[0]) (IN[0])...",
        "index": 545
    },
    {
        "Name": "Formula (",
        "categories": [
            "Core",
            "Scripting"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/Scripting/Action",
        "inDepth": "Add in-depth information about Formula (...",
        "index": 546
    },
    {
        "Name": "Python Script",
        "categories": [
            "Core",
            "Scripting"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/Scripting/Action",
        "inDepth": "Add in-depth information about Python Script...",
        "index": 547
    },
    {
        "Name": "Python Script From String",
        "categories": [
            "Core",
            "Scripting"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/Scripting/Action",
        "inDepth": "Add in-depth information about Python Script From String...",
        "index": 548
    },
    {
        "Name": "String from Array",
        "categories": [
            "Core",
            "String"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/String/Action",
        "inDepth": "Add in-depth information about String from Array...",
        "index": 549
    },
    {
        "Name": "String from Object",
        "categories": [
            "Core",
            "String"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/String/Action",
        "inDepth": "Add in-depth information about String from Object...",
        "index": 550
    },
    {
        "Name": "Pause",
        "categories": [
            "Core",
            "Thread"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/Thread/Action",
        "inDepth": "Add in-depth information about Pause...",
        "index": 551
    },
    {
        "Name": "ByDateDifference",
        "categories": [
            "Core",
            "TimeSpan"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/TimeSpan/Action",
        "inDepth": "Add in-depth information about ByDateDifference...",
        "index": 552
    },
    {
        "Name": "Create",
        "categories": [
            "Core",
            "TimeSpan"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/TimeSpan/Action",
        "inDepth": "Add in-depth information about Create...",
        "index": 553
    },
    {
        "Name": "Negate",
        "categories": [
            "Core",
            "TimeSpan"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/TimeSpan/Action",
        "inDepth": "Add in-depth information about Negate...",
        "index": 554
    },
    {
        "Name": "Scale",
        "categories": [
            "Core",
            "TimeSpan"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/TimeSpan/Action",
        "inDepth": "Add in-depth information about Scale...",
        "index": 555
    },
    {
        "Name": "TotalDays",
        "categories": [
            "Core",
            "TimeSpan"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/TimeSpan/Action",
        "inDepth": "Add in-depth information about TotalDays...",
        "index": 556
    },
    {
        "Name": "TotalHours",
        "categories": [
            "Core",
            "TimeSpan"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/TimeSpan/Action",
        "inDepth": "Add in-depth information about TotalHours...",
        "index": 557
    },
    {
        "Name": "TotalMilliseconds",
        "categories": [
            "Core",
            "TimeSpan"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/TimeSpan/Action",
        "inDepth": "Add in-depth information about TotalMilliseconds...",
        "index": 558
    },
    {
        "Name": "TotalMinutes",
        "categories": [
            "Core",
            "TimeSpan"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/TimeSpan/Action",
        "inDepth": "Add in-depth information about TotalMinutes...",
        "index": 559
    },
    {
        "Name": "TotalSeconds",
        "categories": [
            "Core",
            "TimeSpan"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/TimeSpan/Action",
        "inDepth": "Add in-depth information about TotalSeconds...",
        "index": 560
    },
    {
        "Name": "MinValue",
        "categories": [
            "Core",
            "TimeSpan"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/TimeSpan/Query",
        "inDepth": "Add in-depth information about MinValue...",
        "index": 561
    },
    {
        "Name": "Zero",
        "categories": [
            "Core",
            "TimeSpan"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/TimeSpan/Query",
        "inDepth": "Add in-depth information about Zero...",
        "index": 562
    },
    {
        "Name": "Convert Between Units",
        "categories": [
            "Core",
            "Units"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/Units/Action",
        "inDepth": "Add in-depth information about Convert Between Units...",
        "index": 563
    },
    {
        "Name": "Number From Feet and Inches",
        "categories": [
            "Core",
            "Units"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/Units/Action",
        "inDepth": "Add in-depth information about Number From Feet and Inches...",
        "index": 564
    },
    {
        "Name": "Unit Types",
        "categories": [
            "Core",
            "Units"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/Units/Action",
        "inDepth": "Add in-depth information about Unit Types...",
        "index": 565
    },
    {
        "Name": "Watch",
        "categories": [
            "Core",
            "View"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/View/Action",
        "inDepth": "Add in-depth information about Watch...",
        "index": 566
    },
    {
        "Name": "Watch 3D",
        "categories": [
            "Core",
            "View"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/View/Action",
        "inDepth": "Add in-depth information about Watch 3D...",
        "index": 567
    },
    {
        "Name": "Watch Image",
        "categories": [
            "Core",
            "View"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/View/Action",
        "inDepth": "Add in-depth information about Watch Image...",
        "index": 568
    },
    {
        "Name": "Web Request",
        "categories": [
            "Core",
            "Web"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/Web/Action",
        "inDepth": "Add in-depth information about Web Request...",
        "index": 569
    },
    {
        "Name": "ByGeometryColor",
        "categories": [
            "Display",
            "Display",
            "Display"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Display/Display/Display/Create",
        "inDepth": "Add in-depth information about ByGeometryColor...",
        "index": 570
    },
    {
        "Name": "BySurfaceColors",
        "categories": [
            "Display",
            "Display",
            "Display"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Display/Display/Display/Create",
        "inDepth": "Add in-depth information about BySurfaceColors...",
        "index": 571
    },
    {
        "Name": "ToPolySurface",
        "categories": [
            "Geometry",
            "BoundingBox"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/BoundingBox/Action",
        "inDepth": "Add in-depth information about ToPolySurface...",
        "index": 572
    },
    {
        "Name": "ByMatrix",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Create",
        "inDepth": "Add in-depth information about ByMatrix...",
        "index": 573
    },
    {
        "Name": "ByOrigin (origin)",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Create",
        "inDepth": "Add in-depth information about ByOrigin (origin)...",
        "index": 574
    },
    {
        "Name": "ByOrigin (x, y)",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Create",
        "inDepth": "Add in-depth information about ByOrigin (x, y)...",
        "index": 575
    },
    {
        "Name": "ByOrigin (x, y, z)",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Create",
        "inDepth": "Add in-depth information about ByOrigin (x, y, z)...",
        "index": 576
    },
    {
        "Name": "ByOriginVectors (origin, xAxis, yAxis, zAxis)",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Create",
        "inDepth": "Add in-depth information about ByOriginVectors (origin, xAxis, yAxis, zAxis)...",
        "index": 577
    },
    {
        "Name": "ByOriginVectors (origin, xAxis, yAxis)",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Create",
        "inDepth": "Add in-depth information about ByOriginVectors (origin, xAxis, yAxis)...",
        "index": 578
    },
    {
        "Name": "ByPlane",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Create",
        "inDepth": "Add in-depth information about ByPlane...",
        "index": 579
    },
    {
        "Name": "Identity (",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Create",
        "inDepth": "Add in-depth information about Identity (...",
        "index": 580
    },
    {
        "Name": "Identity (matrix)",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Create",
        "inDepth": "Add in-depth information about Identity (matrix)...",
        "index": 581
    },
    {
        "Name": "Inverse",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Add in-depth information about Inverse...",
        "index": 582
    },
    {
        "Name": "IsEqualTo",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Add in-depth information about IsEqualTo...",
        "index": 583
    },
    {
        "Name": "PostMultiplyBy",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Add in-depth information about PostMultiplyBy...",
        "index": 584
    },
    {
        "Name": "PreMultiplyBy",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Add in-depth information about PreMultiplyBy...",
        "index": 585
    },
    {
        "Name": "Rotate (coordinateSystem, origin, degrees)",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Add in-depth information about Rotate (coordinateSystem, origin, degrees)...",
        "index": 586
    },
    {
        "Name": "Rotate (coordinateSystem, origin, axis, degrees)",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Add in-depth information about Rotate (coordinateSystem, origin, axis, degrees)...",
        "index": 587
    },
    {
        "Name": "Scale (coordinateSystem, xamount, yamount, zamount)",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Add in-depth information about Scale (coordinateSystem, xamount, yamount, zamount)...",
        "index": 588
    },
    {
        "Name": "Scale (coordinateSystem, plane, xamount, yamount, zamount)",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Add in-depth information about Scale (coordinateSystem, plane, xamount, yamount, zamount)...",
        "index": 589
    },
    {
        "Name": "Scale (coordinateSystem, basePoint, from, to)",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Add in-depth information about Scale (coordinateSystem, basePoint, from, to)...",
        "index": 590
    },
    {
        "Name": "Scale (coordinateSystem, amount)",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Add in-depth information about Scale (coordinateSystem, amount)...",
        "index": 591
    },
    {
        "Name": "ScaleFactor",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Add in-depth information about ScaleFactor...",
        "index": 592
    },
    {
        "Name": "Transform (coordinateSystem, fromCoordinateSystem, contextCoordinateSystem)",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Add in-depth information about Transform (coordinateSystem, fromCoordinateSystem, contextCoordinateSystem)...",
        "index": 593
    },
    {
        "Name": "Transform (coordinateSystem, cs)",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Add in-depth information about Transform (coordinateSystem, cs)...",
        "index": 594
    },
    {
        "Name": "Translate (coordinateSystem, direction)",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Add in-depth information about Translate (coordinateSystem, direction)...",
        "index": 595
    },
    {
        "Name": "Translate (coordinateSystem, direction, distance)",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Add in-depth information about Translate (coordinateSystem, direction, distance)...",
        "index": 596
    },
    {
        "Name": "Translate (coordinateSystem, xTranslation, yTranslation, zTranslation)",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Add in-depth information about Translate (coordinateSystem, xTranslation, yTranslation, zTranslation)...",
        "index": 597
    },
    {
        "Name": "Determinant",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Query",
        "inDepth": "Add in-depth information about Determinant...",
        "index": 598
    },
    {
        "Name": "IsScaledOrtho",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Query",
        "inDepth": "Add in-depth information about IsScaledOrtho...",
        "index": 599
    },
    {
        "Name": "IsSingular",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Query",
        "inDepth": "Add in-depth information about IsSingular...",
        "index": 600
    },
    {
        "Name": "IsUniscaledOrtho",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Query",
        "inDepth": "Add in-depth information about IsUniscaledOrtho...",
        "index": 601
    },
    {
        "Name": "XScaleFactor",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Query",
        "inDepth": "Add in-depth information about XScaleFactor...",
        "index": 602
    },
    {
        "Name": "XYPlane",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Query",
        "inDepth": "Add in-depth information about XYPlane...",
        "index": 603
    },
    {
        "Name": "YScaleFactor",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Query",
        "inDepth": "Add in-depth information about YScaleFactor...",
        "index": 604
    },
    {
        "Name": "YZPlane",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Query",
        "inDepth": "Add in-depth information about YZPlane...",
        "index": 605
    },
    {
        "Name": "ZAxis",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Query",
        "inDepth": "Add in-depth information about ZAxis...",
        "index": 606
    },
    {
        "Name": "ZScaleFactor",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Query",
        "inDepth": "Add in-depth information about ZScaleFactor...",
        "index": 607
    },
    {
        "Name": "ZXPlane",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Query",
        "inDepth": "Add in-depth information about ZXPlane...",
        "index": 608
    },
    {
        "Name": "ByLengths (cs, width, length, height) (cs, width, length, height)",
        "categories": [
            "Geometry",
            "Cuboid"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Cuboid/Create",
        "inDepth": "Add in-depth information about ByLengths (cs, width, length, height) (cs, width, length, height)...",
        "index": 609
    },
    {
        "Name": "Simplify",
        "categories": [
            "Geometry",
            "Curve"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Curve/Action",
        "inDepth": "Add in-depth information about Simplify...",
        "index": 610
    },
    {
        "Name": "ByRadiusHeight",
        "categories": [
            "Geometry",
            "Cylinder"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Cylinder/Create",
        "inDepth": "Add in-depth information about ByRadiusHeight...",
        "index": 611
    },
    {
        "Name": "AdjacentFaces",
        "categories": [
            "Geometry",
            "Edge"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Edge/Query",
        "inDepth": "Add in-depth information about AdjacentFaces...",
        "index": 612
    },
    {
        "Name": "CurveGeometry",
        "categories": [
            "Geometry",
            "Edge"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Edge/Query",
        "inDepth": "Add in-depth information about CurveGeometry...",
        "index": 613
    },
    {
        "Name": "EndVertex",
        "categories": [
            "Geometry",
            "Edge"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Edge/Query",
        "inDepth": "Add in-depth information about EndVertex...",
        "index": 614
    },
    {
        "Name": "StartVertex",
        "categories": [
            "Geometry",
            "Edge"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Edge/Query",
        "inDepth": "Add in-depth information about StartVertex...",
        "index": 615
    },
    {
        "Name": "SurfaceGeometry",
        "categories": [
            "Geometry",
            "Face"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Face/Action",
        "inDepth": "Add in-depth information about SurfaceGeometry...",
        "index": 616
    },
    {
        "Name": "Edges",
        "categories": [
            "Geometry",
            "Face"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Face/Query",
        "inDepth": "Add in-depth information about Edges...",
        "index": 617
    },
    {
        "Name": "Vertices",
        "categories": [
            "Geometry",
            "Face"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Face/Query",
        "inDepth": "Add in-depth information about Vertices...",
        "index": 618
    },
    {
        "Name": "DeserializeFromSAB",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "Add in-depth information about DeserializeFromSAB...",
        "index": 619
    },
    {
        "Name": "ExportToSAT (geometry, filePath, unitsMM)",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "Add in-depth information about ExportToSAT (geometry, filePath, unitsMM)...",
        "index": 620
    },
    {
        "Name": "SerializeAsSAB (geometry)",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "Add in-depth information about SerializeAsSAB (geometry)...",
        "index": 621
    },
    {
        "Name": "BoundingBox",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Geometry/Query",
        "inDepth": "Add in-depth information about BoundingBox...",
        "index": 622
    },
    {
        "Name": "ContextCoordinateSystem",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Geometry/Query",
        "inDepth": "Add in-depth information about ContextCoordinateSystem...",
        "index": 623
    },
    {
        "Name": "ByIndices (a, b, c, d) (a, b, c, d) (a, b, c, d)",
        "categories": [
            "Geometry",
            "IndexGroup"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/IndexGroup/Create",
        "inDepth": "Add in-depth information about ByIndices (a, b, c, d) (a, b, c, d) (a, b, c, d)...",
        "index": 624
    },
    {
        "Name": "ByIndices (a, b, c) (a, b, c)",
        "categories": [
            "Geometry",
            "IndexGroup"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/IndexGroup/Create",
        "inDepth": "Add in-depth information about ByIndices (a, b, c) (a, b, c)...",
        "index": 625
    },
    {
        "Name": "A",
        "categories": [
            "Geometry",
            "IndexGroup"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/IndexGroup/Query",
        "inDepth": "Add in-depth information about A...",
        "index": 626
    },
    {
        "Name": "B",
        "categories": [
            "Geometry",
            "IndexGroup"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/IndexGroup/Query",
        "inDepth": "Add in-depth information about B...",
        "index": 627
    },
    {
        "Name": "C",
        "categories": [
            "Geometry",
            "IndexGroup"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/IndexGroup/Query",
        "inDepth": "Add in-depth information about C...",
        "index": 628
    },
    {
        "Name": "D",
        "categories": [
            "Geometry",
            "IndexGroup"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/IndexGroup/Query",
        "inDepth": "Add in-depth information about D...",
        "index": 629
    },
    {
        "Name": "ByPointsFaceIndices",
        "categories": [
            "Geometry",
            "Mesh"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Mesh/Create",
        "inDepth": "Add in-depth information about ByPointsFaceIndices...",
        "index": 630
    },
    {
        "Name": "FaceIndices",
        "categories": [
            "Geometry",
            "Mesh"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Mesh/Query",
        "inDepth": "Add in-depth information about FaceIndices...",
        "index": 631
    },
    {
        "Name": "VertexNormals",
        "categories": [
            "Geometry",
            "Mesh"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Mesh/Query",
        "inDepth": "Add in-depth information about VertexNormals...",
        "index": 632
    },
    {
        "Name": "VertexPositions",
        "categories": [
            "Geometry",
            "Mesh"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Mesh/Query",
        "inDepth": "Add in-depth information about VertexPositions...",
        "index": 633
    },
    {
        "Name": "ByPointsTangentsKnotsDerivatives",
        "categories": [
            "Geometry",
            "NurbsSurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/NurbsSurface/Create",
        "inDepth": "Add in-depth information about ByPointsTangentsKnotsDerivatives...",
        "index": 634
    },
    {
        "Name": "UKnots",
        "categories": [
            "Geometry",
            "NurbsSurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/NurbsSurface/Action",
        "inDepth": "Add in-depth information about UKnots...",
        "index": 635
    },
    {
        "Name": "VKnots",
        "categories": [
            "Geometry",
            "NurbsSurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/NurbsSurface/Action",
        "inDepth": "Add in-depth information about VKnots...",
        "index": 636
    },
    {
        "Name": "DegreeU",
        "categories": [
            "Geometry",
            "NurbsSurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/NurbsSurface/Query",
        "inDepth": "Add in-depth information about DegreeU...",
        "index": 637
    },
    {
        "Name": "DegreeV",
        "categories": [
            "Geometry",
            "NurbsSurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/NurbsSurface/Query",
        "inDepth": "Add in-depth information about DegreeV...",
        "index": 638
    },
    {
        "Name": "IsPeriodicInU",
        "categories": [
            "Geometry",
            "NurbsSurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/NurbsSurface/Query",
        "inDepth": "Add in-depth information about IsPeriodicInU...",
        "index": 639
    },
    {
        "Name": "IsPeriodicInV",
        "categories": [
            "Geometry",
            "NurbsSurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/NurbsSurface/Query",
        "inDepth": "Add in-depth information about IsPeriodicInV...",
        "index": 640
    },
    {
        "Name": "NumControlPointsU",
        "categories": [
            "Geometry",
            "NurbsSurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/NurbsSurface/Query",
        "inDepth": "Add in-depth information about NumControlPointsU...",
        "index": 641
    },
    {
        "Name": "NumControlPointsV",
        "categories": [
            "Geometry",
            "NurbsSurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/NurbsSurface/Query",
        "inDepth": "Add in-depth information about NumControlPointsV...",
        "index": 642
    },
    {
        "Name": "ByCoordinates (x, y, z)",
        "categories": [
            "Geometry",
            "Point"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Point/Create",
        "inDepth": "Add in-depth information about ByCoordinates (x, y, z)...",
        "index": 643
    },
    {
        "Name": "CloseWithLineAndTangentArcs",
        "categories": [
            "Geometry",
            "PolyCurve"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/PolyCurve/Action",
        "inDepth": "Add in-depth information about CloseWithLineAndTangentArcs...",
        "index": 644
    },
    {
        "Name": "ExtendWithEllipse",
        "categories": [
            "Geometry",
            "PolyCurve"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/PolyCurve/Action",
        "inDepth": "Add in-depth information about ExtendWithEllipse...",
        "index": 645
    },
    {
        "Name": "ByLoftGuides",
        "categories": [
            "Geometry",
            "PolySurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/PolySurface/Create",
        "inDepth": "Add in-depth information about ByLoftGuides...",
        "index": 646
    },
    {
        "Name": "BySolid",
        "categories": [
            "Geometry",
            "PolySurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/PolySurface/Create",
        "inDepth": "Add in-depth information about BySolid...",
        "index": 647
    },
    {
        "Name": "BySweep (rail, crossSection)",
        "categories": [
            "Geometry",
            "PolySurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/PolySurface/Create",
        "inDepth": "Add in-depth information about BySweep (rail, crossSection)...",
        "index": 648
    },
    {
        "Name": "BySweep (rail, profile)",
        "categories": [
            "Geometry",
            "PolySurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/PolySurface/Create",
        "inDepth": "Add in-depth information about BySweep (rail, profile)...",
        "index": 649
    },
    {
        "Name": "EdgeCount",
        "categories": [
            "Geometry",
            "PolySurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/PolySurface/Action",
        "inDepth": "Add in-depth information about EdgeCount...",
        "index": 650
    },
    {
        "Name": "ExtractSolids",
        "categories": [
            "Geometry",
            "PolySurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/PolySurface/Action",
        "inDepth": "Add in-depth information about ExtractSolids...",
        "index": 651
    },
    {
        "Name": "LocateSurfacesByLine",
        "categories": [
            "Geometry",
            "PolySurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/PolySurface/Action",
        "inDepth": "Add in-depth information about LocateSurfacesByLine...",
        "index": 652
    },
    {
        "Name": "LocateSurfacesByPoint",
        "categories": [
            "Geometry",
            "PolySurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/PolySurface/Action",
        "inDepth": "Add in-depth information about LocateSurfacesByPoint...",
        "index": 653
    },
    {
        "Name": "SurfaceCount",
        "categories": [
            "Geometry",
            "PolySurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/PolySurface/Action",
        "inDepth": "Add in-depth information about SurfaceCount...",
        "index": 654
    },
    {
        "Name": "Surfaces",
        "categories": [
            "Geometry",
            "PolySurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/PolySurface/Action",
        "inDepth": "Add in-depth information about Surfaces...",
        "index": 655
    },
    {
        "Name": "UnconnectedBoundaries",
        "categories": [
            "Geometry",
            "PolySurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/PolySurface/Action",
        "inDepth": "Add in-depth information about UnconnectedBoundaries...",
        "index": 656
    },
    {
        "Name": "VertexCount",
        "categories": [
            "Geometry",
            "PolySurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/PolySurface/Action",
        "inDepth": "Add in-depth information about VertexCount...",
        "index": 657
    },
    {
        "Name": "ByFourPoints",
        "categories": [
            "Geometry",
            "Sphere"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Sphere/Create",
        "inDepth": "Add in-depth information about ByFourPoints...",
        "index": 658
    },
    {
        "Name": "Join (surface, otherSurfaces)",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Surface/Action",
        "inDepth": "Add in-depth information about Join (surface, otherSurfaces)...",
        "index": 659
    },
    {
        "Name": "Join (surface, otherSurface)",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Surface/Action",
        "inDepth": "Add in-depth information about Join (surface, otherSurface)...",
        "index": 660
    },
    {
        "Name": "TrimWithEdgeLoops",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Surface/Action",
        "inDepth": "Add in-depth information about TrimWithEdgeLoops...",
        "index": 661
    },
    {
        "Name": "Closed",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Surface/Query",
        "inDepth": "Add in-depth information about Closed...",
        "index": 662
    },
    {
        "Name": "ClosedInU",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Surface/Query",
        "inDepth": "Add in-depth information about ClosedInU...",
        "index": 663
    },
    {
        "Name": "ClosedInV",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Surface/Query",
        "inDepth": "Add in-depth information about ClosedInV...",
        "index": 664
    },
    {
        "Name": "Perimeter",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Surface/Query",
        "inDepth": "Add in-depth information about Perimeter...",
        "index": 665
    },
    {
        "Name": "ByParametersOnSurface",
        "categories": [
            "Geometry",
            "Tessellation",
            "Delaunay"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Tessellation/Delaunay/Action",
        "inDepth": "Add in-depth information about ByParametersOnSurface...",
        "index": 666
    },
    {
        "Name": "Faces",
        "categories": [
            "Geometry",
            "Topology"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Topology/Query",
        "inDepth": "Add in-depth information about Faces...",
        "index": 667
    },
    {
        "Name": "ByCoordinates",
        "categories": [
            "Geometry",
            "UV"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/UV/Create",
        "inDepth": "Add in-depth information about ByCoordinates...",
        "index": 668
    },
    {
        "Name": "U",
        "categories": [
            "Geometry",
            "UV"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/UV/Query",
        "inDepth": "Add in-depth information about U...",
        "index": 669
    },
    {
        "Name": "V",
        "categories": [
            "Geometry",
            "UV"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/UV/Query",
        "inDepth": "Add in-depth information about V...",
        "index": 670
    },
    {
        "Name": "ByCoordinates (x, y, z, normalized)",
        "categories": [
            "Geometry",
            "Vector"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vector/Create",
        "inDepth": "Add in-depth information about ByCoordinates (x, y, z, normalized)...",
        "index": 671
    },
    {
        "Name": "ByTwoPoints",
        "categories": [
            "Geometry",
            "Vector"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vector/Create",
        "inDepth": "Add in-depth information about ByTwoPoints...",
        "index": 672
    },
    {
        "Name": "AngleAboutAxis",
        "categories": [
            "Geometry",
            "Vector"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "Add in-depth information about AngleAboutAxis...",
        "index": 673
    },
    {
        "Name": "AngleWithVector",
        "categories": [
            "Geometry",
            "Vector"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "Add in-depth information about AngleWithVector...",
        "index": 674
    },
    {
        "Name": "AsPoint",
        "categories": [
            "Geometry",
            "Vector"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "Add in-depth information about AsPoint...",
        "index": 675
    },
    {
        "Name": "Cross",
        "categories": [
            "Geometry",
            "Vector"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "Add in-depth information about Cross...",
        "index": 676
    },
    {
        "Name": "Dot",
        "categories": [
            "Geometry",
            "Vector"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "Add in-depth information about Dot...",
        "index": 677
    },
    {
        "Name": "IsParallel",
        "categories": [
            "Geometry",
            "Vector"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "Add in-depth information about IsParallel...",
        "index": 678
    },
    {
        "Name": "Normalized",
        "categories": [
            "Geometry",
            "Vector"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "Add in-depth information about Normalized...",
        "index": 679
    },
    {
        "Name": "Rotate (vector, origin, degrees)",
        "categories": [
            "Geometry",
            "Vector"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "Add in-depth information about Rotate (vector, origin, degrees)...",
        "index": 680
    },
    {
        "Name": "Rotate (vector, axis, degrees)",
        "categories": [
            "Geometry",
            "Vector"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "Add in-depth information about Rotate (vector, axis, degrees)...",
        "index": 681
    },
    {
        "Name": "Scale (vector, scale_factor)",
        "categories": [
            "Geometry",
            "Vector"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "Add in-depth information about Scale (vector, scale_factor)...",
        "index": 682
    },
    {
        "Name": "Scale (vector, xScaleFactor, yScaleFactor, zScaleFactor)",
        "categories": [
            "Geometry",
            "Vector"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "Add in-depth information about Scale (vector, xScaleFactor, yScaleFactor, zScaleFactor)...",
        "index": 683
    },
    {
        "Name": "Transform",
        "categories": [
            "Geometry",
            "Vector"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "Add in-depth information about Transform...",
        "index": 684
    },
    {
        "Name": "AdjacentEdges",
        "categories": [
            "Geometry",
            "Vertex"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vertex/Query",
        "inDepth": "Add in-depth information about AdjacentEdges...",
        "index": 685
    },
    {
        "Name": "PointGeometry",
        "categories": [
            "Geometry",
            "Vertex"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vertex/Query",
        "inDepth": "Add in-depth information about PointGeometry...",
        "index": 686
    },
    {
        "Name": "IsAlmostEqualTo",
        "categories": [
            "Analyze",
            "AnalysisExtensions"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Analyze/AnalysisExtensions/Action",
        "inDepth": "Add in-depth information about IsAlmostEqualTo...",
        "index": 465
    },
    {
        "Name": "Count",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about Count...",
        "index": 688
    },
    {
        "Name": "Flatten",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about Flatten...",
        "index": 689
    },
    {
        "Name": "IndexOf",
        "categories": [
            "BuiltIn"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "BuiltIn/Action",
        "inDepth": "Add in-depth information about IndexOf...",
        "index": 690
    },
    {
        "Name": "Components",
        "categories": [
            "Core",
            "DateTime"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/DateTime/Action",
        "inDepth": "Add in-depth information about Components...",
        "index": 691
    },
    {
        "Name": "Add",
        "categories": [
            "Core",
            "TimeSpan"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/TimeSpan/Action",
        "inDepth": "Add in-depth information about Add...",
        "index": 692
    },
    {
        "Name": "Components",
        "categories": [
            "Core",
            "TimeSpan"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/TimeSpan/Action",
        "inDepth": "Add in-depth information about Components...",
        "index": 693
    },
    {
        "Name": "FromString",
        "categories": [
            "Core",
            "TimeSpan"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/TimeSpan/Action",
        "inDepth": "Add in-depth information about FromString...",
        "index": 694
    },
    {
        "Name": "Subtract",
        "categories": [
            "Core",
            "TimeSpan"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/TimeSpan/Action",
        "inDepth": "Add in-depth information about Subtract...",
        "index": 695
    },
    {
        "Name": "MaxValue",
        "categories": [
            "Core",
            "TimeSpan"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Core/TimeSpan/Query",
        "inDepth": "Add in-depth information about MaxValue...",
        "index": 696
    },
    {
        "Name": "IsEmpty",
        "categories": [
            "Geometry",
            "BoundingBox"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/BoundingBox/Action",
        "inDepth": "Add in-depth information about IsEmpty...",
        "index": 697
    },
    {
        "Name": "ByCylindricalCoordinates",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Create",
        "inDepth": "Add in-depth information about ByCylindricalCoordinates...",
        "index": 698
    },
    {
        "Name": "BySphericalCoordinates",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Create",
        "inDepth": "Add in-depth information about BySphericalCoordinates...",
        "index": 699
    },
    {
        "Name": "Mirror",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Add in-depth information about Mirror...",
        "index": 700
    },
    {
        "Name": "Scale1D",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Add in-depth information about Scale1D...",
        "index": 701
    },
    {
        "Name": "Scale2D",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Action",
        "inDepth": "Add in-depth information about Scale2D...",
        "index": 702
    },
    {
        "Name": "Origin",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Query",
        "inDepth": "Add in-depth information about Origin...",
        "index": 703
    },
    {
        "Name": "XAxis",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Query",
        "inDepth": "Add in-depth information about XAxis...",
        "index": 704
    },
    {
        "Name": "YAxis",
        "categories": [
            "Geometry",
            "CoordinateSystem"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/CoordinateSystem/Query",
        "inDepth": "Add in-depth information about YAxis...",
        "index": 705
    },
    {
        "Name": "ByPointsRadius",
        "categories": [
            "Geometry",
            "Cylinder"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Cylinder/Create",
        "inDepth": "Add in-depth information about ByPointsRadius...",
        "index": 706
    },
    {
        "Name": "Radius",
        "categories": [
            "Geometry",
            "Cylinder"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Cylinder/Query",
        "inDepth": "Add in-depth information about Radius...",
        "index": 707
    },
    {
        "Name": "IsAlmostEqualTo",
        "categories": [
            "Geometry",
            "Geometry"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Geometry/Action",
        "inDepth": "Add in-depth information about IsAlmostEqualTo...",
        "index": 708
    },
    {
        "Name": "Count",
        "categories": [
            "Geometry",
            "IndexGroup"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/IndexGroup/Query",
        "inDepth": "Add in-depth information about Count...",
        "index": 709
    },
    {
        "Name": "ByControlPointsWeightsKnots",
        "categories": [
            "Geometry",
            "NurbsSurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/NurbsSurface/Create",
        "inDepth": "Add in-depth information about ByControlPointsWeightsKnots...",
        "index": 710
    },
    {
        "Name": "ByPointsTangents",
        "categories": [
            "Geometry",
            "NurbsSurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/NurbsSurface/Create",
        "inDepth": "Add in-depth information about ByPointsTangents...",
        "index": 711
    },
    {
        "Name": "ControlPoints",
        "categories": [
            "Geometry",
            "NurbsSurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/NurbsSurface/Action",
        "inDepth": "Add in-depth information about ControlPoints...",
        "index": 712
    },
    {
        "Name": "Weights",
        "categories": [
            "Geometry",
            "NurbsSurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/NurbsSurface/Action",
        "inDepth": "Add in-depth information about Weights...",
        "index": 713
    },
    {
        "Name": "IsRational",
        "categories": [
            "Geometry",
            "NurbsSurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/NurbsSurface/Query",
        "inDepth": "Add in-depth information about IsRational...",
        "index": 714
    },
    {
        "Name": "Origin",
        "categories": [
            "Geometry",
            "Point"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Point/Create",
        "inDepth": "Add in-depth information about Origin...",
        "index": 715
    },
    {
        "Name": "Fillet",
        "categories": [
            "Geometry",
            "PolyCurve"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/PolyCurve/Action",
        "inDepth": "Add in-depth information about Fillet...",
        "index": 716
    },
    {
        "Name": "ByJoinedSurfaces",
        "categories": [
            "Geometry",
            "PolySurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/PolySurface/Create",
        "inDepth": "Add in-depth information about ByJoinedSurfaces...",
        "index": 717
    },
    {
        "Name": "ByLoft (crossSections)",
        "categories": [
            "Geometry",
            "PolySurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/PolySurface/Create",
        "inDepth": "Add in-depth information about ByLoft (crossSections)...",
        "index": 718
    },
    {
        "Name": "ByLoft (crossSections, guideCurve)",
        "categories": [
            "Geometry",
            "PolySurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/PolySurface/Create",
        "inDepth": "Add in-depth information about ByLoft (crossSections, guideCurve)...",
        "index": 719
    },
    {
        "Name": "Chamfer",
        "categories": [
            "Geometry",
            "PolySurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/PolySurface/Action",
        "inDepth": "Add in-depth information about Chamfer...",
        "index": 720
    },
    {
        "Name": "Fillet",
        "categories": [
            "Geometry",
            "PolySurface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/PolySurface/Action",
        "inDepth": "Add in-depth information about Fillet...",
        "index": 721
    },
    {
        "Name": "BySweep2Rails",
        "categories": [
            "Geometry",
            "Solid"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Solid/Create",
        "inDepth": "Add in-depth information about BySweep2Rails...",
        "index": 722
    },
    {
        "Name": "Area",
        "categories": [
            "Geometry",
            "Surface"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Surface/Query",
        "inDepth": "Add in-depth information about Area...",
        "index": 723
    },
    {
        "Name": "ByPoints",
        "categories": [
            "Geometry",
            "Tessellation",
            "ConvexHull"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Tessellation/ConvexHull/Action",
        "inDepth": "Add in-depth information about ByPoints...",
        "index": 724
    },
    {
        "Name": "ByPoints",
        "categories": [
            "Geometry",
            "Tessellation",
            "Delaunay"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Tessellation/Delaunay/Action",
        "inDepth": "Add in-depth information about ByPoints...",
        "index": 725
    },
    {
        "Name": "ByParametersOnSurface",
        "categories": [
            "Geometry",
            "Tessellation",
            "Voronoi"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Tessellation/Voronoi/Action",
        "inDepth": "Add in-depth information about ByParametersOnSurface...",
        "index": 726
    },
    {
        "Name": "Edges",
        "categories": [
            "Geometry",
            "Topology"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Topology/Query",
        "inDepth": "Add in-depth information about Edges...",
        "index": 727
    },
    {
        "Name": "Vertices",
        "categories": [
            "Geometry",
            "Topology"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Topology/Query",
        "inDepth": "Add in-depth information about Vertices...",
        "index": 728
    },
    {
        "Name": "ByCoordinates (x, y, z)",
        "categories": [
            "Geometry",
            "Vector"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vector/Create",
        "inDepth": "Add in-depth information about ByCoordinates (x, y, z)...",
        "index": 729
    },
    {
        "Name": "XAxis",
        "categories": [
            "Geometry",
            "Vector"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vector/Create",
        "inDepth": "Add in-depth information about XAxis...",
        "index": 730
    },
    {
        "Name": "YAxis",
        "categories": [
            "Geometry",
            "Vector"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vector/Create",
        "inDepth": "Add in-depth information about YAxis...",
        "index": 731
    },
    {
        "Name": "ZAxis",
        "categories": [
            "Geometry",
            "Vector"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vector/Create",
        "inDepth": "Add in-depth information about ZAxis...",
        "index": 732
    },
    {
        "Name": "Add",
        "categories": [
            "Geometry",
            "Vector"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "Add in-depth information about Add...",
        "index": 733
    },
    {
        "Name": "IsAlmostEqualTo",
        "categories": [
            "Geometry",
            "Vector"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "Add in-depth information about IsAlmostEqualTo...",
        "index": 734
    },
    {
        "Name": "Reverse",
        "categories": [
            "Geometry",
            "Vector"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "Add in-depth information about Reverse...",
        "index": 735
    },
    {
        "Name": "Subtract",
        "categories": [
            "Geometry",
            "Vector"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vector/Action",
        "inDepth": "Add in-depth information about Subtract...",
        "index": 736
    },
    {
        "Name": "Length",
        "categories": [
            "Geometry",
            "Vector"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vector/Query",
        "inDepth": "Add in-depth information about Length...",
        "index": 737
    },
    {
        "Name": "X",
        "categories": [
            "Geometry",
            "Vector"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vector/Query",
        "inDepth": "Add in-depth information about X...",
        "index": 738
    },
    {
        "Name": "Y",
        "categories": [
            "Geometry",
            "Vector"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vector/Query",
        "inDepth": "Add in-depth information about Y...",
        "index": 739
    },
    {
        "Name": "Z",
        "categories": [
            "Geometry",
            "Vector"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vector/Query",
        "inDepth": "Add in-depth information about Z...",
        "index": 740
    },
    {
        "Name": "AdjacentFaces",
        "categories": [
            "Geometry",
            "Vertex"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Geometry/Vertex/Query",
        "inDepth": "Add in-depth information about AdjacentFaces...",
        "index": 741
    },
    {
        "Name": "ReadFromFile",
        "categories": [
            "Office",
            "Excel"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Office/Excel/Action",
        "inDepth": "Add in-depth information about ReadFromFile... ",
        "index": 742
    },
    {
        "Name": "WriteToFile",
        "categories": [
            "Office",
            "Excel"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Office/Excel/Action",
        "inDepth": "Add in-depth information about WriteToFile...",
        "index": 743
    },
    {
        "Name": "ReadFromFile",
        "categories": [
            "Office",
            "Excel"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Office/Excel/Action",
        "inDepth": "Add in-depth information about ReadFromFile... ",
        "index": 742
    },
    {
        "Name": "ReadFromFile",
        "categories": [
            "Office",
            "Excel"
        ],
        "dynFile": [],
        "imageFile": [],
        "folderPath": "Office/Excel/Action",
        "inDepth": "Add in-depth information about ReadFromFile... ",
        "index": 742
    }
]